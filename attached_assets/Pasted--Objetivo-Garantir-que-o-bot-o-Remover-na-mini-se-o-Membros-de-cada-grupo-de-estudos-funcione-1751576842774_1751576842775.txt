

Objetivo: Garantir que o botão "Remover" na mini-seção "Membros" de cada grupo de estudos funcione exatamente como o botão "Sair" na grade de "Meus Grupos", removendo o usuário escolhido pelo administrador do grupo de estudos da tabela membros_grupos no Supabase. A remoção deve ocorrer sem exibir mensagens de erro ao usuário, mesmo em falhas temporárias, usando retries robustos. A interface deve ser atualizada imediatamente, com sincronização em tempo real via Realtime, preservando o design atual da mini-seção "Membros" e todas as outras funcionalidades.



Instruções Gerais





Escopo Restrito: Modifique apenas as funções accessGroup, removeMember, loadMembers, e o listener Realtime no arquivo script.js. Não altere o design (HTML, CSS, layout, estilos) das outras mini-seções ("Discussões", "Ajustes", "Sobre", "Notificações"), nem dos modals de "Adicionar Grupo" e "Criar Novo Grupo", nem outras partes do código que funcionam.



Preservação do Design: Mantenha o layout, os estilos e a estrutura HTML dos mini-cards e da mini-seção "Membros" intactos, ajustando apenas a lógica de remoção.



Funcionalidades de Remoção:





O botão "Remover" deve replicar a lógica do botão "Sair" da grade "Meus Grupos", que exclui o usuário autenticado, mas agora aplicado ao user_id do membro selecionado pelo administrador.



Garantir que a exclusão na tabela membros_grupos seja bem-sucedida, mesmo em caso de falhas, usando retries (máximo de 5 tentativas com intervalo de 500ms).



Atualizar a interface removendo o mini-card imediatamente e recarregar a lista de membros.



Sincronizar a remoção em tempo real para todos os usuários via Realtime.



Tratamento de Erros: Suprimir mensagens de erro visíveis ao usuário, logando falhas apenas no console para depuração.



Testes Completos: Após as alterações, realize testes abrangentes e envie os logs.



Descrição da Interface da Mini-Seção "Membros" (Preservação do Design)





Mini-Cards: Cada mini-card exibe o perfil de um usuário com o ícone de retirar membro (.remove-member-icon), que abre o modal de confirmação.



Modal: Mantém o comportamento atual (texto, "Cancelar", "Remover"), mas a ação "Remover" usa a lógica do botão "Sair".



Restrição: Não modificar elementos HTML/CSS, apenas ajustar a lógica.



Passos para a IA Programadora





Acesse o Arquivo:





Abra o arquivo script.js e localize as funções accessGroup, removeMember, loadMembers, e o listener Realtime.



Revise e Ajuste removeMember com Lógica de "Sair":





Replique a query de exclusão do botão "Sair" (supabase.from('membros_grupos').delete().eq('grupo_id', groupId).eq('user_id', currentUserId)), substituindo currentUserId pelo userId do membro selecionado.



Adicione retries robustos (5 tentativas, 500ms de intervalo) para garantir sucesso.



Remova o mini-card imediatamente após o clique e recarregue loadMembers para sincronização.



Logue erros no console, mas evite alertas ao usuário.



Otimize loadMembers:





Garantir que a função recarregue a lista de membros corretamente após a exclusão.



Ajuste o Listener Realtime:





Atualizar a lógica para remover o mini-card com base no payload.old.user_id e recarregar loadMembers.



Aplique Configurações:





Confirme que as permissões da tabela membros_grupos permitem exclusão por administradores.



Valide a autenticação antes da exclusão.



Revise e Analise:





Teste o fluxo completo (clique no ícone, modal, "Remover") e verifique os logs.



Confirme que a exclusão é registrada no Supabase e refletida no DOM sem erros visíveis.



Seja Precisa e Robusta:





Garanta que a solução seja infalível, alinhada ao comportamento do "Sair", e livre de bugs.



Modificações no Frontend (JavaScript)

 // Atualizar accessGroup com remoção de membro igual ao botão "Sair" let currentGroupId = null; // Variável global para armazenar o groupId ativo

const accessGroup = async (groupId) => { try { console.log(Acessando grupo ${groupId}...); const userId = await validateUserAuth(); if (!userId) { console.error('Usuário não autenticado.'); alert('Usuário não autenticado.'); return; }

// Validar e armazenar o groupId
if (!groupId || typeof groupId !== 'string') {
  console.error('ID do grupo inválido:', groupId);
  alert('ID do grupo inválido. Verifique o console.');
  return;
}
currentGroupId = groupId;

// Ocultar o cabeçalho de Minhas Turmas
const header = document.querySelector('.groups-header');
if (header) header.style.display = 'none';

// Cache para nomes e imagens de perfil
const userCache = new Map();
const { data: users, error: usersError } = await supabase
  .from('auth.users')
  .select('id, user_metadata')
  .in('id', (await supabase.from('membros_grupos').select('user_id').eq('grupo_id', groupId)).data.map(u => u.user_id));
if (usersError) throw usersError;
if (!users) throw new Error('Nenhum usuário encontrado no grupo.');
users.forEach(user => {
  const metadata = user.user_metadata || {};
  userCache.set(user.id, {
    name: metadata.name || `Usuário ${user.id.slice(0, 5)}`,
    avatar_url: metadata.avatar_url || null
  });
});
console.log(`Cache de usuários populado com ${userCache.size} entradas.`);

// Buscar dados do grupo com retries
const fetchGroupData = async (groupId, retries = 3, delay = 2000) => {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const { data: groupData, error: groupError } = await supabase
        .from('grupos')
        .select('nome, descricao, disciplina, topico_especifico, codigo_unico, tags, privacidade')
        .eq('id', groupId)
        .single();
      if (groupError) throw groupError;
      if (!groupData) throw new Error(`Dados do grupo ${groupId} não encontrados.`);
      return groupData;
    } catch (error) {
      console.warn(`Tentativa ${attempt} de buscar dados do grupo ${groupId} falhou:`, error.message);
      if (attempt === retries) throw error;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};
const groupData = await fetchGroupData(groupId);

// Buscar imagens do grupo com retries e URL pública
const fetchGroupImages = async (groupId, retries = 3, delay = 2000) => {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const { data: bannerData, error: bannerError } = await supabase.storage
        .from('group-banners')
        .createSignedUrl(`${groupId}-banner`, 3600);
      const { data: photoData, error: photoError } = await supabase.storage
        .from('group-photos')
        .createSignedUrl(`${groupId}-photo`, 3600);
      if (bannerError && bannerError.message !== 'File not found') throw bannerError;
      if (photoError && photoError.message !== 'File not found') throw photoError;
      return {
        bannerUrl: bannerData ? bannerData.signedUrl : null,
        photoUrl: photoData ? photoData.signedUrl : null
      };
    } catch (error) {
      console.warn(`Tentativa ${attempt} de buscar imagens do grupo ${groupId} falhou:`, error.message);
      if (attempt === retries) throw error;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};
const { bannerUrl, photoUrl } = await fetchGroupImages(groupId);

// Contagem de membros online
let onlineCount = 0;
const updateOnlineCount = () => {
  const now = new Date();
  return supabase
    .from('user_sessions')
    .select('user_id', { count: 'exact' })
    .eq('grupo_id', groupId)
    .gte('last_active', new Date(now - 30 * 1000).toISOString())
    .then(({ count }) => {
      onlineCount = count || 0;
      return onlineCount;
    })
    .catch(err => {
      console.error('Erro ao atualizar contagem de online:', err.message);
      return 0;
    });
};
setInterval(() => {
  updateOnlineCount().then(count => {
    const onlineNumber = document.getElementById('online-number');
    if (onlineNumber) onlineNumber.textContent = count;
  });
}, 15000);
updateOnlineCount().then(count => {
  const onlineNumber = document.getElementById('online-number');
  if (onlineNumber) onlineNumber.textContent = count;
});

// Preservar a interface existente
const groupInterface = document.querySelector('#group-interface') || document.createElement('div');
if (!groupInterface.id) {
  groupInterface.id = 'group-interface';
  groupInterface.style.cssText = 'margin-left: 250px; padding: 20px;';
  document.getElementById('main-content').innerHTML = '';
  document.getElementById('main-content').appendChild(groupInterface);
}

// Exibir imagens na interface
const bannerImg = document.getElementById('group-banner');
if (bannerImg) bannerImg.src = bannerUrl || 'default-banner.png';
const photoImg = document.getElementById('group-photo');
if (photoImg) photoImg.src = photoUrl || 'default-photo.png';

// Preencher e habilitar edição dos campos
const fillAndEnableEditing = (groupData) => {
  try {
    const nameInput = document.querySelector('#group-name');
    const descriptionInput = document.querySelector('#group-description');
    const disciplineInput = document.querySelector('#group-discipline');
    const topicInput = document.querySelector('#group-topic');
    const tagsInput = document.querySelector('#group-tags');
    const privacySelect = document.querySelector('#group-privacy');

    if (!nameInput || !descriptionInput || !disciplineInput || !topicInput || !tagsInput || !privacySelect) {
      console.error(`Campos da mini-seção "Ajustes" não encontrados para o grupo ${groupId}. Verifique os seletores.`);
      return;
    }

    nameInput.removeAttribute('readonly');
    descriptionInput.removeAttribute('readonly');
    disciplineInput.removeAttribute('readonly');
    topicInput.removeAttribute('readonly');
    tagsInput.removeAttribute('readonly');
    privacySelect.removeAttribute('disabled');

    nameInput.value = groupData.nome || '';
    descriptionInput.value = groupData.descricao || '';
    disciplineInput.value = groupData.disciplina || '';
    topicInput.value = groupData.topico_especifico || '';
    tagsInput.value = Array.isArray(groupData.tags) ? groupData.tags.join(', ') : groupData.tags || '';
    privacySelect.value = groupData.privacidade || 'public';

    console.log(`Campos da mini-seção "Ajustes" habilitados para edição para o grupo ${groupId}.`);
  } catch (error) {
    console.error(`Erro ao habilitar edição dos campos para o grupo ${groupId}:`, error.message);
    alert('Erro ao carregar os dados dos ajustes. Verifique o console.');
  }
};

// Função para salvar alterações no Supabase
const saveChanges = async (groupId) => {
  try {
    const nameInput = document.querySelector('#group-name');
    const descriptionInput = document.querySelector('#group-description');
    const disciplineInput = document.querySelector('#group-discipline');
    const topicInput = document.querySelector('#group-topic');
    const tagsInput = document.querySelector('#group-tags');
    const privacySelect = document.querySelector('#group-privacy');

    if (!nameInput || !descriptionInput || !disciplineInput || !topicInput || !tagsInput || !privacySelect) {
      console.error(`Campos da mini-seção "Ajustes" não encontrados para salvar alterações no grupo ${groupId}.`);
      alert('Erro ao localizar campos para salvar. Verifique o console.');
      return;
    }

    if (!nameInput.value.trim()) {
      alert('O Nome do Grupo é obrigatório.');
      return;
    }

    const updates = {
      nome: nameInput.value.trim(),
      descricao: descriptionInput.value.trim(),
      disciplina: disciplineInput.value.trim(),
      topico_especifico: topicInput.value.trim(),
      tags: tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag),
      privacidade: privacySelect.value
    };

    const { error } = await supabase
      .from('grupos')
      .update(updates)
      .eq('id', groupId);

    if (error) throw error;

    console.log(`Alterações salvas com sucesso para o grupo ${groupId}.`);
    alert('Alterações salvas com sucesso!');
    const updatedData = await fetchGroupData(groupId);
    fillAndEnableEditing(updatedData);
  } catch (error) {
    console.error(`Erro ao salvar alterações para o grupo ${groupId}:`, error.message);
    alert('Erro ao salvar as alterações. Verifique o console.');
  }
};

// Função para carregar membros
const loadMembers = async (groupId, userCache, currentUserId, isAdminOrOwner) => {
  try {
    const membersContent = document.getElementById('members-content');
    if (!membersContent) {
      console.error('Seção "Membros" não encontrada para o grupo ${groupId}.');
      return;
    }
    membersContent.innerHTML = ''; // Limpar conteúdo existente