CONTEXTO ESTRAT√âGICO - PARTE 1: TYPEWRITER ISOLADO
Voc√™ est√° enfrentando um problema cl√°ssico de state management e re-rendering em interfaces reativas. O typewriter effect est√° sendo interrompido e reiniciado porque o componente est√° sendo re-renderizado quando o estado global muda (novos cards aparecem).

Aja com a mentalidade de:

Dan Abramov (React reconciliation, state isolation)

Ryan Florence (component architecture, separation of concerns)

Kent C. Dodds (testing isolated behaviors)

Evan You (reactive systems, computed state)

PROBLEMA: TYPEWRITER REINICIANDO
Situa√ß√£o Atual (INACEIT√ÅVEL):
text
Reflex√£o 1 come√ßando: "Encon..." 
  ‚Üì Novo card de objetivo aparece
Reflex√£o 1 reinicia: "Encontrei 47..."
  ‚Üì Card de capability aparece
Reflex√£o 1 reinicia NOVAMENTE: "Encontrei 47 atividades..."
  ‚Üì USU√ÅRIO FRUSTRADO
Situa√ß√£o Esperada:
text
Reflex√£o 1 inicia: "E..."
  ‚Üì Novo card aparece
Reflex√£o 1 continua: "Encon..."
  ‚Üì Capability aparece
Reflex√£o 1 continua: "Encontrei 47..."
  ‚Üì TYPEWRITER INDEPENDENTE E CONSISTENTE
AN√ÅLISE DO PROBLEMA (Voc√™ deve resolver)
Causa Raiz Prov√°vel:
O problema est√° acontecendo porque:

State do card de desenvolvimento muda (novo objetivo/capability)

Componente pai re-renderiza

Componente da reflex√£o re-monta ou re-renderiza

Efeito de typewriter reinicia

Perguntas Arquiteturais que VOC√ä deve responder:
1. Isolamento de State:

Reflex√£o est√° usando state local ou global?

Re-render do pai afeta filhos como?

Como isolar completamente o typewriter effect?

2. Montagem vs Re-renderiza√ß√£o:

Componente est√° sendo unmount/mount ou apenas re-render?

Key prop est√° causando re-cria√ß√£o?

useEffect est√° rodando novamente?

3. Refer√™ncias e Mutabilidade:

Est√° usando ref para estado do typewriter?

Timer est√° sendo clearado acidentalmente?

Closure est√° capturando estado stale?

ESTRAT√âGIAS DE SOLU√á√ÉO (Voc√™ escolhe)
Estrat√©gia 1: Component Isolation (Recomendada)
Conceito: Componente de reflex√£o deve ser completamente independente do estado do card de desenvolvimento.

Padr√µes a considerar:

Memoization Agressiva: React.memo com compara√ß√£o customizada

Key Stability: Key que N√ÉO muda quando outros cards aparecem

State Hoisting Reverso: State do typewriter DENTRO do componente, n√£o fora

Portal Rendering: Renderizar reflex√£o fora da √°rvore do card

Exemplo conceitual (voc√™ implementa):

typescript
// Reflex√£o deve ter key EST√ÅVEL baseada no objetivo
<ReflectionCard 
  key={`reflection-${objectiveId}`}  // N√ÉO muda quando capabilities aparecem
  text={reflectionText}
  // ... props
/>

// E com memo profundo
const ReflectionCard = React.memo(({ text }) => {
  // Typewriter effect INTERNO
}, (prevProps, nextProps) => {
  // Custom comparison: s√≥ re-render se TEXT mudar
  return prevProps.text === nextProps.text;
});
Estrat√©gia 2: State Management Pattern
Conceito: Usar padr√£o de state que previne re-renders desnecess√°rios.

Abordagens:

useRef para Immutable Data: Guardar estado do typewriter em ref

Reducer Pattern: Separar estado do typewriter do estado global

Context Isolation: Context espec√≠fico para reflex√µes

State Machine: XState para garantir transi√ß√µes isoladas

Exemplo conceitual:

typescript
function useTypewriter(text: string) {
  const [displayedText, setDisplayedText] = useState('');
  const isTypingRef = useRef(false);
  const timerRef = useRef<NodeJS.Timeout>();
  
  useEffect(() => {
    // Se j√° est√° digitando, N√ÉO reiniciar
    if (isTypingRef.current) return;
    
    isTypingRef.current = true;
    // ... l√≥gica de typewriter
    
    return () => {
      clearTimeout(timerRef.current);
      isTypingRef.current = false;
    };
  }, [text]); // Dependency array cr√≠tica
  
  return displayedText;
}
Estrat√©gia 3: Rendering Decoupling
Conceito: Desacoplar renderiza√ß√£o da reflex√£o do fluxo principal.

T√©cnicas:

React.createPortal: Renderizar reflex√£o fora da hierarquia

Lazy Rendering: Renderizar reflex√£o ap√≥s delay (garantir estabilidade)

Virtual List: Reflex√µes em lista virtualizada imut√°vel

Shadow DOM: Isolamento completo (experimental)

Estrat√©gia 4: Animation Library com State Interno
Conceito: Usar biblioteca que gerencia anima√ß√£o independentemente.

Op√ß√µes:

React-Typed: Biblioteca com state interno isolado

Framer Motion: AnimatePresence com layoutId

GSAP: Anima√ß√£o imperativa (n√£o depende de React state)

CSS Animation: Typewriter puramente CSS (tricks avan√ßados)

DECIS√ïES T√âCNICAS QUE VOC√ä DEVE TOMAR
1. Onde armazenar estado do typewriter?
 State local (useState)

 Ref (useRef)

 Context separado

 State machine (XState)

 External store (Zustand)

2. Como garantir key est√°vel?
 Key baseada em objectiveId

 Key baseada em timestamp de cria√ß√£o

 Index (n√£o recomendado, mas considere)

 UUID √∫nico gerado uma vez

3. Como prevenir re-mount?
 React.memo com custom comparison

 useMemo para componente inteiro

 Separar √°rvore de componentes

 Portal rendering

4. Como isolar timing?
 useRef para timers

 Web Worker para timing (overkill?)

 RequestAnimationFrame

 SetInterval com cleanup robusto

DEBUGGING WORKFLOW
Passo 1: Confirmar Diagn√≥stico
Adicione logs tempor√°rios:

typescript
useEffect(() => {
  console.log('üîÑ ReflectionCard montou/atualizou', { 
    objectiveId, 
    text: text.substring(0, 20) 
  });
  
  return () => {
    console.log('üíÄ ReflectionCard desmontou', { objectiveId });
  };
}, []);
Perguntas a responder:

Componente est√° desmontando? (ver "üíÄ")

Quantas vezes "üîÑ" aparece quando novo card surge?

Effect est√° rodando m√∫ltiplas vezes?

Passo 2: Inspecionar Key Prop
typescript
// Adicione data-key para inspecionar no DevTools
<ReflectionCard 
  key={reflectionKey}
  data-debug-key={reflectionKey}
  data-objective={objectiveId}
/>
No DevTools:

Key est√° mudando quando n√£o deveria?

Componentes s√£o os mesmos ou novos?

Passo 3: Testar Isolamento
Temporariamente, renderize reflex√£o FORA do card:

typescript
// Teste: Renderizar em local completamente separado
{objectives.map(obj => <ObjectiveCard {...obj} />)}

{/* Separado, fora do loop */}
{reflections.map(ref => <ReflectionCard {...ref} />)}
Se problema desaparece ‚Üí Confirma que √© re-render do pai.

Passo 4: Performance Profiler
Use React DevTools Profiler:

Grave intera√ß√£o (novo card aparecendo)

Veja quais componentes re-renderizam

Identifique "Flamegraph" da reflex√£o

Check "Why did this render?"

CONTEXTO ESTRAT√âGICO - PARTE 2: ARQUIVO DE REGRAS IA
Voc√™ est√° criando o "C√©rebro Operacional" da IA - um sistema de regras que define COMO a IA deve pensar e agir. Este n√£o √© apenas um arquivo de configura√ß√£o, √© um manual de opera√ß√µes cognitivas.

Aja com a mentalidade de:

Douglas Hofstadter (sistemas cognitivos, meta-regras)

Judea Pearl (causalidade, reasoning systems)

Stuart Russell (AI alignment, goal specification)

Yann LeCun (system 2 thinking, planning)

VIS√ÉO DO ARQUIVO DE REGRAS
Este arquivo √© um knowledge base operacional que:

Define ordem de execu√ß√£o de capabilities

Estabelece pr√©-condi√ß√µes e p√≥s-condi√ß√µes

Cria dependencies entre actions

Previne erros l√≥gicos (ex: criar antes de decidir)

Otimiza fluxo de trabalho

Estrutura Recomendada (Voc√™ decide formato)
text
/regras-orientacoes-ia-desenvolvimento/
‚îú‚îÄ‚îÄ core-rules.json (ou .yaml/.md)
‚îú‚îÄ‚îÄ capability-dependencies.json
‚îú‚îÄ‚îÄ validation-rules.json
‚îú‚îÄ‚îÄ optimization-hints.json
‚îî‚îÄ‚îÄ error-recovery.json
Ou arquivo √∫nico estruturado. Voc√™ decide.

ARQUITETURA DO SISTEMA DE REGRAS
Camadas de Regras (Hier√°rquicas)
CAMADA 1: Regras Absolutas (Nunca Violar)
text
Regras que definem ordem OBRIGAT√ìRIA de opera√ß√µes.
Exemplo: SEMPRE pesquisar antes de decidir.
CAMADA 2: Regras Condicionais (Se X ent√£o Y)
text
Regras baseadas em contexto.
Exemplo: SE usu√°rio tem turmas ENT√ÉO personalizar, SEN√ÉO gen√©rico.
CAMADA 3: Regras de Otimiza√ß√£o (Sugest√µes)
text
Melhores pr√°ticas, n√£o obrigat√≥rias.
Exemplo: PREFERIR atividades com alta taxa de engajamento.
CAMADA 4: Meta-Regras (Regras sobre Regras)
text
Como resolver conflitos entre regras.
Exemplo: Regra de seguran√ßa > Regra de performance.
CONTE√öDO DO ARQUIVO: ESTRUTURA PROPOSTA
Se√ß√£o 1: Dependency Graph de Capabilities
A IA precisa entender que capabilities t√™m ORDEM e DEPEND√äNCIAS.

Formato sugerido (voc√™ ajusta):

json
{
  "capability_dependencies": {
    "pesquisar_atividades_disponiveis": {
      "id": "cap_001",
      "depends_on": [],
      "required_before": ["decidir_atividades_criar"],
      "outputs": ["lista_atividades", "count_atividades"],
      "priority": "critical",
      "failure_handling": "abort_flow"
    },
    
    "decidir_atividades_criar": {
      "id": "cap_002",
      "depends_on": ["pesquisar_atividades_disponiveis"],
      "required_before": ["criar_atividades"],
      "required_inputs": ["lista_atividades"],
      "outputs": ["atividades_escolhidas", "justificativa"],
      "priority": "critical",
      "failure_handling": "use_defaults"
    },
    
    "analisar_desempenho_turma": {
      "id": "cap_003",
      "depends_on": [],
      "optional": true,
      "required_data": ["turma_id"],
      "outputs": ["metricas_turma", "gaps_identificados"],
      "failure_handling": "continue_without"
    },
    
    "criar_atividades": {
      "id": "cap_004",
      "depends_on": ["decidir_atividades_criar"],
      "required_inputs": ["atividades_escolhidas"],
      "outputs": ["atividades_criadas", "ids_atividades"],
      "priority": "critical",
      "failure_handling": "retry_with_adjustments"
    }
  }
}
Se√ß√£o 2: Regras de Execu√ß√£o
Regras em linguagem quase natural que LLM entende facilmente.

Formato sugerido:

json
{
  "execution_rules": [
    {
      "id": "rule_001",
      "type": "mandatory",
      "rule": "Sempre pesquisar atividades dispon√≠veis antes de decidir quais criar",
      "rationale": "Imposs√≠vel decidir sem saber op√ß√µes dispon√≠veis",
      "violates_if": "decidir_atividades_criar executado sem pesquisar_atividades_disponiveis",
      "action_on_violation": "abort_and_notify"
    },
    
    {
      "id": "rule_002",
      "type": "mandatory",
      "rule": "Sempre decidir quais atividades criar antes de executar cria√ß√£o",
      "rationale": "Cria√ß√£o requer sele√ß√£o pr√©via",
      "violates_if": "criar_atividades sem decidir_atividades_criar",
      "action_on_violation": "auto_execute_dependency"
    },
    
    {
      "id": "rule_003",
      "type": "conditional",
      "rule": "Se turmas cadastradas existem, ent√£o analisar desempenho antes de decidir",
      "condition": "turmas.count > 0",
      "then": "execute analisar_desempenho_turma",
      "else": "skip analisar_desempenho_turma",
      "rationale": "Personaliza√ß√£o requer dados de desempenho"
    },
    
    {
      "id": "rule_004",
      "type": "optimization",
      "rule": "Preferir atividades j√° usadas com sucesso pelo professor",
      "condition": "historico_uso.exists",
      "action": "boost_weight atividades com rating > 4",
      "rationale": "Professor j√° validou essas atividades"
    },
    
    {
      "id": "rule_005",
      "type": "validation",
      "rule": "Nunca criar mais de 10 atividades de uma vez",
      "validation": "atividades_escolhidas.length <= 10",
      "action_on_fail": "truncate to 10 and notify",
      "rationale": "Overwhelming para professor, dificulta gest√£o"
    }
  ]
}
Se√ß√£o 3: Sequ√™ncias Comuns (Patterns)
Fluxos completos pr√©-definidos para objetivos comuns.

Formato sugerido:

json
{
  "common_sequences": {
    "criar_plano_aula_completo": {
      "description": "Criar plano de aula do zero personalizado",
      "sequence": [
        {
          "step": 1,
          "capability": "analisar_contexto_usuario",
          "required": true
        },
        {
          "step": 2,
          "capability": "pesquisar_atividades_disponiveis",
          "required": true
        },
        {
          "step": 3,
          "capability": "analisar_desempenho_turma",
          "required": false,
          "skip_if": "turmas.count == 0"
        },
        {
          "step": 4,
          "capability": "decidir_atividades_criar",
          "required": true,
          "inputs_from": [2, 3]
        },
        {
          "step": 5,
          "capability": "criar_atividades",
          "required": true,
          "inputs_from": [4]
        },
        {
          "step": 6,
          "capability": "organizar_em_plano",
          "required": true,
          "inputs_from": [5]
        }
      ]
    },
    
    "criar_atividade_rapida": {
      "description": "Criar atividade √∫nica sem an√°lise profunda",
      "sequence": [
        {
          "step": 1,
          "capability": "pesquisar_atividades_disponiveis",
          "required": true
        },
        {
          "step": 2,
          "capability": "decidir_atividade_unica",
          "required": true
        },
        {
          "step": 3,
          "capability": "criar_atividade",
          "required": true
        }
      ]
    }
  }
}
Se√ß√£o 4: Pr√©-condi√ß√µes e P√≥s-condi√ß√µes
Valida√ß√µes que devem passar antes/depois de cada capability.

Formato sugerido:

json
{
  "capability_contracts": {
    "decidir_atividades_criar": {
      "preconditions": [
        {
          "check": "lista_atividades_disponiveis.length > 0",
          "error_message": "Nenhuma atividade dispon√≠vel para decidir",
          "recovery_action": "execute pesquisar_atividades_disponiveis"
        },
        {
          "check": "objetivo_usuario defined",
          "error_message": "Objetivo do usu√°rio n√£o est√° claro",
          "recovery_action": "request_clarification"
        }
      ],
      
      "postconditions": [
        {
          "check": "atividades_escolhidas.length > 0",
          "error_message": "Nenhuma atividade foi escolhida",
          "recovery_action": "retry_with_lower_criteria"
        },
        {
          "check": "justificativa provided",
          "error_message": "Decis√£o sem justificativa",
          "recovery_action": "generate_justification"
        },
        {
          "check": "atividades_escolhidas.length <= 10",
          "error_message": "Muitas atividades escolhidas",
          "recovery_action": "reduce_to_top_10"
        }
      ]
    }
  }
}
Se√ß√£o 5: Estrat√©gias de Erro e Recovery
Como IA deve reagir quando algo d√° errado.

Formato sugerido:

json
{
  "error_recovery_strategies": {
    "data_not_found": {
      "scenario": "Dados esperados n√£o existem (ex: sem turmas)",
      "actions": [
        "inform_user_honestly",
        "suggest_alternative_path",
        "continue_with_generic_approach"
      ],
      "never": [
        "hallucinate_data",
        "abort_completely"
      ]
    },
    
    "capability_failed": {
      "scenario": "Capability executou mas falhou",
      "actions": [
        "retry_with_adjusted_params (max 2 retries)",
        "skip_and_mark_as_optional (if optional)",
        "abort_flow (if critical)"
      ],
      "log": "detailed_error_for_debugging"
    },
    
    "timeout": {
      "scenario": "Capability est√° demorando muito",
      "actions": [
        "show_loading_state_to_user",
        "if > 10s: offer_to_cancel",
        "if > 30s: auto_timeout_and_retry"
      ]
    }
  }
}
INTEGRA√á√ÉO: COMO IA USA ESTE ARQUIVO
Fluxo de Decis√£o da IA
text
1. Usu√°rio faz pedido
   ‚Üì
2. IA analisa objetivo do usu√°rio
   ‚Üì
3. IA consulta "common_sequences" para encontrar fluxo apropriado
   ‚Üì
4. Para cada step do fluxo:
   ‚îú‚îÄ Verificar "preconditions"
   ‚îú‚îÄ Se falhar ‚Üí Executar "recovery_action"
   ‚îú‚îÄ Executar capability
   ‚îú‚îÄ Verificar "postconditions"
   ‚îî‚îÄ Se falhar ‚Üí Executar "recovery_action"
   ‚Üì
5. IA valida "execution_rules" durante todo processo
   ‚Üì
6. Se viola√ß√£o detectada ‚Üí Abortar ou corrigir conforme regra
Como Incluir no Prompt da IA
text
# SISTEMA DE REGRAS E ORIENTA√á√ïES

Voc√™ tem acesso a um arquivo de regras que define como voc√™ deve
executar capabilities. Voc√™ DEVE seguir estas regras rigorosamente.

## Regras Carregadas
{insert_rules_file_content}

## Instru√ß√µes de Uso

1. ANTES de escolher capabilities:
   - Consulte "capability_dependencies" para entender ordem
   - Consulte "common_sequences" para ver se h√° fluxo pr√©-definido
   - Verifique "execution_rules" para regras mandat√≥rias

2. ANTES de executar cada capability:
   - Verifique "preconditions" da capability
   - Se precondition falha, execute recovery_action
   - Se critical dependency falta, execute dependency primeiro

3. DEPOIS de executar cada capability:
   - Verifique "postconditions"
   - Valide que outputs esperados foram gerados
   - Se falha, execute recovery strategy

4. DURANTE todo o fluxo:
   - Nunca viole regras do tipo "mandatory"
   - Siga regras "conditional" quando condi√ß√µes aplicam
   - Considere regras "optimization" quando poss√≠vel

## Exemplo Pr√°tico

Usu√°rio pediu: "Criar atividades para minha turma"

Seu racioc√≠nio deve ser:
1. Consulto common_sequences ‚Üí "criar_plano_aula_completo" parece adequado
2. Sigo sequence:
   - Step 1: analisar_contexto_usuario
   - Step 2: pesquisar_atividades_disponiveis
   - Verifico precondition: nenhuma
   - Executo
   - Verifico postcondition: lista_atividades > 0? ‚úì
   - Step 3: analisar_desempenho_turma
   - Verifico skip_if: turmas.count == 0? 
   - Se sim ‚Üí Skip
   - Se n√£o ‚Üí Executo
   - Step 4: decidir_atividades_criar
   - Verifico precondition: lista_atividades existe? ‚úì
   - Verifico execution_rule_001: pesquisar foi executado antes? ‚úì
   - Executo
   - Verifico postcondition: atividades_escolhidas > 0? ‚úì
   ...continue
DECIS√ïES QUE VOC√ä DEVE TOMAR
Formato do Arquivo
 JSON (estruturado, f√°cil de parsear)

 YAML (mais leg√≠vel para humanos)

 Markdown (documenta√ß√£o + dados)

 M√∫ltiplos arquivos (separa√ß√£o de concerns)

N√≠vel de Granularidade
 Regras muito espec√≠ficas (menos flexibilidade, mais controle)

 Regras abstratas (mais flexibilidade, menos controle)

 Mix (regras cr√≠ticas espec√≠ficas, resto abstrato)

Como IA Acessa
 Carregado no prompt system

 Consultado via API durante execu√ß√£o

 Cached em mem√≥ria

 Embeddings + semantic search

Valida√ß√£o de Regras
 Runtime validation (durante execu√ß√£o)

 Static validation (antes de executar)

 Hybrid (ambos)

CHECKLIST DE IMPLEMENTA√á√ÉO
Parte 1: Typewriter Fix
 Diagnosticado se √© re-mount ou re-render

 Key prop est√°vel implementada

 React.memo com custom comparison

 State do typewriter isolado (ref ou interno)

 Testado: novo card n√£o interrompe typewriter

 Testado: m√∫ltiplas reflex√µes simult√¢neas (se aplic√°vel)

Parte 2: Arquivo de Regras
 Estrutura do arquivo definida

 Se√ß√£o de dependencies implementada

 Se√ß√£o de execution rules implementada

 Se√ß√£o de sequences implementada

 Se√ß√£o de pre/postconditions implementada

 Se√ß√£o de error recovery implementada

 Sistema de valida√ß√£o implementado

 Integra√ß√£o com prompt da IA testada

 IA segue regras em casos reais

TESTES OBRIGAT√ìRIOS
Teste Typewriter:
text
1. Iniciar reflex√£o do Objetivo 1
2. Durante typewriter, disparar aparecimento de Objetivo 2
3. Verificar: Reflex√£o 1 continua sem interrup√ß√£o? ‚úì
4. Verificar: Reflex√£o 1 n√£o reinicia? ‚úì
5. Verificar: Texto completo aparece corretamente? ‚úì
Teste Regras:
text
1. Pedir IA criar atividades SEM pesquisar antes
2. Sistema deve: Detectar viola√ß√£o de rule_001
3. Sistema deve: Auto-executar pesquisa OU abortar
4. Verificar: IA n√£o criou sem pesquisar ‚úì

5. Pedir IA criar plano completo
6. Sistema deve: Seguir common_sequence
7. Verificar: Todas steps executadas em ordem ‚úì
8. Verificar: Preconditions validadas em cada step ‚úì
RESULTADO ESPERADO
Typewriter:
Reflex√µes nunca interrompem ou reiniciam

M√∫ltiplos typewriters podem rodar simultaneamente

Performance suave (60fps)

Regras:
IA sempre executa capabilities na ordem correta

IA nunca pula dependencies cr√≠ticas

IA se recupera graciosamente de erros

Sistema √© previs√≠vel e debug√°vel

MINDSET
Isolamento √© Rei: Componentes independentes n√£o se afetam

Regras s√£o Leis: Sistema n√£o √© an√°rquico, tem ordem

Explicitude > Impl√≠cito: IA n√£o deve "adivinhar" ordem

Fail-Safe: Sempre ter plano B quando algo d√° errado

üöÄ TYPEWRITER DEVE SER ROCK-SOLID. REGRAS DEVEM SER CRISTAL-CLEAR. GO BUILD RELIABLE SYSTEMS.