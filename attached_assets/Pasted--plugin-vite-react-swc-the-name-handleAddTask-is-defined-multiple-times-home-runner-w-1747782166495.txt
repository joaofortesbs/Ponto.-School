[plugin:vite:react-swc] × the name `handleAddTask` is defined multiple times
     ╭─[/home/runner/workspace/src/components/agenda/tasks/TasksView.tsx:77:1]
  77 │   });
  78 │ 
  79 │   // Adicionar nova tarefa
  80 │   const handleAddTask = async (taskData: any) => {
     ·         ──────┬──────
     ·               ╰── previous definition of `handleAddTask` here
  81 │     try {
  82 │       console.log("TasksView: Adding task:", taskData);
  83 │ 
  84 │       // Verificar se a tarefa já existe
  85 │       if (taskData.id && tasks.some(task => task.id === taskData.id)) {
  86 │         console.log("TasksView: Tarefa já existe, ignorando duplicação:", taskData.id);
  87 │         return null;
  88 │       }
  89 │ 
  90 │       // Validate required fields
  91 │       if (!taskData.title) {
  92 │         toast({
  93 │           title: "Erro ao adicionar tarefa",
  94 │           description: "O título da tarefa é obrigatório.",
  95 │           variant: "destructive",
  96 │         });
  97 │         return null;
  98 │       }
  99 │ 
 100 │       // Gerar ID consistente e único
 101 │       const taskId = taskData.id || `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
 102 │ 
 103 │       // Create a new task with all fields properly handled
 104 │       const newTask: Task = {
 105 │         id: taskId,
 106 │         title: taskData.title,
 107 │         description: taskData.description || "",
 108 │         discipline: taskData.discipline || "Geral",
 109 │         dueDate: taskData.dueDate || new Date().toISOString(),
 110 │         status: taskData.status || "a-fazer",
 111 │         priority: taskData.priority || "média",
 112 │         progress: taskData.progress || 0,
 113 │         type: taskData.type || "tarefa",
 114 │         professor: taskData.professor || "",
 115 │         subtasks: taskData.subtasks || [],
 116 │         createdAt: taskData.createdAt || new Date().toISOString(),
 117 │         updatedAt: taskData.updatedAt || new Date().toISOString(),
 118 │         tags: taskData.tags || [],
 119 │         reminderSet: taskData.reminderSet || false,
 120 │         reminderTime: taskData.reminderTime,
 121 │         attachments: taskData.attachments || [],
 122 │         timeSpent: taskData.timeSpent || 0,
 123 │         notes: taskData.notes || "",
 124 │         isPersonal:
 125 │           taskData.isPersonal !== undefined ? taskData.isPersonal : true,
 126 │         associatedClass: taskData.associatedClass || "",
 127 │         comments: [],
 128 │       };
 129 │ 
 130 │       console.log("TasksView: Nova tarefa formatada:", newTask);
 131 │ 
 132 │       // Add the new task to the beginning of the tasks array immediately
 133 │       setTasks((prevTasks) => {
 134 │         // Verificar novamente por duplicações antes de adicionar
 135 │         if (prevTasks.some(task => task.id === newTask.id)) {
 136 │           console.log("TasksView: Tarefa já existe (verificação final), ignorando duplicação:", newTask.id);
 137 │           return prevTasks;
 138 │         }
 139 │ 
 140 │         const updatedTasks = [newTask, ...prevTasks];
 141 │ 
 142 │         // Salvar no banco de dados/localStorage
 143 │         const saveTasksAsync = async () => {
 144 │           try {
 145 │             console.log("TasksView: Salvando tarefa no banco de dados");
 146 │             const user = await getCurrentUser();
 147 │             if (user && user.id) {
 148 │               // Salvar tarefa no banco de dados/localStorage
 149 │               const saved = await taskService.saveTasks(user.id, updatedTasks);
 150 │               
 151 │               if (!saved) {
 152 │                 console.warn("TasksView: Não foi possível salvar tarefas no banco de dados nem localmente");
 153 │               } else {
 154 │                 console.log("TasksView: Tarefa salva com sucesso no banco de dados");
 155 │                 
 156 │                 // Emitir evento para outros componentes
 157 │                 if (!taskData._fromEvent) {
 158 │                   console.log("TasksView: Emitindo evento de tarefa adicionada");
 159 │                   
 160 │                   // Forçar atualização imediata no PendingTasksCard por evento direto
 161 │                   const pendingTasksCard = document.querySelector('[data-testid="pending-tasks-card"]');
 162 │                   if (pendingTasksCard) {
 163 │                     console.log("TasksView: Enviando evento direto para PendingTasksCard");
 164 │                     pendingTasksCard.dispatchEvent(
 165 │                       new CustomEvent('refresh-tasks', { 
 166 │                         detail: {...newTask, _fromEvent: true},
 167 │                         bubbles: true 
 168 │                       })
 169 │                     );
 170 │                   }
 171 │                   
 172 │                   // Emitir evento global para sincronização entre componentes
 173 │                   taskService.emitTaskAdded({...newTask, _fromEvent: true});
 174 │                   
 175 │                   // Emitir evento específico para o PendingTasksCard como backup
 176 │                   document.dispatchEvent(
 177 │                     new CustomEvent('pending-tasks-updated', { 
 178 │                       detail: {...newTask, _fromEvent: true}
 179 │                     })
 180 │                   );
 181 │                   
 182 │                   // Adicionar atraso para garantir que o evento seja processado
 183 │                   setTimeout(() => {
 184 │                     console.log("TasksView: Verificando se evento foi processado");
 185 │                     // Emitir evento de backup após um pequeno atraso
 186 │                     document.dispatchEvent(
 187 │                       new CustomEvent('refresh-tasks', { 
 188 │                         detail: {...newTask, _fromEvent: true, _delayed: true}
 189 │                       })
 190 │                     );
 191 │                   }, 500);
 192 │                 }
 193 │               }
 194 │             } else {
 195 │               console.warn("TasksView: Usuário não autenticado, tarefas salvas apenas na sessão atual");
 196 │               // Mesmo sem usuário, emitir evento para componentes da mesma sessão
 197 │               if (!taskData._fromEvent) {
 198 │                 taskService.emitTaskAdded({...newTask, _fromEvent: true});
 199 │               }
 200 │             }
 201 │           } catch (err) {
 202 │             console.error("TasksView: Erro ao salvar tarefas:", err);
 203 │           }
 204 │         };
 205 │ 
 206 │         // Executar salvamento assíncrono para não bloquear a UI
 207 │         saveTasksAsync();
 208 │ 
 209 │         return updatedTasks;
 210 │       });
 211 │ 
 212 │       // Close the modal if this is a direct add (not from an event)
 213 │       if (!taskData._fromEvent) {
 214 │         setShowAddTask(false);
 215 │ 
 216 │         // Show confirmation toast
 217 │         toast({
 218 │           title: "Tarefa adicionada",
 219 │           description: "A nova tarefa foi adicionada com sucesso.",
 220 │         });
 221 │       }
 222 │ 
 223 │       // Check if task is overdue and update status accordingly
 224 │       const now = new Date();
 225 │       const dueDate = new Date(newTask.dueDate);
 226 │       if (dueDate < now && newTask.status === "a-fazer") {
 227 │         // Update the task to be marked as overdue
 228 │         setTimeout(() => {
 229 │           setTasks((prevTasks) => {
 230 │             const updatedTasks = prevTasks.map((task) =>
 231 │               task.id === newTask.id ? { ...task, status: "atrasado" } : task,
 232 │             );
 233 │ 
 234 │             // Salvar no banco de dados/localStorage
 235 │             const saveTasksAsync = async () => {
 236 │               try {
 237 │                 const user = await getCurrentUser();
 238 │                 if (user && user.id) {
 239 │                   await taskService.saveTasks(user.id, updatedTasks);
 240 │                 }
 241 │               } catch (err) {
 242 │                 console.error("Erro ao salvar tarefas atualizadas:", err);
 243 │               }
 244 │             };
 245 │ 
 246 │             saveTasksAsync();
 247 │ 
 248 │             return updatedTasks;
 249 │           });
 250 │         }, 100);
 251 │       }
 252 │ 
 253 │       return newTask;
 254 │     } catch (error) {
 255 │       console.error("Error adding task:", error);
 256 │       toast({
 257 │         title: "Erro ao adicionar tarefa",
 258 │         description: "Ocorreu um erro ao adicionar a tarefa. Tente novamente.",
 259 │         variant: "destructive",
 260 │       });
 261 │       return null;
 262 │     }
 263 │   };
 264 │ 
 265 │   // Listen for external task additions
 266 │   useEffect(() => {
 267 │     console.log("TasksView: Configurando sistema de sincronização de tarefas");
 268 │     
 269 │     // Função unificada para processar novas tarefas
 270 │     const processNewTask = (taskData: any) => {
 271 │       if (!taskData) return;
 272 │       
 273 │       console.log("TasksView: Processando nova tarefa", taskData.title || taskData.id);
 274 │       
 275 │       // Verificar se a tarefa já existe para evitar duplicação
 276 │       const taskExists = tasks.some(task => task.id === taskData.id);
 277 │       
 278 │       if (!taskExists) {
 279 │         console.log("TasksView: Adicionando nova tarefa", taskData.title);
 280 │         handleAddTask(taskData);
 281 │       } else {
 282 │         console.log("TasksView: Tarefa já existe, ignorando:", taskData.id);
 283 │       }
 284 │     };
 285 │ 
 286 │     // Handler para eventos DOM
 287 │     const handleTaskEvent = (event: any) => {
 288 │       if (event.detail) {
 289 │         console.log("TasksView: Evento de tarefa recebido via DOM", event.type);
 290 │         processNewTask(event.detail);
 291 │       }
 292 │     };
 293 │     
 294 │     // Handler para sincronização completa
 295 │     const handleSyncEvent = (event: any) => {
 296 │       if (event.detail && event.detail.task) {
 297 │         console.log("TasksView: Evento de sincronização recebido", event.detail.timestamp);
 298 │         processNewTask(event.detail.task);
 299 │       }
 300 │     };
 301 │ 
 302 │     // Handler para conclusão de tarefa
 303 │     const handleTaskCompletedEvent = (event: any) => {
 304 │       if (event.detail && event.detail.taskId) {
 305 │         console.log("TasksView: Tarefa marcada como concluída:", event.detail.taskId);
 306 │         setTasks(currentTasks => 
 307 │           currentTasks.map(task => 
 308 │             task.id === event.detail.taskId 
 309 │               ? { ...task, status: "concluido", progress: 100 } 
 310 │               : task
 311 │           )
 312 │         );
 313 │       }
 314 │     };
 315 │ 
 316 │     // Registrar componente para eventos diretos
 317 │     const tasksView = document.querySelector('[data-testid="tasks-view"]');
 318 │     if (tasksView) {
 319 │       tasksView.addEventListener("refresh-tasks", handleTaskEvent);
 320 │       tasksView.addEventListener("tasks-view-updated", handleTaskEvent);
 321 │     }
 322 │     
 323 │     // Registrar listeners para eventos DOM globais
 324 │     document.addEventListener("refresh-tasks", handleTaskEvent);
 325 │     document.addEventListener("tasks-view-updated", handleTaskEvent);
 326 │     document.addEventListener("tasks-sync-all", handleSyncEvent);
 327 │     document.addEventListener("task-completed", handleTaskCompletedEvent);
 328 │ 
 329 │     // Registrar listeners para eventos do serviço
 330 │     const serviceHandlers = [
 331 │       // Escutar adição de tarefas via serviço
 332 │       taskService.onTaskAdded((task) => {
 333 │         console.log("TasksView: Evento onTaskAdded recebido via serviço");
 334 │         processNewTask(task);
 335 │       }),
 336 │       
 337 │       // Escutar atualizações gerais
 338 │       taskService.onTasksUpdated(async (userId) => {
 339 │         try {
 340 │           console.log("TasksView: Atualizando tarefas para usuário", userId);
 341 │           const user = await getCurrentUser();
 342 │           if (user && user.id === userId) {
 343 │             const updatedTasks = await taskService.loadTasks(userId);
 344 │             if (updatedTasks && updatedTasks.length > 0) {
 345 │               setTasks(updatedTasks);
 346 │             }
 347 │           }
 348 │         } catch (error) {
 349 │           console.error("TasksView: Erro ao atualizar tarefas", error);
 350 │         }
 351 │       }),
 352 │       
 353 │       // Escutar conclusão de tarefas
 354 │       taskService.onTaskCompleted((taskId) => {
 355 │         console.log("TasksView: Evento onTaskCompleted recebido", taskId);
 356 │         setTasks(currentTasks => 
 357 │           currentTasks.map(task => 
 358 │             task.id === taskId 
 359 │               ? { ...task, status: "concluido", progress: 100 } 
 360 │               : task
 361 │           )
 362 │         );
 363 │       })
 364 │     ];
 365 │ 
 366 │     // Função de limpeza
 367 │     return () => {
 368 │       console.log("TasksView: Limpando sistema de sincronização");
 369 │       
 370 │       // Limpar listeners do componente
 371 │       if (tasksView) {
 372 │         tasksView.removeEventListener("refresh-tasks", handleTaskEvent);
 373 │         tasksView.removeEventListener("tasks-view-updated", handleTaskEvent);
 374 │       }
 375 │       
 376 │       // Limpar listeners DOM globais
 377 │       document.removeEventListener("refresh-tasks", handleTaskEvent);
 378 │       document.removeEventListener("tasks-view-updated", handleTaskEvent);
 379 │       document.removeEventListener("tasks-sync-all", handleSyncEvent);
 380 │       document.removeEventListener("task-completed", handleTaskCompletedEvent);
 381 │       
 382 │       // Limpar listeners de serviço
 383 │       serviceHandlers.forEach(unsubscribe => unsubscribe && unsubscribe());
 384 │     };
 385 │   }, [tasks]); // Removido handleAddTask das dependências
 386 │ 
 387 │   // Carregar tarefas do usuário
 388 │   useEffect(() => {
 389 │     const loadUserTasks = async () => {
 390 │       try {
 391 │         // Obter usuário atual
 392 │         const user = await getCurrentUser();
 393 │ 
 394 │         if (user && user.id) {
 395 │           // Carregar tarefas sincronizadas (do Supabase ou local, o mais recente)
 396 │           const userTasks = await taskService.syncTasks(user.id);
 397 │           if (userTasks && userTasks.length > 0) {
 398 │             setTasks(userTasks);
 399 │             console.log(`Carregadas ${userTasks.length} tarefas do usuário ${user.id}`);
 400 │           } else {
 401 │             console.log("Nenhuma tarefa encontrada para o usuário");
 402 │             setTasks([]);
 403 │           }
 404 │         } else {
 405 │           console.warn("Usuário não autenticado, não é possível carregar tarefas");
 406 │           setTasks([]);
 407 │         }
 408 │       } catch (error) {
 409 │         console.error("Erro ao carregar tarefas do usuário:", error);
 410 │         setTasks([]);
 411 │       }
 412 │     };
 413 │ 
 414 │     loadUserTasks();
 415 │   }, []);
 416 │ 
 417 │   // Filtrar tarefas com base nos filtros e na busca
 418 │   useEffect(() => {
 419 │     let result = [...tasks];
 420 │ 
 421 │     // Aplicar filtro de busca
 422 │     if (searchQuery) {
 423 │       const query = searchQuery.toLowerCase();
 424 │       result = result.filter(
 425 │         (task) =>
 426 │           task.title.toLowerCase().includes(query) ||
 427 │           (task.description || "").toLowerCase().includes(query) ||
 428 │           task.discipline.toLowerCase().includes(query) ||
 429 │           (task.professor || "").toLowerCase().includes(query) ||
 430 │           (task.tags || []).some((tag) => tag.toLowerCase().includes(query)),
 431 │       );
 432 │     }
 433 │ 
 434 │     // Aplicar filtros de status
 435 │     if (filters.status.length > 0) {
 436 │       result = result.filter((task) => filters.status.includes(task.status));
 437 │     }
 438 │ 
 439 │     // Aplicar filtros de prioridade
 440 │     if (filters.priority.length > 0) {
 441 │       result = result.filter((task) =>
 442 │         filters.priority.includes(task.priority),
 443 │       );
 444 │     }
 445 │ 
 446 │     // Aplicar filtros de disciplina
 447 │     if (filters.discipline.length > 0) {
 448 │       result = result.filter((task) =>
 449 │         filters.discipline.includes(task.discipline),
 450 │       );
 451 │     }
 452 │ 
 453 │     // Aplicar filtro de data de vencimento
 454 │     if (filters.dueDate !== "all") {
 455 │       const now = new Date();
 456 │       const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
 457 │       const tomorrow = new Date(today);
 458 │       tomorrow.setDate(tomorrow.getDate() + 1);
 459 │ 
 460 │       const nextWeek = new Date(today);
 461 │       nextWeek.setDate(nextWeek.getDate() + 7);
 462 │ 
 463 │       const nextMonth = new Date(today);
 464 │       nextMonth.setMonth(nextMonth.getMonth() + 1);
 465 │ 
 466 │       switch (filters.dueDate) {
 467 │         case "today":
 468 │           result = result.filter((task) => {
 469 │             const dueDate = new Date(task.dueDate);
 470 │             return (
 471 │               dueDate.getDate() === today.getDate() &&
 472 │               dueDate.getMonth() === today.getMonth() &&
 473 │               dueDate.getFullYear() === today.getFullYear()
 474 │             );
 475 │           });
 476 │           break;
 477 │         case "week":
 478 │           result = result.filter((task) => {
 479 │             const dueDate = new Date(task.dueDate);
 480 │             return dueDate >= today && dueDate < nextWeek;
 481 │           });
 482 │           break;
 483 │         case "month":
 484 │           result = result.filter((task) => {
 485 │             const dueDate = new Date(task.dueDate);
 486 │             return dueDate >= today && dueDate < nextMonth;
 487 │           });
 488 │           break;
 489 │       }
 490 │     }
 491 │ 
 492 │     setFilteredTasks(result);
 493 │   }, [tasks, searchQuery, filters]);
 494 │ 
 495 │   // Agrupar tarefas por status
 496 │   const tasksByStatus = {
 497 │     "a-fazer": filteredTasks.filter((task) => task.status === "a-fazer"),
 498 │     "em-andamento": filteredTasks.filter(
 499 │       (task) => task.status === "em-andamento",
 500 │     ),
 501 │     concluido: filteredTasks.filter((task) => task.status === "concluido"),
 502 │     atrasado: filteredTasks.filter((task) => task.status === "atrasado"),
 503 │   };
 504 │ 
 505 │   // Abrir modal de detalhes da tarefa
 506 │   const handleTaskClick = (task: Task) => {
 507 │     setSelectedTask(task);
 508 │     setShowTaskDetails(true);
 509 │   };
 510 │ 
 511 │   // Mover tarefa para outro status
 512 │   const handleMoveTask = (taskId: string, newStatus: TaskStatus) => {
 513 │     setTasks((currentTasks) => {
 514 │       const updatedTasks = currentTasks.map((task) => {
 515 │         if (task.id === taskId) {
 516 │           // Se estiver movendo para concluído, definir progresso como 100%
 517 │           const newProgress =
 518 │             newStatus === "concluido" ? 100 : task.progress;
 519 │           // Se estiver movendo para concluído, registrar data de conclusão
 520 │           const completedAt =
 521 │             newStatus === "concluido"
 522 │               ? new Date().toISOString()
 523 │               : task.completedAt;
 524 │ 
 525 │           const updatedTask = {
 526 │             ...task,
 527 │             status: newStatus,
 528 │             progress: newProgress,
 529 │             completedAt,
 530 │           };
 531 │ 
 532 │           return updatedTask;
 533 │         }
 534 │         return task;
 535 │       });
 536 │ 
 537 │       // Salvar no banco de dados/localStorage
 538 │       const saveTasksAsync = async () => {
 539 │         try {
 540 │           const user = await getCurrentUser();
 541 │           if (user && user.id) {
 542 │             await taskService.saveTasks(user.id, updatedTasks);
 543 │           }
 544 │         } catch (err) {
 545 │           console.error("Erro ao salvar tarefas após mover:", err);
 546 │         }
 547 │       };
 548 │ 
 549 │       saveTasksAsync();
 550 │ 
 551 │       return updatedTasks;
 552 │     });
 553 │   };
 554 │ 
 555 │   // Marcar tarefa como concluída/não concluída
 556 │   const handleCompleteTask = (taskId: string, completed: boolean) => {
 557 │     setTasks((currentTasks) => {
 558 │       const updatedTasks = currentTasks.map((task) => {
 559 │         if (task.id === taskId) {
 560 │           const newStatus = completed ? "concluido" : "a-fazer";
 561 │           const updatedTask = {
 562 │             ...task,
 563 │             status: newStatus,
 564 │             completedAt: completed ? new Date().toISOString() : undefined,
 565 │             progress: completed ? 100 : task.progress,
 566 │           };
 567 │ 
 568 │           return updatedTask;
 569 │         }
 570 │         return task;
 571 │       });
 572 │ 
 573 │       // Salvar no banco de dados/localStorage
 574 │       const saveTasksAsync = async () => {
 575 │         try {
 576 │           const user = await getCurrentUser();
 577 │           if (user && user.id) {
 578 │             await taskService.saveTasks(user.id, updatedTasks);
 579 │           }
 580 │         } catch (err) {
 581 │           console.error("Erro ao salvar tarefas após concluir:", err);
 582 │         }
 583 │       };
 584 │ 
 585 │       saveTasksAsync();
 586 │ 
 587 │       return updatedTasks;
 588 │     });
 589 │   };
 590 │ 
 591 │   // Atualizar tarefa
 592 │   const handleUpdateTask = (updatedTask: Task) => {
 593 │     setTasks((currentTasks) => {
 594 │       const updatedTasks = currentTasks.map((task) =>
 595 │         task.id === updatedTask.id ? updatedTask : task,
 596 │       );
 597 │ 
 598 │       // Salvar no banco de dados/localStorage
 599 │       const saveTasksAsync = async () => {
 600 │         try {
 601 │           const user = await getCurrentUser();
 602 │           if (user && user.id) {
 603 │             await taskService.saveTasks(user.id, updatedTasks);
 604 │           }
 605 │         } catch (err) {
 606 │           console.error("Erro ao salvar tarefas após atualização:", err);
 607 │         }
 608 │       };
 609 │ 
 610 │       saveTasksAsync();
 611 │ 
 612 │       return updatedTasks;
 613 │     });
 614 │ 
 615 │     // Mostrar toast de confirmação
 616 │     toast({
 617 │       title: "Tarefa atualizada",
 618 │       description: "As alterações foram salvas com sucesso.",
 619 │     });
 620 │   };
 621 │ 
 622 │   // Excluir tarefa
 623 │   const handleDeleteTask = (taskId: string) => {
 624 │     setTasks((currentTasks) => {
 625 │       const updatedTasks = currentTasks.filter((task) => task.id !== taskId);
 626 │ 
 627 │       // Salvar no banco de dados/localStorage
 628 │       const saveTasksAsync = async () => {
 629 │         try {
 630 │           const user = await getCurrentUser();
 631 │           if (user && user.id) {
 632 │             await taskService.saveTasks(user.id, updatedTasks);
 633 │           }
 634 │         } catch (err) {
 635 │           console.error("Erro ao salvar tarefas após exclusão:", err);
 636 │         }
 637 │       };
 638 │ 
 639 │       saveTasksAsync();
 640 │ 
 641 │       return updatedTasks;
 642 │     });
 643 │ 
 644 │     setShowTaskDetails(false);
 645 │ 
 646 │     // Mostrar toast de confirmação
 647 │     toast({
 648 │       title: "Tarefa excluída",
 649 │       description: "A tarefa foi excluída permanentemente.",
 650 │     });
 651 │   };
 652 │ 
 653 │   // Adicionar nova tarefa
 654 │   const handleAddTask = async (taskData: any) => {
     ·         ──────┬──────
     ·               ╰── `handleAddTask` redefined here
 655 │     try {
 656 │       console.log("TasksView: Adding task:", taskData);
     ╰────
/home/runner/workspace/src/components/agenda/tasks/TasksView.tsx:77:1
724|                
725|                if (!saved) {
726|                  console.warn("TasksView: Não foi possível salvar tarefas no banco de dados nem localmente");
   |                                      ^
727|                } else {
728|                  console.log("TasksView: Tarefa salva com sucesso no banco de dados");