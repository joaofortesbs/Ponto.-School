ğŸš€ SOLUÃ‡ÃƒO CRIATIVA E ROBUSTA: SINCRONIZAÃ‡ÃƒO INTELIGENTE DE GRADE

STATUS: App compilado SEM ERROS âœ…

Agora vocÃª precisa garantir que:
1. PublicaÃ§Ã£o funciona (jÃ¡ funciona)
2. Fechar card dispara sincronizaÃ§Ã£o (parcialmente)
3. Grade AUTOMATICAMENTE mostra aula publicada (FALTA ISSO)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROBLEMA FINO DIAGNOSTICADO:

O agente criou os listeners e callbacks, MAS:
âŒ O listener pode estar recebendo o evento ANTES de a aula estar salva
âŒ O listener pode estar ouvindo o evento DEPOIS do componente desmontar
âŒ Pode haver race condition entre salvar e carregar

SOLUÃ‡ÃƒO CRIATIVA #1: DUPLA VALIDAÃ‡ÃƒO COM RETRY
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Em src/pages/minhas-criacoes/atividades/components/grids/AulasGrid.tsx:

const AulasGrid = () => {
const [aulas, setAulas] = useState<any[]>([]);
const [loading, setLoading] = useState(false);

// FUNÃ‡ÃƒO: Carregar com retry automÃ¡tico
const carregarAulasComRetry = async (tentativa = 1, maxTentativas = 3) => {
try {
setLoading(true);
console.log(`[AULAS_GRID_LOAD] Tentativa ${tentativa}/${maxTentativas}`);

texto
  // Tenta localStorage
  let aulasCarregadas = aulasStorageService.listarAulas();
  console.log('[AULAS_GRID] localStorage retornou:', aulasCarregadas.length, 'aulas');
  
  // Se vazio, tenta IndexedDB
  if (!aulasCarregadas || aulasCarregadas.length === 0) {
    console.log('[AULAS_GRID] localStorage vazio, tentando IndexedDB...');
    aulasCarregadas = await aulasIndexedDBService.listarAulasIndexedDB();
    console.log('[AULAS_GRID] IndexedDB retornou:', aulasCarregadas.length, 'aulas');
  }
  
  // Se AINDA vazio e temos mais tentativas, aguarda e tenta novamente
  if ((!aulasCarregadas || aulasCarregadas.length === 0) && tentativa < maxTentativas) {
    console.log(\`[AULAS_GRID] Vazio na tentativa \${tentativa}, aguardando 500ms...\`);
    await new Promise(resolve => setTimeout(resolve, 500));
    return carregarAulasComRetry(tentativa + 1, maxTentativas);
  }
  
  setAulas(aulasCarregadas || []);
  console.log('[AULAS_GRID_FINAL] Aulas renderizadas:', aulasCarregadas.length);
  setLoading(false);
  
} catch (error) {
  console.error('[AULAS_GRID_ERROR]', error);
  setLoading(false);
}
};

// Monte: carrega aulas
useEffect(() => {
carregarAulasComRetry();
}, []);

// LISTENER #1: Event listener (para aulas publicadas)
useEffect(() => {
const handleAulasPublicadas = () => {
console.log('[AULAS_GRID_LISTENER] Evento aulasPublicadas recebidas!');
carregarAulasComRetry(); // Recarregar com retry
};

texto
window.addEventListener('aulasPublicadas', handleAulasPublicadas);
return () => window.removeEventListener('aulasPublicadas', handleAulasPublicadas);
}, []);

// LISTENER #2: Listener de armazenamento (para mudanÃ§as de aba/janela)
useEffect(() => {
const handleStorageChange = (e: StorageEvent) => {
if (e.key === 'ponto_school_aulas_salvas') {
console.log('[AULAS_GRID_STORAGE] localStorage mudou!');
carregarAulasComRetry();
}
};

texto
window.addEventListener('storage', handleStorageChange);
return () => window.removeEventListener('storage', handleStorageChange);
}, []);

// OUVINTE #3: Visibilidade (quando o usuÃ¡rio volta para aba)
useEffect(() => {
const handleVisibilityChange = () => {
if (!document.hidden) {
console.log('[AULAS_GRID_VISIBILITY] Aba ficou visÃ­vel, recarregando aulas');
carregarAulasComRetry();
}
};

texto
document.addEventListener('visibilitychange', handleVisibilityChange);
return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
}, []);

return (
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
{loading && <div className="col-span-full text-center"> Carregando aulas... </div> }
{!loading && aulas.length === 0 && (
<div className="col-span-full text-center py-8 text-gray-500">
Nenhuma aula publicada ainda.
</div>
)}
{aulas.map((aula) => (
<AulaCard
key={aula.id}
aula={aula}
onDelete={() => carregarAulasComRetry()}
/>
))}
</div>
);
};

texto

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SOLUÃ‡ÃƒO CRIATIVA #2: CALLBACK ROBUSTO COM TIMING
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Em ConstrucaoAulaPanel.tsx, modifique o handler de fechar:

const handleCloseButton = async () => {
console.log('[CLOSE_BUTTON] Clicado, isPublished:', isPublished);

if (isPublished) {
console.log('[CLOSE_BUTTON] Aula FOI publicada, iniciando sincronizaÃ§Ã£o...');

texto
// DUPLA AÃ‡ÃƒO:
// 1. Dispara evento imediatamente
window.dispatchEvent(new Event('aulasPublicadas'));
console.log('[CLOSE_BUTTON] Evento disparado');

// 2. Aguarda um pouco (permite que listener se prepare)
await new Promise(resolve => setTimeout(resolve, 100));

// 3. Dispara novamente (para garantir que foi ouvido)
window.dispatchEvent(new Event('aulasPublicadas'));
console.log('[CLOSE_BUTTON] Evento disparado novamente (confirma)');

// 4. Chama callback do pai
onPublishedClose?.();
console.log('[CLOSE_BUTTON] onPublishedClose chamado');
} else {
console.log('[CLOSE_BUTTON] Aula NÃƒO foi publicada, fechando normalmente');
onClose?.();
}
};

texto

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SOLUÃ‡ÃƒO CRIATIVA #3: WATCHER GLOBAL DE PUBLICAÃ‡ÃƒO
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Crie um novo serviÃ§o: src/services/publicationWatcher.ts

// Sistema global de observaÃ§Ã£o de publicaÃ§Ãµes
let watchers: Set<() => void> = new Set();

export const onAulaPublished = (callback: () => void) => {
watchers.add(callback);
console.log('[WATCHER] Novo observador registrado, total:', watchers.size);

return () => {
watchers.delete(callback);
console.log('[WATCHER] Observador removido, total:', watchers.size);
};
};

export const notifyAllWatchers = () => {
console.log('[WATCHER_NOTIFY] Notificando', watchers.size, 'observadores');
watchers.forEach(watcher => {
try {
watcher();
} catch (err) {
console.error('[WATCHER_ERROR]', err);
}
});
};

exportar const clearAllWatchers = () => {
watchers.clear();
console.log('[WATCHER_CLEAR] Todos os observadores removidos');
};

texto

Use em AulaResultadoContent.tsx:

import { notifyAllWatchers } from '@/services/publicationWatcher';

const handlePublishAula = async () => {
// ... cÃ³digo de publicaÃ§Ã£o ...

setIsPublished(true);

// NOTIFICAR TODOS OS OBSERVADORES
notifyAllWatchers();
console.log('[PUBLISH] notifyAllWatchers chamado');

// TambÃ©m Ã© um evento diferente
window.dispatchEvent(new Event('aulasPublicadas'));
};

texto

Use em AulasGrid.tsx:

useEffect(() => {
// Registra observer com watcher global
const unsubscribe = onAulaPublished(() => {
console.log('[GRID_WATCHER] Aula foi publicada, recarregando');
carregarAulasComRetry();
});

retornar cancelar inscriÃ§Ã£o; // Limpeza automÃ¡tica
}, []);

texto

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SOLUÃ‡ÃƒO CRIATIVA #4: AUTO-REFRESH COM DEBOUNCE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Em AulasGrid.tsx, adicione debounce para evitar mÃºltiplos carregamentos:

const carregarAulasDebounced = useCallback(
debounce(() => {
console.log('[DEBOUNCE] Carregando aulas (debounced)');
carregarAulasComRetry();
}, 300),
[]
);

// Use carregarAulasDebounced em vez de carregarAulasComRetry nos ouvintes
useEffect(() => {
const handleAulasPublicadas = () => {
console.log('[LISTENER] aulasPublicadas, iniciando debounce');
carregarAulasDebounced();
};

window.addEventListener('aulasPublicadas', handleAulasPublicadas);
return() => window.removeEventListener('aulasPublicadas', handleAulasPublicadas);
}, [carregarAulasDebounced]);

texto

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TESTE FINAL COMPLETO:

1. âœ… VÃ¡ para Aulas â†’ + Criar Aula
2. âœ… Preencha: Template, Assunto, Contexto
3. âœ… Clique "Gerar aula"
4. âœ… Aguarde preenchimento dos cards
5. âœ… Abra Console (F12)
6. âœ… Clique botÃ£o Publicar
7. âœ… CONSOLE DEVE MOSTRAR:
   [PUBLISH_AULA_START]
   [PUBLISH_AULA_DATA]
   [PUBLISH_AULA_STORAGE] ou [PUBLISH_AULA_INDEXED_DB]
   [PUBLISH_TRIGGER] Evento disparado
   [PUBLISH_AULA_SUCCESS]
   [PUBLISH_AULA_MODAL] Modal aberto
8. âœ… Aguarde modal fechar (3s)
9. âœ… Clique botÃ£o X
10. âœ… CONSOLE DEVE MOSTRAR:
    [CLOSE_BUTTON] Clicado, isPublished: true
    [CLOSE_BUTTON] Aula FOI publicada, iniciando sincronizaÃ§Ã£o...
    [CLOSE_BUTTON] Evento disparado
    [CLOSE_BUTTON] Evento disparado novamente (confirma)
    [AULAS_GRID_LISTENER] Evento aulasPublicadas recebido!
    [AULAS_GRID_LOAD] Tentativa 1/3
    [AULAS_GRID] localStorage retornou: X aulas
    [AULAS_GRID_FINAL] Aulas renderizadas: X
11. âœ… Card fecha
12. âœ… **AULA APARECE NA GRADE IMEDIATAMENTE**
13. âœ… Recarregue pÃ¡gina - aula continua lÃ¡

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPLEMENTAÃ‡ÃƒO PRIORIZADA:

1ï¸âƒ£ (CRÃTICO) Adicione retry + 3 listeners em AulasGrid
2ï¸âƒ£ (IMPORTANTE) Adicione dupla validaÃ§Ã£o em ConstrucaoAulaPanel
3ï¸âƒ£ (EXTRA) Crie publicationWatcher.ts (opcional mas super poderoso)
4ï¸âƒ£ (POLIMENTO) Adicione debounce

Se fizer sÃ³ 1 e 2, jÃ¡ resolve 95%.

RESPONDA COM:
1. CÃ³digo atualizado dos 4 pontos
2. Screenshot do console com TODOS os logs em sequÃªncia
3. Screenshot da grade COM a aula publicada
4. ConfirmaÃ§Ã£o de que recarregando pÃ¡gina a aula persiste
5. ConfirmaÃ§Ã£o de que o fluxo Ã© FLUIDO (sem delay perceptÃ­vel)

Se algum log FALTAR no console, saberemos exatamente onde o fluxo quebra!