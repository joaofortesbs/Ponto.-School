PROMPT REFINADO E COMPLETO PARA VIBE CODE
OBJETIVO GERAL
Implementar o sistema de Modo Desenvolvedor no School Power 2.0, que exibe em tempo real o progresso de execuÃ§Ã£o do plano de aÃ§Ã£o, mostrando cada etapa sendo processada e as capabilities sendo acionadas dinamicamente conforme a IA trabalha.

CONTEXTO ARQUITETURAL
Baseado nas imagens fornecidas, o fluxo atual possui:

Card de Plano de AÃ§Ã£o (primeira imagem) - mostra etapas como checkboxes

BotÃµes de aÃ§Ã£o: "APLICAR PLANO" e "EDITAR PLANO"

Mensagem de confirmaÃ§Ã£o: "Vou executar o seu plano de aÃ§Ã£o agora"

Card expandido (segunda imagem) - mostra etapas sendo executadas em tempo real

ESPECIFICAÃ‡ÃƒO TÃ‰CNICA DETALHADA
1. FLUXO COMPLETO DE EXECUÃ‡ÃƒO
FASE 1: RecepÃ§Ã£o do Prompt Inicial
Entrada:

UsuÃ¡rio digita prompt na caixa de mensagens

Exemplo: "Criar 3 atividades de Ã¡lgebra para turma 7A"

SaÃ­da:

IA retorna mensagem explicativa: "Vou montar um plano de aÃ§Ã£o pra vocÃª:"

Renderiza Card de Plano de AÃ§Ã£o com etapas estruturadas

Componente:

typescript
// interface-modo-producao-chat/components/PlanActionCard.tsx
Estrutura visual:

text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¤– Vou montar um plano de aÃ§Ã£o pra vocÃª:â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚ â—‹ Escolher as melhores atividades      â”‚
â”‚   para sua turma                        â”‚
â”‚                                         â”‚
â”‚ â—‹ Vou criar todas as atividades        â”‚
â”‚                                         â”‚
â”‚ â—‹ Transformar essas atividades em aulasâ”‚
â”‚                                         â”‚
â”‚ â—‹ Criar um flow para suas atividades   â”‚
â”‚                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [APLICAR PLANO]  [EDITAR PLANO]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
FASE 2: ConfirmaÃ§Ã£o de ExecuÃ§Ã£o
Trigger: UsuÃ¡rio clica em "APLICAR PLANO"

Comportamento:

NÃƒO animar o card atual

Manter card de plano visÃ­vel e estÃ¡tico

Adicionar nova mensagem do agente abaixo do card:

Avatar do Agente Jota

Texto: "Vou executar o seu plano de aÃ§Ã£o agora"

Iniciar transiÃ§Ã£o para Modo Desenvolvedor

Componente:

typescript
// interface-modo-producao-chat/components/ExecutionConfirmationMessage.tsx
CÃ³digo:

typescript
function handleApplyPlan(plan: ExecutionPlan) {
  // 1. Adiciona mensagem de confirmaÃ§Ã£o
  setMessages(prev => [...prev, {
    id: generateId(),
    role: "assistant",
    content: "Vou executar o seu plano de aÃ§Ã£o agora",
    timestamp: Date.now(),
    type: "execution_start"
  }]);

  // 2. Ativa Modo Desenvolvedor
  setDeveloperMode({
    active: true,
    plan: plan,
    currentStep: null,
    capabilities: []
  });

  // 3. Inicia execuÃ§Ã£o no backend
  executeDevPlan(plan.id);
}
FASE 3: RenderizaÃ§Ã£o do Modo Desenvolvedor
Comportamento:

Renderizar Card Retangular de Modo Desenvolvedor abaixo da mensagem de confirmaÃ§Ã£o

Card expande verticalmente conforme etapas sÃ£o processadas

Progressive disclosure: apenas etapa atual Ã© visÃ­vel inicialmente

Capabilities aparecem dinamicamente abaixo da etapa atual

Componente:

typescript
// interface-modo-producao-chat/components/DeveloperModeCard.tsx
Estrutura visual inicial:

text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ› ï¸ MODO DESENVOLVEDOR                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                â”‚
â”‚ â—‰ Vou escolher as melhores atividades         â”‚
â”‚   para sua turma                               â”‚
â”‚   â”œâ”€ ğŸ“Š Vou pesquisar o desempenho da turma X â”‚
â”‚   â”‚   [âš¡ Executando...]                       â”‚
â”‚   â””â”€ ğŸ“ Vou pesquisar quais atividades eu     â”‚
â”‚       posso criar                              â”‚
â”‚       [â³ Aguardando...]                        â”‚
â”‚                                                â”‚
â”‚ â—‹ Vou criar todas as atividades               â”‚
â”‚   [ğŸ”’ Bloqueado]                               â”‚
â”‚                                                â”‚
â”‚ â—‹ Transformar essas atividades em aulas       â”‚
â”‚   [ğŸ”’ Bloqueado]                               â”‚
â”‚                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2. ESTRUTURA DE DADOS
Schema do Plano de AÃ§Ã£o
typescript
// shared/types/plan-types.ts

interface ExecutionPlan {
  id: string;
  objetivo: string;
  etapas: PlanStep[];
  status: 'pending' | 'executing' | 'completed' | 'failed';
  createdAt: number;
}

interface PlanStep {
  ordem: number;
  titulo: string; // Ex: "Escolher as melhores atividades para sua turma"
  descricao: string;
  capabilities: CapabilityCall[];
  status: 'pending' | 'executing' | 'completed' | 'failed';
  resultado?: any;
  startedAt?: number;
  completedAt?: number;
}

interface CapabilityCall {
  id: string;
  nome: string; // Ex: "pesquisar_desempenho_turma"
  displayName: string; // Ex: "Vou pesquisar o desempenho da turma X"
  categoria: 'PESQUISAR' | 'CRIAR' | 'ADICIONAR' | 'EDITAR' | 'ANALISAR';
  parametros: Record<string, any>;
  status: 'pending' | 'executing' | 'completed' | 'failed';
  resultado?: any;
  duracao?: number; // ms
  ordem: number; // Ordem dentro da etapa
}
3. COMPORTAMENTO DINÃ‚MICO (PROGRESSIVE DISCLOSURE)
Regras de ExibiÃ§Ã£o
Etapa 1 (Atual):

âœ… Totalmente expandida

âœ… Capabilities visÃ­veis e atualizando em tempo real

âœ… Ãcone: â—‰ (filled circle)

âœ… Status individual de cada capability

Etapa 2+ (Futuras):

âœ… VisÃ­vel mas colapsada

âŒ Capabilities ocultas

âœ… Ãcone: â—‹ (empty circle)

âœ… Label: [ğŸ”’ Bloqueado]

Etapas ConcluÃ­das:

âœ… Colapsadas por padrÃ£o

âœ… Ãcone: âœ“ (checkmark)

âœ… Cor: verde

âœ… ClicÃ¡vel para expandir e ver detalhes

4. ATUALIZAÃ‡ÃƒO EM TEMPO REAL (WEBSOCKET)
Eventos do Backend â†’ Frontend
typescript
// WebSocket Events

// 1. Etapa iniciada
ws.on('execution:step:started', (data: {
  stepIndex: number;
  stepTitle: string;
  capabilities: CapabilityCall[];
}) => {
  // Expande etapa atual
  // Mostra capabilities iniciais
});

// 2. Capability iniciada
ws.on('execution:capability:started', (data: {
  stepIndex: number;
  capabilityId: string;
  capabilityName: string;
}) => {
  // Atualiza status da capability para "executing"
  // Adiciona animaÃ§Ã£o de loading
});

// 3. Capability concluÃ­da
ws.on('execution:capability:completed', (data: {
  stepIndex: number;
  capabilityId: string;
  resultado: any;
  duracao: number;
}) => {
  // Marca capability como concluÃ­da
  // Mostra checkmark verde
  // Opcionalmente exibe resultado resumido
});

// 4. Etapa concluÃ­da
ws.on('execution:step:completed', (data: {
  stepIndex: number;
  resultado: any;
}) => {
  // Marca etapa como concluÃ­da
  // Colapsa etapa atual
  // Expande prÃ³xima etapa (se houver)
});

// 5. ExecuÃ§Ã£o completa
ws.on('execution:completed', (data: {
  planId: string;
  relatorio: string;
}) => {
  // Colapsa todas as etapas
  // Mostra mensagem final com relatÃ³rio
});
5. IMPLEMENTAÃ‡ÃƒO DO COMPONENTE PRINCIPAL
typescript
// interface-modo-producao-chat/components/DeveloperModeCard.tsx

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useChatWebSocket } from '@/hooks/useChatWebSocket';

interface DeveloperModeCardProps {
  plan: ExecutionPlan;
  sessionId: string;
}

export function DeveloperModeCard({ plan, sessionId }: DeveloperModeCardProps) {
  const [executionState, setExecutionState] = useState<ExecutionPlan>(plan);
  const { socket } = useChatWebSocket(sessionId);

  // WebSocket listeners
  useEffect(() => {
    if (!socket) return;

    socket.on('execution:step:started', (data) => {
      setExecutionState(prev => ({
        ...prev,
        etapas: prev.etapas.map((etapa, idx) => 
          idx === data.stepIndex
            ? { ...etapa, status: 'executing', capabilities: data.capabilities }
            : etapa
        )
      }));
    });

    socket.on('execution:capability:started', (data) => {
      setExecutionState(prev => ({
        ...prev,
        etapas: prev.etapas.map((etapa, idx) => 
          idx === data.stepIndex
            ? {
                ...etapa,
                capabilities: etapa.capabilities.map(cap =>
                  cap.id === data.capabilityId
                    ? { ...cap, status: 'executing' }
                    : cap
                )
              }
            : etapa
        )
      }));
    });

    socket.on('execution:capability:completed', (data) => {
      setExecutionState(prev => ({
        ...prev,
        etapas: prev.etapas.map((etapa, idx) => 
          idx === data.stepIndex
            ? {
                ...etapa,
                capabilities: etapa.capabilities.map(cap =>
                  cap.id === data.capabilityId
                    ? { ...cap, status: 'completed', resultado: data.resultado, duracao: data.duracao }
                    : cap
                )
              }
            : etapa
        )
      }));
    });

    socket.on('execution:step:completed', (data) => {
      setExecutionState(prev => ({
        ...prev,
        etapas: prev.etapas.map((etapa, idx) => 
          idx === data.stepIndex
            ? { ...etapa, status: 'completed', resultado: data.resultado }
            : etapa
        )
      }));
    });

    return () => {
      socket.off('execution:step:started');
      socket.off('execution:capability:started');
      socket.off('execution:capability:completed');
      socket.off('execution:step:completed');
    };
  }, [socket]);

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="developer-mode-card"
    >
      {/* Header */}
      <div className="dev-mode-header">
        <Wrench className="icon" />
        <h3>MODO DESENVOLVEDOR</h3>
      </div>

      {/* Etapas */}
      <div className="execution-steps">
        <AnimatePresence mode="sync">
          {executionState.etapas.map((etapa, idx) => (
            <ExecutionStepItem
              key={idx}
              etapa={etapa}
              isActive={etapa.status === 'executing'}
              isCompleted={etapa.status === 'completed'}
              isPending={etapa.status === 'pending'}
            />
          ))}
        </AnimatePresence>
      </div>
    </motion.div>
  );
}

// Componente individual de etapa
function ExecutionStepItem({
  etapa,
  isActive,
  isCompleted,
  isPending
}: {
  etapa: PlanStep;
  isActive: boolean;
  isCompleted: boolean;
  isPending: boolean;
}) {
  const [isExpanded, setIsExpanded] = useState(isActive);

  useEffect(() => {
    if (isActive) setIsExpanded(true);
    if (isCompleted) setIsExpanded(false);
  }, [isActive, isCompleted]);

  return (
    <motion.div
      layout
      className={`execution-step ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}`}
    >
      {/* Header da etapa */}
      <div 
        className="step-header"
        onClick={() => isCompleted && setIsExpanded(!isExpanded)}
      >
        {/* Ãcone de status */}
        <div className="step-icon">
          {isCompleted && <Check className="text-green-500" />}
          {isActive && <Circle className="text-orange-500 animate-pulse" />}
          {isPending && <Circle className="text-gray-500" />}
        </div>

        {/* TÃ­tulo */}
        <p className="step-title">{etapa.titulo}</p>

        {/* Badge de status */}
        {isPending && (
          <span className="status-badge locked">
            ğŸ”’ Bloqueado
          </span>
        )}
      </div>

      {/* Capabilities (expansÃ­vel) */}
      <AnimatePresence>
        {isExpanded && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="capabilities-list"
          >
            {etapa.capabilities.map((capability, capIdx) => (
              <CapabilityItem
                key={capability.id}
                capability={capability}
              />
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
}

// Componente individual de capability
function CapabilityItem({ capability }: { capability: CapabilityCall }) {
  return (
    <motion.div
      initial={{ opacity: 0, x: -20 }}
      animate={{ opacity: 1, x: 0 }}
      transition={{ duration: 0.2 }}
      className="capability-item"
    >
      {/* Ãcone da categoria */}
      <div className="capability-icon">
        {capability.categoria === 'PESQUISAR' && <Search size={16} />}
        {capability.categoria === 'CRIAR' && <Plus size={16} />}
        {capability.categoria === 'ADICIONAR' && <Link size={16} />}
        {capability.categoria === 'ANALISAR' && <BarChart size={16} />}
      </div>

      {/* Nome da capability */}
      <p className="capability-name">{capability.displayName}</p>

      {/* Status */}
      <div className="capability-status">
        {capability.status === 'pending' && (
          <span className="status-badge pending">â³ Aguardando...</span>
        )}
        {capability.status === 'executing' && (
          <span className="status-badge executing">
            <Loader2 className="animate-spin" size={14} />
            Executando...
          </span>
        )}
        {capability.status === 'completed' && (
          <span className="status-badge completed">
            <Check size={14} />
            {capability.duracao && `${capability.duracao}ms`}
          </span>
        )}
        {capability.status === 'failed' && (
          <span className="status-badge failed">âŒ Falhou</span>
        )}
      </div>
    </motion.div>
  );
}
6. BACKEND: ESCOLHA DINÃ‚MICA DE CAPABILITIES
Importante: As capabilities nÃ£o sÃ£o prÃ©-definidas - a IA escolhe dinamicamente durante a execuÃ§Ã£o.

typescript
// agente-jota-chat/executor/PlanExecutor.ts

async function executeStep(etapa: PlanStep, onProgress: ProgressCallback) {
  
  // 1. NOTIFICA INÃCIO DA ETAPA
  onProgress({
    type: 'execution:step:started',
    stepIndex: etapa.ordem,
    stepTitle: etapa.titulo,
    capabilities: [] // Inicialmente vazio
  });

  // 2. IA DECIDE QUAIS CAPABILITIES USAR
  const capabilitiesToCall = await this.llm.decideCapabilities({
    stepDescription: etapa.descricao,
    availableCapabilities: this.registry.getAll(),
    context: await this.memory.getWorkingMemory()
  });

  // 3. EXECUTA CADA CAPABILITY DINAMICAMENTE
  for (const capability of capabilitiesToCall) {
    
    // 3.1. NOTIFICA INÃCIO DA CAPABILITY
    onProgress({
      type: 'execution:capability:started',
      stepIndex: etapa.ordem,
      capabilityId: capability.id,
      capabilityName: capability.displayName
    });

    // 3.2. EXECUTA
    const startTime = Date.now();
    const resultado = await this.functionCaller.call(
      capability.funcao,
      capability.parametros
    );
    const duracao = Date.now() - startTime;

    // 3.3. NOTIFICA CONCLUSÃƒO
    onProgress({
      type: 'execution:capability:completed',
      stepIndex: etapa.ordem,
      capabilityId: capability.id,
      resultado,
      duracao
    });

    // 3.4. SALVA NA MEMÃ“RIA
    await this.memory.saveToWorkingMemory({
      tipo: 'capability_executed',
      capability: capability.funcao,
      resultado
    });
  }

  // 4. NOTIFICA CONCLUSÃƒO DA ETAPA
  onProgress({
    type: 'execution:step:completed',
    stepIndex: etapa.ordem,
    resultado: await this.summarizeStepResult(etapa)
  });
}
7. ANIMAÃ‡Ã•ES E FEEDBACK VISUAL
css
/* AnimaÃ§Ãµes suaves */
.execution-step {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.execution-step.active {
  border-left: 3px solid #f97316; /* Orange */
  background: rgba(249, 115, 22, 0.05);
}

.execution-step.completed {
  border-left: 3px solid #10b981; /* Green */
  opacity: 0.7;
}

.capability-item {
  animation: slideInFromLeft 0.3s ease-out;
}

@keyframes slideInFromLeft {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Loading spinner */
.status-badge.executing {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
8. CONFIGURAÃ‡ÃƒO
typescript
// config/developer-mode-config.ts

export const DEVELOPER_MODE_CONFIG = {
  // Comportamento
  autoExpandCurrentStep: true,
  autoCollapseCompletedSteps: true,
  allowManualExpand: true, // Permitir clicar para expandir etapas concluÃ­das
  
  // ExibiÃ§Ã£o
  showCapabilityDuration: true,
  showCapabilityParameters: false, // Esconder parÃ¢metros tÃ©cnicos por padrÃ£o
  maxVisibleSteps: 5, // Scroll apÃ³s 5 etapas
  
  // AnimaÃ§Ãµes
  stepTransitionDuration: 300, // ms
  capabilityAppearDelay: 100, // ms entre capabilities
  
  // Feedback
  showProgressPercentage: true,
  showEstimatedTime: false, // NÃ£o mostrar tempo estimado (pode ser impreciso)
  playSuccessSound: false,
  
  // Debug
  enableDevTools: process.env.NODE_ENV === 'development',
  logCapabilityCalls: true
};
RESUMO DO COMPORTAMENTO ESPERADO
Fluxo Visual Completo
âœ… UsuÃ¡rio clica "APLICAR PLANO"

âœ… Card de plano permanece estÃ¡tico (sem animaÃ§Ã£o)

âœ… Nova mensagem aparece: "Vou executar o seu plano de aÃ§Ã£o agora"

âœ… Card de Modo Desenvolvedor aparece abaixo

âœ… Primeira etapa expande automaticamente

âœ… Capabilities aparecem progressivamente conforme IA escolhe

âœ… Cada capability mostra status em tempo real (aguardando â†’ executando â†’ concluÃ­do)

âœ… Ao concluir etapa, ela colapsa e prÃ³xima expande automaticamente

âœ… Ao finalizar tudo, todas as etapas mostram checkmark verde

ARQUIVOS A SEREM CRIADOS/MODIFICADOS
text
/interface-modo-producao-chat/components/
â”œâ”€â”€ DeveloperModeCard.tsx          # NOVO - Card principal do modo dev
â”œâ”€â”€ ExecutionStepItem.tsx          # NOVO - Item de etapa individual
â”œâ”€â”€ CapabilityItem.tsx             # NOVO - Item de capability individual
â””â”€â”€ ExecutionConfirmationMessage.tsx # NOVO - Mensagem de confirmaÃ§Ã£o

/agente-jota-chat/executor/
â”œâ”€â”€ PlanExecutor.ts                # MODIFICAR - Adicionar escolha dinÃ¢mica
â””â”€â”€ CapabilityDecider.ts           # NOVO - LLM decide capabilities

/shared/types/
â””â”€â”€ execution-types.ts             # NOVO - Types para execuÃ§Ã£o

/config/
â””â”€â”€ developer-mode-config.ts       # NOVO - ConfiguraÃ§Ãµes do modo dev
PONTOS CRÃTICOS DE ATENÃ‡ÃƒO
âš ï¸ Performance:

Limitar nÃºmero de capabilities exibidas simultaneamente (max 10 por etapa)

Virtualizar lista se houver muitas etapas

âš ï¸ UX:

Loading spinners para indicar que capability estÃ¡ executando

TransiÃ§Ãµes suaves para nÃ£o causar "flashing"

Scroll automÃ¡tico para manter etapa atual visÃ­vel

âš ï¸ Erro Handling:

Se capability falhar, mostrar status vermelho mas continuar execuÃ§Ã£o

Permitir retry manual de capability falhada

Mostrar mensagem de erro amigÃ¡vel

âš ï¸ WebSocket:

Implementar reconnection automÃ¡tica

Buffer de eventos caso conexÃ£o caia temporariamente

Fallback para polling se WebSocket falhar