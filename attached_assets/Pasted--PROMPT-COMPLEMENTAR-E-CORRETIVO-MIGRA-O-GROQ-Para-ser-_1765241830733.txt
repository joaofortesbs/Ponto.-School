üîß PROMPT COMPLEMENTAR E CORRETIVO - MIGRA√á√ÉO GROQ
Para ser enviado AP√ìS o primeiro prompt ao Replit Agent
text
üéØ AGENT CORRETIVO: Validar, Debugar e Corrigir Erros da Migra√ß√£o Groq
=====================================================================

CONTEXTO: O prompt anterior foi executado, mas a integra√ß√£o Groq ainda n√£o est√° funcionando perfeitamente. 
Este prompt COMPLEMENTA e CORRIGE os problemas identificados.

‚ö†Ô∏è FASE 1: VALIDA√á√ÉO E DIAGN√ìSTICO

1. VERIFICAR ARQUIVO .env
   ‚òê Confirmar se GROQ_API_KEY est√° presente
   ‚òê IMPORTANTE: API key deve iniciar com 'gsk_'
   ‚òê Validar se n√£o tem espa√ßos extras (usar .trim())
   ‚òê Exemplo correto: GROQ_API_KEY=gsk_AIhyJ2qnSsKXvLnf0ckWGdyb3fYmoabcU7UuswKz9OsWuJmzdJp
   
2. VERIFICAR BaseURL em groqService.js
   ‚òê Deve ser: 'https://api.groq.com/openai/v1' (SEM /chat/completions no final!)
   ‚òê Procurar por qualquer 'https://api.groq.com/chat/completions' e REMOVER
   ‚òê Procurar por 'https://api.groq.com/v1' (falta /openai) e CORRIGIR
   ‚òê Verificar se baseURL est√° sendo passado corretamente ao inicializar Groq

3. VERIFICAR NOME DO MODELO
   ‚òê Procurar por 'llama3', 'gemini', 'gpt-4' ou nomes incorretos
   ‚òê SUBSTITUIR TODOS por: 'llama-3.3-70b-versatile'
   ‚òê Alternativas v√°lidas: 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'
   ‚òê Validar em TODAS as fun√ß√µes: generateFlashcards, generateQuiz, generateTest, chat

4. VERIFICAR max_tokens
   ‚òê Para 'llama-3.3-70b-versatile': max √© 8000 (n√£o mais!)
   ‚òê Se v√™ max_tokens: 10000 ou maior ‚Üí REDUZIR para 7000 ou menos
   ‚òê Verificar em TODAS as chamadas √† API

5. VERIFICAR AUTENTICA√á√ÉO
   ‚òê API key deve ter .trim() para remover espa√ßos
   ‚òê Exemplo: apiKey: process.env.GROQ_API_KEY?.trim()
   ‚òê Procurar por apiKey sem .trim() e ADICIONAR


‚ö†Ô∏è FASE 2: ADICIONAR TRATAMENTO DE ERROS ROBUSTO

1. ENVOLVER TODAS AS CHAMADAS COM try-catch
   ‚òê Cada fun√ß√£o (generateFlashcards, generateQuiz, etc) deve ter:
      try {
        const completion = await groq.chat.completions.create({...});
        // processar resposta
      } catch (err) {
        if (err instanceof Groq.AuthenticationError) {
          console.error('‚ùå API key inv√°lida ou expirada');
        } else if (err.status === 429) {
          console.error('‚ùå Rate limit atingido');
        } else {
          console.error('‚ùå Erro:', err.message);
        }
        throw err;
      }

2. IMPLEMENTAR VALIDA√á√ÉO DE RESPOSTA
   ‚òê Adicionar em CADA fun√ß√£o:
      const content = response.choices[0]?.message?.content;
      if (!content || content.trim() === '') {
        console.warn('‚ö†Ô∏è Resposta vazia do modelo');
        return [];  // ou fallback apropriado
      }

3. ADICIONAR PARSING JSON SEGURO
   ‚òê Quando usar JSON.parse(), fazer com try-catch:
      try {
        const jsonStr = content.replace(/``````\n?/g, '').trim();
        return JSON.parse(jsonStr);
      } catch (err) {
        console.error('‚ùå Erro ao parsear JSON:', err.message);
        return [];  // fallback para array vazio
      }

4. IMPLEMENTAR RETRY COM BACKOFF EXPONENCIAL
   ‚òê Criar fun√ß√£o gen√©rica:
      async function withRetry(asyncFn, maxRetries = 3) {
        let lastError;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            return await asyncFn();
          } catch (err) {
            lastError = err;
            if (err.status === 429 && attempt < maxRetries - 1) {
              const waitTime = Math.pow(2, attempt) * 1000;
              console.log(`‚è≥ Rate limited. Aguardando ${waitTime}ms...`);
              await new Promise(r => setTimeout(r, waitTime));
            } else if (err.code === 'ECONNREFUSED' && attempt < maxRetries - 1) {
              const waitTime = (attempt + 1) * 2000;
              console.log(`‚è≥ Conex√£o recusada. Tentando em ${waitTime}ms...`);
              await new Promise(r => setTimeout(r, waitTime));
            } else {
              throw err;
            }
          }
        }
        throw lastError;
      }
   
   ‚òê Envolver todas as chamadas groq.chat.completions.create():
      return withRetry(async () => {
        const completion = await groq.chat.completions.create({...});
        // processar
      });

5. ADICIONAR VALIDA√á√ÉO INICIAL DO CLIENTE GROQ
   ‚òê No in√≠cio de groqService.js:
      const apiKey = process.env.GROQ_API_KEY?.trim();
      if (!apiKey || !apiKey.startsWith('gsk_')) {
        throw new Error('‚ùå GROQ_API_KEY inv√°lida! Verifique .env');
      }
      
      if (!apiKey.includes('gsk_')) {
        throw new Error('‚ùå Chave deve iniciar com "gsk_"');
      }


‚ö†Ô∏è FASE 3: CORRIGIR ESTRUTURA DAS FUN√á√ïES

1. generateFlashcards() - VALIDA√á√ïES:
   ‚òê Verificar se role est√° correto: 'user', 'assistant', 'system' (nunca 'bot')
   ‚òê Verificar se temperature est√° entre 0 e 2.0
   ‚òê Verificar se top_p est√° entre 0 e 1.0
   ‚òê Validar que messages array n√£o est√° vazio
   ‚òê Adicionar fallback se content vazio:
      if (!content || content.trim() === '') return [];

2. generateQuiz() - MESMAS VALIDA√á√ïES

3. generateTest() - MESMAS VALIDA√á√ïES

4. chat() - VALIDA√á√ïES EXTRAS:
   ‚òê Verificar conversationHistory √© array
   ‚òê Validar que userMessage n√£o est√° vazio
   ‚òê Implementar limite de hist√≥rico (√∫ltimas 10 mensagens, exemplo)
   ‚òê Adicionar fallback se content vazio:
      if (!content || content.trim() === '') {
        return 'Desculpe, n√£o consegui processar. Tente novamente.';
      }


‚ö†Ô∏è FASE 4: TESTES DE VALIDA√á√ÉO

Executar os testes abaixo sequencialmente e reportar CADA resultado:

// TEST 1: Validar conex√£o
async function testConnection() {
try {
const models = await groq.models.list();
console.log('‚úÖ Conex√£o com Groq: OK');
console.log('üìã Modelos dispon√≠veis:', models.data.map(m => m.id));
return true;
} catch (err) {
console.error('‚ùå Conex√£o falhou:', err.message);
return false;
}
}

// TEST 2: Testar flashcards
async function testFlashcards() {
try {
const result = await generateFlashcards('Teste', 2);
if (Array.isArray(result) && result.length > 0) {
console.log('‚úÖ generateFlashcards: OK');
return true;
} else {
console.warn('‚ö†Ô∏è generateFlashcards retornou array vazio');
return false;
}
} catch (err) {
console.error('‚ùå generateFlashcards falhou:', err.message);
return false;
}
}

// TEST 3: Testar quiz
async function testQuiz() {
try {
const result = await generateQuiz('Teste', 2);
if (Array.isArray(result) && result.length > 0) {
console.log('‚úÖ generateQuiz: OK');
return true;
} else {
console.warn('‚ö†Ô∏è generateQuiz retornou array vazio');
return false;
}
} catch (err) {
console.error('‚ùå generateQuiz falhou:', err.message);
return false;
}
}

// TEST 4: Testar teste/prova
async function testTest() {
try {
const result = await generateTest('Teste', 3, 'f√°cil');
if (typeof result === 'string' && result.length > 10) {
console.log('‚úÖ generateTest: OK');
return true;
} else {
console.warn('‚ö†Ô∏è generateTest retornou resposta inv√°lida');
return false;
}
} catch (err) {
console.error('‚ùå generateTest falhou:', err.message);
return false;
}
}

// TEST 5: Testar chat
async function testChat() {
try {
const result = await chat('Ol√°, como voc√™ est√°?', []);
if (typeof result === 'string' && result.length > 5) {
console.log('‚úÖ chat: OK');
return true;
} else {
console.warn('‚ö†Ô∏è chat retornou resposta inv√°lida');
return false;
}
} catch (err) {
console.error('‚ùå chat falhou:', err.message);
return false;
}
}

// EXECUTAR TODOS OS TESTES
async function runAllTests() {
console.log('üß™ INICIANDO TESTES DE VALIDA√á√ÉO...\n');

const test1 = await testConnection();
const test2 = await testFlashcards();
const test3 = await testQuiz();
const test4 = await testTest();
const test5 = await testChat();

const totalPassed = [test1, test2, test3, test4, test5].filter(t => t).length;
console.log( \nüìä RESULTADO: ${totalPassed}/5 testes passaram);

if (totalPassed === 5) {
console.log('‚ú® MIGRA√á√ÉO GROQ: 100% FUNCIONAL!');
} else {
console.log('‚ö†Ô∏è Ainda h√° problemas. Verifique os erros acima.');
}
}

// Executor
runAllTests();

texto


‚ö†Ô∏è FASE 5: CHECKLIST FINAL DE VERIFICA√á√ÉO

Antes de considerar pronto, verificar:

[ ] .env tem GROQ_API_KEY correta
[ ] groqService.js importa dotenv e executa dotenv.config()
[ ] Todas as fun√ß√µes usam 'llama-3.3-70b-versatile'
[ ] Todas as fun√ß√µes t√™m baseURL: 'https://api.groq.com/openai/v1'
[ ] max_tokens est√° <= 8000
[ ] API key tem .trim()
[ ] Todas as fun√ß√µes t√™m try-catch
[ ] JSON parsing tem try-catch
[ ] Retry com backoff implementado
[ ] Valida√ß√£o de resposta vazia implementada
[ ] Testes passam 5/5
[ ] Nenhuma mensagem de erro no console
[ ] Responses n√£o est√£o vazias ou null


‚ö†Ô∏è SE AINDA TIVER ERROS, REPORTAR:

1. QUAL TESTE FALHOU? (1, 2, 3, 4 ou 5)
2. QUAL FOI A MENSAGEM DE ERRO EXATA?
3. QUAL FOI O STACK TRACE?
4. O arquivo groqService.js est√° estruturado corretamente?
5. O .env tem a chave correta?

Depois farei uma investiga√ß√£o profunda e nova corre√ß√£o.