ğŸ¯ PROMPT CRÃTICO - CONFIGURAÃ‡ÃƒO DAS 4 CAPABILITIES CORE
CONTEXTO ESTRATÃ‰GICO
VocÃª estÃ¡ implementando as 4 capabilities fundamentais que formam o coraÃ§Ã£o do sistema School Power 2.0. Estas capabilities representam o ciclo completo: BUSCAR â†’ DECIDIR â†’ CRIAR â†’ ENTREGAR. Cada uma tem responsabilidades distintas mas interdependentes.

Aja com a mentalidade de:

Martin Fowler (enterprise integration patterns)

Eric Evans (domain-driven design, bounded contexts)

Greg Young (CQRS, event sourcing)

Sam Newman (microservices, service boundaries)

VISÃƒO MACRO DO SISTEMA
Fluxo de Dados (Pipeline ObrigatÃ³rio)
text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CAPABILITY 1: pesquisar_atividades_conta           â”‚
â”‚ Fonte: Database Neon (PostgreSQL)                  â”‚
â”‚ Output: Lista de atividades jÃ¡ criadas pelo prof   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CAPABILITY 2: pesquisar_atividades_disponiveis     â”‚
â”‚ Fonte: JSON Local (schoolPowerActivities.json)     â”‚
â”‚ Output: CatÃ¡logo completo de atividades possÃ­veis  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CAPABILITY 3: decidir_atividades_criar             â”‚
â”‚ Input: Dados de 1 + 2 + Contexto do usuÃ¡rio       â”‚
â”‚ Output: Lista filtrada de atividades escolhidas    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CAPABILITY 4: criar_atividade                      â”‚
â”‚ Input: DecisÃµes de 3                               â”‚
â”‚ Output: Interface de ConstruÃ§Ã£o + Atividades reais â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CAPABILITY 1: pesquisar_atividades_conta
Responsabilidade:
Buscar atividades que o professor jÃ¡ criou anteriormente no sistema, armazenadas no banco de dados Neon.

Fonte de Dados: Neon PostgreSQL
DecisÃµes Arquiteturais que VOCÃŠ deve tomar:

1. Database Connection Strategy
Como estabelecer conexÃ£o segura com Neon?

Pool de conexÃµes ou conexÃ£o por request?

Timeout e retry logic?

Connection string vem de environment variables?

2. Query Strategy
VocÃª precisa decidir a query SQL exata. Considere:

BÃ¡sico (retorna tudo):

sql
SELECT * FROM atividades WHERE professor_id = ?
IntermediÃ¡rio (com filtros):

sql
SELECT * FROM atividades 
WHERE professor_id = ? 
  AND deleted_at IS NULL
  AND status = 'published'
ORDER BY created_at DESC
AvanÃ§ado (com joins e metadata):

sql
SELECT 
  a.*,
  t.nome as turma_nome,
  COUNT(DISTINCT ua.aluno_id) as total_usos,
  AVG(ua.rating) as rating_medio
FROM atividades a
LEFT JOIN turmas t ON a.turma_id = t.id
LEFT JOIN uso_atividades ua ON a.id = ua.atividade_id
WHERE a.professor_id = ?
  AND a.deleted_at IS NULL
GROUP BY a.id, t.nome
ORDER BY a.created_at DESC
VocÃª decide: Qual nÃ­vel de complexidade Ã© necessÃ¡rio?

3. Data Transformation
Dados do banco vÃªm em formato SQL row. VocÃª deve transformar para estrutura que IA entende.

PadrÃ£o sugerido (vocÃª implementa):

typescript
interface AtividadeFromDB {
  id: string;
  titulo: string;
  tipo: string;
  disciplina: string;
  conteudo: any; // JSON blob
  created_at: Date;
  // ... outros campos
}

interface AtividadeForAI {
  id: string;
  titulo: string;
  tipo: string;
  metadata: {
    disciplina: string;
    nivel: string;
    tags: string[];
  };
  usage_stats: {
    times_used: number;
    avg_rating: number;
  };
  was_successful: boolean; // HeurÃ­stica baseada em ratings
}

function transformDBtoAI(dbActivities: AtividadeFromDB[]): AtividadeForAI[] {
  // Sua lÃ³gica de transformaÃ§Ã£o
}
4. Anti-Hallucination Measures
CRÃTICO: Esta capability deve retornar estrutura que previne alucinaÃ§Ã£o.

Formato de retorno obrigatÃ³rio:

typescript
interface SearchAccountActivitiesResult {
  found: boolean;
  count: number;
  activities: AtividadeForAI[] | null;
  metadata: {
    query_timestamp: string;
    professor_id: string;
    database: "neon_production";
  };
  isEmpty: boolean;
  summary: string; // "Encontradas 5 atividades" ou "Nenhuma atividade encontrada"
}
Este objeto vai DIRETO para o prompt da IA:

text
DADOS DE ATIVIDADES NA CONTA DO PROFESSOR:
- Total encontrado: {result.count}
- Status: {result.isEmpty ? "VAZIO - Nenhuma atividade criada ainda" : "DADOS DISPONÃVEIS"}
- Lista completa: {JSON.stringify(result.activities)}

IMPORTANTE: VocÃª DEVE usar APENAS as atividades listadas acima.
Se count = 0, vocÃª DEVE informar que nÃ£o hÃ¡ atividades anteriores.
5. Error Handling
CenÃ¡rios que VOCÃŠ deve tratar:

Database connection failed

Query timeout

Professor_id invÃ¡lido

Tabela vazia (professor novo)

Dados corrompidos no banco

Para cada cenÃ¡rio, decida:

Retry? Quantas vezes?

Fallback value (retornar vazio ou erro)?

Log level (error, warn, info)?

User notification (mostrar erro ou silencioso)?

6. Performance Considerations
Perguntas a responder:

Cache results? Por quanto tempo?

Limit de registros (ex: Ãºltimas 100 atividades)?

Pagination (se professor tem 1000+ atividades)?

Lazy loading ou eager loading de relationships?

CAPABILITY 2: pesquisar_atividades_disponiveis
Responsabilidade:
Consultar o catÃ¡logo completo de atividades que o sistema pode criar, definido no arquivo JSON local.

Fonte de Dados: schoolPowerActivities.json
DecisÃµes Arquiteturais que VOCÃŠ deve tomar:

1. File Access Strategy
O arquivo estÃ¡ em src/features/schoolpower/data/schoolPowerActivities.json

OpÃ§Ãµes de acesso:

Static Import: import activities from './data/schoolPowerActivities.json'

Pro: Bundled, rÃ¡pido, type-safe

Con: NÃ£o atualiza sem rebuild

Dynamic Import: const activities = await import('./data/schoolPowerActivities.json')

Pro: Code-splitting

Con: AssÃ­ncrono, mais complexo

Fetch API: const activities = await fetch('/data/schoolPowerActivities.json')

Pro: Pode atualizar arquivo sem rebuild

Con: Overhead de network request

File System (Node.js): fs.readFileSync('./data/schoolPowerActivities.json')

Pro: Funciona em server-side

Con: NÃ£o funciona em browser

VocÃª decide: Qual approach baseado em onde essa capability executa (client/server/edge)?

2. JSON Schema Validation
O arquivo JSON tem estrutura esperada? VocÃª DEVE validar.

PadrÃµes a considerar:

Zod: Schema validation com TypeScript inference

Ajv: JSON Schema validator (performance)

Yup: Validation library

Custom validator: Se arquivo Ã© trusted

Schema esperado (vocÃª refina):

typescript
const ActivityCatalogSchema = z.object({
  version: z.string(),
  total_activities: z.number(),
  activities: z.array(z.object({
    id: z.string(),
    titulo: z.string(),
    tipo: z.string(),
    categoria: z.string(),
    campos_obrigatorios: z.array(z.string()),
    schema_campos: z.record(z.any()),
    // ... outros campos
  }))
});

type ActivityCatalog = z.infer<typeof ActivityCatalogSchema>;
3. Filtering and Search
IA pode querer filtrar atividades do catÃ¡logo. VocÃª deve implementar.

Capacidades de filtro necessÃ¡rias:

typescript
interface FilterOptions {
  tipo?: string[];          // ["plano-aula", "quiz"]
  categoria?: string[];     // ["planejamento", "avaliacao"]
  disciplina?: string[];    // ["matematica", "portugues"]
  nivel?: string[];         // ["fundamental1", "fundamental2"]
  tags?: string[];          // ["bncc", "gamificacao"]
  search_text?: string;     // Busca em titulo/descricao
}

function filterActivities(
  catalog: Activity[],
  filters: FilterOptions
): Activity[] {
  // Sua lÃ³gica de filtro
  // Considere: case-insensitive, partial match, scoring
}
4. Anti-Hallucination: CRITICAL
ESTE Ã‰ O PONTO MAIS CRÃTICO: IA NÃƒO pode inventar atividades fora do JSON.

EstratÃ©gia de Enforcement (vocÃª implementa):

A. Whitelist ExplÃ­cita no Prompt:

text
ATIVIDADES DISPONÃVEIS NO CATÃLOGO (FONTE DE VERDADE):

Total: {catalog.total_activities}
IDs vÃ¡lidos: {catalog.activities.map(a => a.id).join(', ')}

LISTA COMPLETA:
{JSON.stringify(catalog.activities, null, 2)}

âš ï¸ REGRA ABSOLUTA:
VocÃª DEVE escolher APENAS atividades desta lista.
Se vocÃª mencionar um ID que nÃ£o estÃ¡ nesta lista, o sistema REJEITARÃ.
Se vocÃª criar um tipo de atividade que nÃ£o existe aqui, o sistema REJEITARÃ.
B. Validation Post-LLM:

typescript
function validateAIChoices(
  aiChosenIds: string[],
  validCatalog: Activity[]
): ValidationResult {
  const validIds = new Set(validCatalog.map(a => a.id));
  const invalidIds = aiChosenIds.filter(id => !validIds.has(id));
  
  if (invalidIds.length > 0) {
    return {
      valid: false,
      error: `IA escolheu IDs invÃ¡lidos: ${invalidIds.join(', ')}`,
      action: 'reject_and_retry_with_reinforced_prompt'
    };
  }
  
  return { valid: true };
}
C. Embeddings + Semantic Search (AvanÃ§ado):
Se IA pedir "atividade sobre fraÃ§Ãµes", vocÃª deve:

Gerar embedding da query

Calcular similarity com embeddings de atividades do catÃ¡logo

Retornar top-K matches

Garantir que IA escolhe APENAS destas matches

5. Caching Strategy
Arquivo JSON nÃ£o muda frequentemente. Cache agressivo Ã© recomendado.

DecisÃµes:

In-memory cache (variÃ¡vel global)?

Browser cache (localStorage/sessionStorage)?

Server cache (Redis)?

Invalidation strategy (TTL? Manual?)?

6. Return Format
Formato padronizado para IA:

typescript
interface SearchAvailableActivitiesResult {
  found: boolean;
  count: number;
  activities: Activity[];
  filtered_count?: number; // Se filtros aplicados
  filters_applied?: FilterOptions;
  metadata: {
    catalog_version: string;
    query_timestamp: string;
    source: "schoolPowerActivities.json";
  };
  summary: string; // "Encontradas 137 atividades no catÃ¡logo"
}
CAPABILITY 3: decidir_atividades_criar
Responsabilidade:
IA analisa contexto completo (dados de cap1, cap2, contexto do usuÃ¡rio) e decide estrategicamente quais atividades criar.

Inputs desta Capability:
Esta capability recebe:

Resultado de pesquisar_atividades_conta

Resultado de pesquisar_atividades_disponiveis

Contexto do usuÃ¡rio (Quiz de ContextualizaÃ§Ã£o)

Objetivo/prompt do usuÃ¡rio

DecisÃµes Arquiteturais:
1. Decision Engine Architecture
Como IA vai decidir? VocÃª precisa estruturar o raciocÃ­nio.

OpÃ§Ã£o A: Pure LLM Decision

text
Enviar todo contexto para LLM.
LLM retorna lista de IDs escolhidos + justificativa.
OpÃ§Ã£o B: Rule-Based + LLM

text
Primeiro: Aplicar regras hard-coded
  - Se disciplina = MatemÃ¡tica â†’ Filtrar atividades de matemÃ¡tica
  - Se nÃ­vel = Fundamental I â†’ Excluir atividades avanÃ§adas
Depois: LLM escolhe dentro do subset filtrado
OpÃ§Ã£o C: Scoring System + LLM Ranking

text
Sistema calcula score para cada atividade:
  - RelevÃ¢ncia para disciplina: +10
  - Match com nÃ­vel: +10
  - Foi usada antes com sucesso: +5
  - Popular no sistema: +3
LLM recebe top-20 por score, escolhe 3-5 finais
VocÃª decide qual approach baseado em:

Controle desejado

Previsibilidade

Flexibilidade

Performance

2. Context Assembly
VocÃª deve montar um prompt estruturado. Exemplo conceitual:

typescript
interface DecisionContext {
  user_objective: string;
  user_context: {
    disciplina: string;
    turma?: {
      nome: string;
      nivel: string;
      alunos_count: number;
    };
    tempo_disponivel?: string;
    objetivo_pedagogico: string;
  };
  available_activities: Activity[]; // Do catÃ¡logo
  previous_activities: AtividadeForAI[]; // Do banco
  constraints: {
    max_activities: number;
    preferred_types?: string[];
    avoid_types?: string[];
  };
}

function buildDecisionPrompt(context: DecisionContext): string {
  return `
# TAREFA: Decidir quais atividades criar

## OBJETIVO DO USUÃRIO
${context.user_objective}

## CONTEXTO DO PROFESSOR
- Disciplina: ${context.user_context.disciplina}
- Turma: ${context.user_context.turma?.nome || 'NÃ£o especificada'}
- NÃ­vel: ${context.user_context.turma?.nivel || 'NÃ£o especificado'}
- Alunos: ${context.user_context.turma?.alunos_count || 'NÃ£o especificado'}

## ATIVIDADES DISPONÃVEIS NO CATÃLOGO
Total: ${context.available_activities.length}
Lista: ${JSON.stringify(context.available_activities)}

## ATIVIDADES JÃ CRIADAS PELO PROFESSOR
Total: ${context.previous_activities.length}
${context.previous_activities.length > 0 
  ? 'Lista: ' + JSON.stringify(context.previous_activities)
  : 'Nenhuma atividade anterior encontrada.'}

## CONSTRAINTS
- MÃ¡ximo de atividades: ${context.constraints.max_activities}
- Tipos preferidos: ${context.constraints.preferred_types?.join(', ') || 'Nenhum'}

## INSTRUÃ‡Ã•ES DE DECISÃƒO

1. Analise o objetivo do usuÃ¡rio e contexto
2. Escolha ${context.constraints.max_activities} atividades do CATÃLOGO DISPONÃVEL
3. Priorize:
   - RelevÃ¢ncia para disciplina e nÃ­vel
   - ProgressÃ£o pedagÃ³gica (bÃ¡sico â†’ avanÃ§ado)
   - Diversidade de tipos (nÃ£o repetir mesmo tipo)
   - Atividades que o professor ainda nÃ£o criou (se possÃ­vel)

4. RETORNE JSON:
{
  "atividades_escolhidas": [
    {
      "id": "id_do_catalogo",
      "titulo": "titulo_exato_do_catalogo",
      "justificativa": "por que escolhi esta"
    }
  ],
  "estrategia_pedagogica": "explicaÃ§Ã£o da progressÃ£o escolhida",
  "total_escolhidas": nÃºmero
}

âš ï¸ CRÃTICO: Use APENAS IDs do catÃ¡logo listado acima.
  `;
}
3. Output Validation
IA retornou decisÃ£o. VocÃª DEVE validar antes de prosseguir.

ValidaÃ§Ãµes obrigatÃ³rias:

typescript
interface DecisionValidation {
  all_ids_valid: boolean;        // Todos IDs existem no catÃ¡logo?
  count_within_limit: boolean;   // Respeitou max_activities?
  has_justification: boolean;    // Forneceu justificativas?
  no_duplicates: boolean;        // Sem IDs repetidos?
  fields_complete: boolean;      // Todos campos obrigatÃ³rios?
}

function validateDecision(
  decision: AIDecision,
  catalog: Activity[],
  constraints: Constraints
): DecisionValidation {
  // Implementar todas validaÃ§Ãµes
  // Se alguma falhar â†’ Reject & Retry
}
4. State Management
DecisÃ£o aprovada precisa ser armazenada para prÃ³xima capability.

DecisÃµes de state management:

Onde guardar? (Context, Redux, Zustand, State local)

Como prÃ³xima capability acessa? (Props, Context, Store)

Formato de persistÃªncia (JSON, estrutura especÃ­fica)

Quanto tempo persiste (sessÃ£o, localStorage, temporÃ¡rio)

Estrutura sugerida:

typescript
interface CapabilityState {
  pesquisar_conta: {
    status: 'completed';
    result: SearchAccountActivitiesResult;
    timestamp: string;
  };
  pesquisar_disponiveis: {
    status: 'completed';
    result: SearchAvailableActivitiesResult;
    timestamp: string;
  };
  decidir: {
    status: 'completed';
    result: {
      escolhidas: ChosenActivity[];
      estrategia: string;
      metadata: any;
    };
    timestamp: string;
  };
  criar: {
    status: 'pending' | 'executing' | 'completed';
    // ...
  };
}
5. Feedback Loop
Se decisÃ£o falhar validaÃ§Ã£o, como informar IA?

EstratÃ©gia de retry:

typescript
async function decideWithRetry(
  context: DecisionContext,
  maxRetries: number = 2
): Promise<ValidatedDecision> {
  for (let i = 0; i < maxRetries; i++) {
    const decision = await callLLM(buildDecisionPrompt(context));
    const validation = validateDecision(decision, context.catalog, context.constraints);
    
    if (validation.all_valid) {
      return decision;
    }
    
    // Retry com prompt reforÃ§ado
    context.retry_feedback = {
      attempt: i + 1,
      errors: validation.errors,
      reinforcement: "VocÃª cometeu erros na tentativa anterior. Corrija:"
    };
  }
  
  throw new Error('IA falhou em decidir corretamente apÃ³s retries');
}
CAPABILITY 4: criar_atividade
Responsabilidade:
Mostrar interface de construÃ§Ã£o de atividades com as escolhas da capability anterior, permitindo criaÃ§Ã£o automatizada.

UI Component Integration
CRÃTICO: Esta capability tem componente visual que aparece no card de desenvolvimento.

DecisÃµes Arquiteturais:
1. Component Location & Mounting
Hierarquia visual:

text
<ExecutionCard>
  <Objective>Criar atividades personalizadas</Objective>
  <Capability status="completed">Pesquisar disponÃ­veis</Capability>
  <Capability status="completed">Decidir quais criar</Capability>
  <Capability status="executing">Criar atividades</Capability>
  
  {/* AQUI: Interface de ConstruÃ§Ã£o aparece */}
  <ActivityConstructionInterface 
    activities={decidedActivities}
    onBuildAll={handleBuildAll}
    onBuildSingle={handleBuildSingle}
  />
</ExecutionCard>
DecisÃµes:

Renderizar dentro do card de desenvolvimento ou fora?

Usar Portal para renderizaÃ§Ã£o?

AnimaÃ§Ã£o de entrada (slide, fade)?

Posicionamento exato (abaixo de capability, centralizado)?

2. Data Synchronization
CRÃTICO: Interface precisa receber exatamente as atividades decididas na cap3.

PadrÃ£o de sincronizaÃ§Ã£o:

typescript
// Capability 3 terminou e salvou decisÃ£o
const decision = capabilityState.decidir.result;

// Capability 4 inicia e lÃª decisÃ£o
useEffect(() => {
  if (capabilityState.decidir.status === 'completed') {
    const activitiesToBuild = capabilityState.decidir.result.escolhidas;
    setConstructionQueue(activitiesToBuild);
    showConstructionInterface();
  }
}, [capabilityState.decidir.status]);
ValidaÃ§Ã£o de sincronizaÃ§Ã£o:

NÃºmero de atividades coincide?

IDs sÃ£o os mesmos?

Campos obrigatÃ³rios preenchidos?

OrdenaÃ§Ã£o mantida?

3. Construction Interface Component
Este componente jÃ¡ existe no School Power 1.0. VocÃª precisa:

Localizar o componente nos arquivos

Verificar se ainda funciona

Adaptar para nova arquitetura se necessÃ¡rio

Integrar no fluxo de capabilities

QuestÃµes a investigar:

Onde estÃ¡ o componente? (path exato)

Nome do componente? (ActivityBuilder? ConstructionCard?)

Props que ele aceita?

Estado interno dele?

Emite eventos/callbacks?

Interface esperada (vocÃª ajusta baseado no real):

typescript
interface ActivityConstructionInterfaceProps {
  activities: ChosenActivity[];
  onActivityBuilt: (activityId: string, result: Activity) => void;
  onAllBuilt: (results: Activity[]) => void;
  onError: (error: Error) => void;
  autoStart?: boolean;
}

// Exemplo de uso
<ActivityConstructionInterface
  activities={chosenActivities}
  onActivityBuilt={(id, result) => {
    console.log(`Atividade ${id} construÃ­da:`, result);
    updateProgress(id, 'completed');
  }}
  onAllBuilt={(results) => {
    console.log('Todas construÃ­das:', results);
    moveToNextCapability();
  }}
  autoStart={true}
/>
4. Construction Process
Fluxo de construÃ§Ã£o (jÃ¡ existia no 1.0, vocÃª replica/melhora):

text
Para cada atividade escolhida:
1. Mostrar card de "Aguardando construÃ§Ã£o"
2. Sistema preenche modal de ediÃ§Ã£o com campos
3. IA ou sistema completa campos obrigatÃ³rios
4. Sistema salva no banco de dados
5. Card atualiza para "ConstruÃ­da âœ“"
6. Repetir para prÃ³xima
DecisÃµes que VOCÃŠ toma:

Construir sequencial (uma por vez) ou paralelo (todas juntas)?

Mostrar preview de cada atividade antes de construir?

Permitir ediÃ§Ã£o manual pelo usuÃ¡rio ou totalmente automatizado?

Como tratar erro em uma atividade? (Skip, retry, abort all)

5. Progress Tracking
UsuÃ¡rio deve ver progresso de construÃ§Ã£o em tempo real.

UI de progresso:

typescript
interface ConstructionProgress {
  total: number;
  completed: number;
  failed: number;
  current: string | null; // ID da atividade sendo construÃ­da
  percentage: number;
}

// ExibiÃ§Ã£o visual
<ProgressBar>
  {progress.completed} de {progress.total} atividades construÃ­das
  ({progress.percentage}%)
</ProgressBar>

{activities.map(activity => (
  <ActivityCard
    key={activity.id}
    status={getStatus(activity.id)}
    title={activity.titulo}
  >
    {status === 'building' && <Spinner />}
    {status === 'completed' && <CheckIcon />}
    {status === 'failed' && <ErrorIcon />}
  </ActivityCard>
))}
6. Database Persistence
Atividades construÃ­das precisam ser salvas no Neon.

DecisÃµes de persistÃªncia:

Salvar uma por vez ou batch insert?

TransaÃ§Ã£o (rollback se alguma falhar)?

Gerar IDs no frontend ou backend?

ValidaÃ§Ã£o de dados antes de salvar?

Estrutura de salvamento (vocÃª implementa):

typescript
async function saveActivityToDB(activity: BuiltActivity): Promise<SaveResult> {
  try {
    // Validar dados
    const validated = validateActivity(activity);
    
    // Insert no banco
    const result = await db.atividades.create({
      data: {
        professor_id: session.user.id,
        titulo: validated.titulo,
        tipo: validated.tipo,
        conteudo: validated.conteudo, // JSON
        campos: validated.campos,     // JSON
        // ... outros campos
      }
    });
    
    return { success: true, id: result.id };
  } catch (error) {
    return { success: false, error };
  }
}
7. Error Handling & Recovery
CenÃ¡rios de erro:

Campo obrigatÃ³rio faltando

Falha de conexÃ£o com banco

Timeout na criaÃ§Ã£o

Dados invÃ¡lidos

Para cada cenÃ¡rio, decida:

Retry automÃ¡tico?

Notificar usuÃ¡rio?

Pular atividade problemÃ¡tica?

Abortar todo processo?

EstratÃ©gia sugerida:

typescript
async function buildActivityWithRetry(
  activity: ChosenActivity,
  maxRetries: number = 2
): Promise<BuildResult> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const built = await buildActivity(activity);
      const saved = await saveActivityToDB(built);
      return { success: true, data: saved };
    } catch (error) {
      if (i === maxRetries - 1) {
        // Ãšltima tentativa falhou
        return { 
          success: false, 
          error,
          action: 'skip_and_notify_user'
        };
      }
      // Retry com delay exponencial
      await sleep(1000 * Math.pow(2, i));
    }
  }
}
8. Post-Construction Actions
ApÃ³s todas atividades construÃ­das, o que acontece?

OpÃ§Ãµes:

Mostrar resumo de sucesso

Permitir visualizar/editar atividades criadas

Organizar em plano de aula (prÃ³xima capability?)

Compartilhar com turma

Exportar para PDF

VocÃª decide o fluxo pÃ³s-construÃ§Ã£o baseado em UX desejada.

INTEGRAÃ‡ÃƒO ENTRE AS 4 CAPABILITIES
Pipeline Completo (VocÃª implementa)
typescript
// Orquestrador de capabilities
class CapabilityOrchestrator {
  private state: CapabilityState;
  
  async executeCapability1() {
    this.updateStatus('pesquisar_conta', 'executing');
    
    const result = await searchAccountActivities(this.userId);
    
    this.state.pesquisar_conta = {
      status: 'completed',
      result,
      timestamp: new Date().toISOString()
    };
    
    return result;
  }
  
  async executeCapability2() {
    this.updateStatus('pesquisar_disponiveis', 'executing');
    
    const result = await searchAvailableActivities();
    
    this.state.pesquisar_disponiveis = {
      status: 'completed',
      result,
      timestamp: new Date().toISOString()
    };
    
    return result;
  }
  
  async executeCapability3() {
    // Precisa de resultados de 1 e 2
    if (
      this.state.pesquisar_conta.status !== 'completed' ||
      this.state.pesquisar_disponiveis.status !== 'completed'
    ) {
      throw new Error('Dependencies not completed');
    }
    
    const context = this.assembleDecisionContext();
    const decision = await decideActivities(context);
    const validated = await validateDecision(decision);
    
    this.state.decidir = {
      status: 'completed',
      result: validated,
      timestamp: new Date().toISOString()
    };
    
    return validated;
  }
  
  async executeCapability4() {
    // Precisa de resultado de 3
    if (this.state.decidir.status !== 'completed') {
      throw new Error('Decision not completed');
    }
    
    const activitiesToBuild = this.state.decidir.result.escolhidas;
    
    // Renderizar UI de construÃ§Ã£o
    this.renderConstructionInterface(activitiesToBuild);
    
    // Esperar construÃ§Ã£o completar
    const results = await this.waitForConstruction();
    
    this.state.criar = {
      status: 'completed',
      result: results,
      timestamp: new Date().toISOString()
    };
    
    return results;
  }
}
Event System
Capabilities se comunicam via eventos.

Eventos importantes:

typescript
enum CapabilityEvent {
  CAP1_STARTED = 'capability:pesquisar_conta:started',
  CAP1_COMPLETED = 'capability:pesquisar_conta:completed',
  CAP1_FAILED = 'capability:pesquisar_conta:failed',
  
  CAP2_STARTED = 'capability:pesquisar_disponiveis:started',
  CAP2_COMPLETED = 'capability:pesquisar_disponiveis:completed',
  
  CAP3_STARTED = 'capability:decidir:started',
  CAP3_COMPLETED = 'capability:decidir:completed',
  CAP3_VALIDATION_FAILED = 'capability:decidir:validation_failed',
  
  CAP4_STARTED = 'capability:criar:started',
  CAP4_ACTIVITY_BUILT = 'capability:criar:activity_built',
  CAP4_ALL_BUILT = 'capability:criar:all_built',
  CAP4_ERROR = 'capability:criar:error',
}

// Event emitter
eventBus.on(CapabilityEvent.CAP3_COMPLETED, (decision) => {
  // Capability 4 escuta e inicia
  executeCapability4(decision);
});
DEBUGGING E LOGGING
Logging Estruturado ObrigatÃ³rio
Cada capability deve logar detalhadamente.

typescript
logger.info('Capability 1: Pesquisar Atividades Conta', {
  capability_id: 'cap_pesquisar_conta',
  user_id: userId,
  status: 'started',
  timestamp: Date.now()
});

// ApÃ³s query
logger.info('Database query completed', {
  capability_id: 'cap_pesquisar_conta',
  query_duration_ms: duration,
  rows_returned: result.length,
  database: 'neon_production'
});

// Resultado
logger.info('Capability 1: Completed', {
  capability_id: 'cap_pesquisar_conta',
  result_count: result.count,
  isEmpty: result.isEmpty,
  status: 'completed'
});
Debug Panel Para Desenvolvedor
tsx
{isDev && (
  <DebugPanel>
    <h3>Capability State</h3>
    <pre>{JSON.stringify(capabilityState, null, 2)}</pre>
    
    <h3>Data Flow</h3>
    <Timeline>
      {events.map(e => (
        <TimelineItem 
          event={e.type} 
          timestamp={e.timestamp}
          data={e.data}
        />
      ))}
    </Timeline>
    
    <h3>Validation Results</h3>
    {validations.map(v => (
      <ValidationItem 
        capability={v.capability}
        passed={v.passed}
        errors={v.errors}
      />
    ))}
  </DebugPanel>
)}
CHECKLIST DE IMPLEMENTAÃ‡ÃƒO
Capability 1: pesquisar_atividades_conta
 ConexÃ£o com Neon configurada

 Query SQL definida e testada

 TransformaÃ§Ã£o de dados DB â†’ IA implementada

 Anti-hallucination measures aplicadas

 Error handling completo

 Logging estruturado

 Testado com professor novo (0 atividades)

 Testado com professor existente (N atividades)

Capability 2: pesquisar_atividades_disponiveis
 Acesso ao JSON implementado

 Schema validation implementada

 Filtros de busca funcionando

 Whitelist enforcement para IA

 Post-LLM validation implementada

 Caching strategy definida

 Testado com catÃ¡logo completo

 Testado com filtros aplicados

Capability 3: decidir_atividades_criar
 Context assembly implementado

 Prompt de decisÃ£o estruturado

 Decision validation robusta

 Retry logic implementada

 State management configurado

 Integration com cap 1 e 2 testada

 Testado com diversos contextos

 Logs de decisÃµes salvos

Capability 4: criar_atividade
 Componente de construÃ§Ã£o localizado

 IntegraÃ§Ã£o visual no card implementada

 SincronizaÃ§Ã£o com cap 3 funcionando

 Progress tracking visÃ­vel

 Database persistence implementada

 Error handling e recovery

 Testado com 1 atividade

 Testado com mÃºltiplas atividades

 Testado com falhas simuladas

IntegraÃ§Ã£o Geral
 Pipeline completo funcionando

 Event system implementado

 Dependencies validadas

 Logging end-to-end

 Debug panel para dev

 Performance aceitÃ¡vel

 Error recovery testado

 DocumentaÃ§Ã£o atualizada

TESTES OBRIGATÃ“RIOS
Teste E2E: Fluxo Completo
text
1. UsuÃ¡rio pede "Criar atividades de MatemÃ¡tica para 7Âº ano"
2. Cap 1 executa â†’ Retorna 3 atividades existentes
3. Cap 2 executa â†’ Retorna 137 do catÃ¡logo
4. Cap 3 executa â†’ Decide criar 4 novas
5. Cap 4 executa â†’ ConstruÃ§Ã£o interface aparece
6. Sistema constrÃ³i 4 atividades automaticamente
7. Salva no banco de dados
8. Mostra sucesso ao usuÃ¡rio

âœ“ Todas etapas completaram
âœ“ Dados sincronizados
âœ“ Sem alucinaÃ§Ãµes
âœ“ Atividades salvas corretamente
Teste Edge Cases
Professor sem nenhuma atividade anterior

CatÃ¡logo de atividades vazio (nÃ£o deveria acontecer)

IA decide mais que limite permitido

IA escolhe ID invÃ¡lido

Falha de conexÃ£o com banco

Timeout na criaÃ§Ã£o

ConstruÃ§Ã£o parcial (algumas falham)

RESULTADO ESPERADO
Quando completo:

Cap 1: Busca precisa no Neon, zero alucinaÃ§Ã£o

Cap 2: Consulta exata ao JSON, IA nÃ£o inventa atividades

Cap 3: DecisÃµes inteligentes e validadas

Cap 4: Interface de construÃ§Ã£o funcional e sincronizada

Pipeline: Fluxo suave de dados entre capabilities

UX: UsuÃ¡rio vÃª construÃ§Ã£o acontecendo em tempo real

PersistÃªncia: Atividades salvas corretamente no banco

MINDSET OBRIGATÃ“RIO
Data Integrity First: Dados reais > Dados inventados

Validation Everywhere: Validar entrada e saÃ­da de tudo

Fail Visibly: Erros devem ser Ã³bvios, nÃ£o silenciosos

Sync is Critical: Capabilities dependem umas das outras

User sees Process: TransparÃªncia da construÃ§Ã£o

ğŸš€ ESTAS SÃƒO AS CAPABILITIES CORE. IMPLEMENTE COM PRECISÃƒO CIRÃšRGICA. DATA FLOW Ã‰ SAGRADO.