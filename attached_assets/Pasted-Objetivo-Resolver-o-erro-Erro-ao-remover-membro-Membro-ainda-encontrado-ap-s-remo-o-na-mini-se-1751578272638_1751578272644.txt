Objetivo: Resolver o erro "Erro ao remover membro: Membro ainda encontrado após remoção." na mini-seção "Membros" ao clicar em "Remover". Garantir que o membro seja removido da tabela membros_grupos no Supabase e a interface seja atualizada instantaneamente, eliminando o erro. Usar retries robustos, validação pós-exclusão e recarga forçada da lista de membros, preservando o design e outras funcionalidades.



Instruções Gerais





Escopo Restrito: Modifique apenas as funções removeMember, loadMembers, e o listener Realtime no arquivo script.js. Não altere o design (HTML, CSS) nem outras partes do código que funcionam.



Preservação do Design: Mantenha o layout e estilos da mini-seção "Membros" intactos.



Funcionalidades de Remoção:





Executar a query de exclusão com 5 retries (500ms intervalo) até sucesso.



Validar pós-exclusão verificando se o membro foi removido do Supabase.



Forçar recarga de loadMembers após exclusão para atualizar a interface.



Remover o mini-card imediatamente e sincronizar via Realtime.



Tratamento de Erros: Logar erros no console, evitar alertas visíveis.



Testes: Realize testes e envie logs.



Passos para a IA Programadora





Acesse o Arquivo: Abra script.js e localize removeMember, loadMembers, e o listener Realtime.



Corrigir removeMember:





Use supabase.from('membros_grupos').delete().eq('grupo_id', groupId).eq('user_id', userId) com 5 retries.



Após sucesso, valide com supabase.from('membros_grupos').select().eq('grupo_id', groupId).eq('user_id', userId); se vazio, confirmar exclusão.



Remover o mini-card (document.querySelector(.member-card[data-user-id="${userId}"])?.remove()) e chamar loadMembers.



Otimizar loadMembers:





Recarregar a lista de membros forçadamente após removeMember.



Ajustar Realtime:





No evento DELETE, remover o mini-card e recarregar loadMembers.



Teste e Valide:





Teste o fluxo (clique em "Remover") e confirme a remoção sem erro.



Envie logs do console.



Modificações no Frontend (JavaScript)

 // Atualizar removeMember para corrigir erro de remoção const removeMember = async (groupId, userId, retries = 5, delay = 500) => { try { for (let attempt = 1; attempt <= retries; attempt++) { try { const { data, error } = await supabase .from('membros_grupos') .delete() .eq('grupo_id', groupId) .eq('user_id', userId); if (error) throw error; console.log(`Membro ${userId} removido do grupo ${groupId} na tentativa ${attempt}.`); 

    // Validação pós-exclusão
    const { data: validation } = await supabase
      .from('membros_grupos')
      .select()
      .eq('grupo_id', groupId)
      .eq('user_id', userId);
    if (validation.length === 0) {
      console.log(`Validação: Membro ${userId} removido com sucesso.`);
      const memberCard = document.querySelector(`.member-card[data-user-id="${userId}"]`);
      if (memberCard) memberCard.remove();
      loadMembers(groupId, userCache, userId, isAdminOrOwner);
      return;
    } else {
      console.warn(`Validação falhou: Membro ${userId} ainda encontrado. Tentando novamente.`);
    }
  } catch (error) {
    console.error(`Tentativa ${attempt} falhou: ${error.message}`);
    if (attempt === retries) {
      const memberCard = document.querySelector(`.member-card[data-user-id="${userId}"]`);
      if (memberCard) memberCard.remove(); // Forçar remoção
      loadMembers(groupId, userCache, userId, isAdminOrOwner); // Recarregar
    }
    await new Promise(resolve => setTimeout(resolve, delay));
  }
}

} catch (error) { console.error(Erro geral ao remover ${userId}: ${error.message}); const memberCard = document.querySelector(.member-card[data-user-id="${userId}"]); if (memberCard) memberCard.remove(); // Forçar remoção loadMembers(groupId, userCache, userId, isAdminOrOwner); // Recarregar } };

// Ajustar loadMembers para recarga forçada const loadMembers = async (groupId, userCache, currentUserId, isAdminOrOwner) => { try { const membersContent = document.getElementById('members-content'); if (!membersContent) { console.error('Seção "Membros" não encontrada.'); return; } membersContent.innerHTML = ''; const { data: members, error } = await supabase .from('membros_grupos') .select('user_id, is_admin, is_owner') .eq('grupo_id', groupId); if (error) throw error; members.forEach(member => { const user = userCache.get(member.user_id) || { name: Usuário ${member.user_id.slice(0, 5)}, avatar_url: null }; const memberCard = document.createElement('div'); memberCard.className = 'member-card'; memberCard.dataset.userId = member.user_id; memberCard.innerHTML = <img src="${user.avatar_url || 'default-avatar.png'}" alt="${user.name}"> <span>${user.name}</span> ${member.user_id === currentUserId ? '' : '<i class="remove-member-icon" data-user-id="' + member.user_id + '"></i>'} ; membersContent.appendChild(memberCard); if (member.user_id !== currentUserId && isAdminOrOwner) { memberCard.querySelector('.remove-member-icon').addEventListener('click', () => showRemoveMemberModal(member.user_id, user.name)); } }); console.log(Membros recarregados para ${groupId} com ${members.length} entradas.); } catch (error) { console.error('Erro ao carregar membros:', error.message); } };

// Ajustar Realtime para sincronização const channel = supabase .channel(members-${groupId}) .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'membros_grupos', filter: grupo_id=eq.${groupId} }, (payload) => { if (payload.old.user_id) { const memberCard = document.querySelector(.member-card[data-user-id="${payload.old.user_id}"]); if (memberCard) memberCard.remove(); loadMembers(groupId, userCache, userId, isAdminOrOwner); console.log(Membro ${payload.old.user_id} removido via Realtime.); } }) .subscribe(status => console.log(Subscribed to members-${groupId}: ${status}));