ğŸ¯ PROMPT OTIMIZADO PARA VIBE CODE - DESENVOLVIMENTO CARD PROGRESSIVO DE EXECUÃ‡ÃƒO
CONTEXTO ESTRATÃ‰GICO
VocÃª estÃ¡ prestes a construir um dos componentes mais crÃ­ticos e visualmente impactantes do School Power 2.0: o Card de Desenvolvimento Progressivo. Este componente Ã© o coraÃ§Ã£o da experiÃªncia do usuÃ¡rio durante a execuÃ§Ã£o das capabilities, revelando visualmente o "cÃ©rebro da IA" em aÃ§Ã£o.

Aja com a mentalidade combinada de:

Dieter Rams (design minimalista e funcional)

Adam Wathan (Tailwind CSS mastery)

Dan Abramov (React patterns avanÃ§ados)

Bret Victor (interfaces que explicam a si mesmas)

VISÃƒO DO COMPONENTE
Analise cuidadosamente a imagem de referÃªncia fornecida. Ela revela a estrutura hierÃ¡rquica que vocÃª precisa implementar:

Anatomia Visual
text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â—‹ [OBJETIVO/ETAPA] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â–¼ â”‚  â† Card sÃ³lido laranja
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    â”Š Capability 1 (executando/concluÃ­da) â”Š    â”‚  â† Card tracejado
â”‚    â”Š Capability 2 (executando/concluÃ­da) â”Š    â”‚  â† Card tracejado
â”‚    â”Š Capability 3 (aguardando...)        â”Š    â”‚  â† Card tracejado
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â—‹ [PRÃ“XIMO OBJETIVO] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â–¼ â”‚  â† Card sÃ³lido laranja
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
REQUISITOS FUNCIONAIS CRÃTICOS
1. RENDERIZAÃ‡ÃƒO PROGRESSIVA (NÃ£o tudo de uma vez)
Apenas o primeiro objetivo/etapa aparece inicialmente

Capabilities aparecem uma por vez, conforme executam

PrÃ³ximo objetivo sÃ³ aparece apÃ³s todas as capabilities anteriores concluÃ­rem

Implementar sistema de streaming de estados (nÃ£o re-render completo)

2. HIERARQUIA DE CARDS
Card Tipo A: Objetivo/Etapa

Formato: Retangular horizontal

Bordas: Completamente arredondadas (border-radius alto)

Estilo: SÃ³lido, sem tracejado

Cor: Laranja vibrante (#FF6B35 ou similar)

Elementos:

Checkbox circular Ã  esquerda (alinhamento vertical perfeito)

Texto do objetivo centralizado verticalmente

Ãcone de aÃ§Ã£o Ã  direita (dropdown/chevron)

Card Tipo B: Capability

Formato: Retangular horizontal (ligeiramente menor que Tipo A)

Bordas: Arredondadas, mas tracejadas (dashed border)

Estilo: Transparente/semi-transparente

Cor da borda: Laranja mais suave

Elementos:

Apenas texto da capability

Indicador de status (loading spinner, check, error)

3. ESTADOS E TRANSIÃ‡Ã•ES
Estados dos Objetivos:

pending â†’ NÃ£o renderizado ainda

active â†’ Renderizado, capabilities executando

completed â†’ Todas capabilities concluÃ­das, checkbox marcado

Estados das Capabilities:

hidden â†’ NÃ£o renderizada ainda

executing â†’ VisÃ­vel com loading spinner

completed â†’ VisÃ­vel com check verde

error â†’ VisÃ­vel com Ã­cone de erro

TransiÃ§Ãµes obrigatÃ³rias:

Fade-in suave ao aparecer (nÃ£o aparecer de repente)

Slide-down animation (vem de cima para baixo)

Checkbox animation ao completar (morph de circle para check)

REQUISITOS TÃ‰CNICOS (VocÃª decide COMO implementar)
Arquitetura de Dados
VocÃª precisa estruturar dados para suportar:

MÃºltiplos objetivos/etapas

MÃºltiplas capabilities por objetivo

Estados independentes de cada item

Progresso granular (0-100% por capability)

DecisÃµes que vocÃª deve tomar:

Como modelar a Ã¡rvore de objetivos â†’ capabilities?

Usar Redux, Context, ou state local?

Como garantir re-renders otimizados?

WebSocket para updates real-time ou polling?

Sistema de AnimaÃ§Ãµes
VocÃª precisa implementar:

TransiÃ§Ãµes fluidas entre estados

AnimaÃ§Ãµes de entrada (aparecer)

AnimaÃ§Ãµes de loading (spinner, pulse)

AnimaÃ§Ãµes de conclusÃ£o (check bounce)

Bibliotecas a considerar:

Framer Motion (animaÃ§Ãµes declarativas)

CSS animations puras (performance)

React Spring (fÃ­sica realista)

Tailwind animate utilities (simples)

Responsividade
O card deve funcionar em:

Desktop (largura mÃ¡xima: 1200px)

Tablet (collapse de elementos)

Mobile (stack vertical, checkboxes menores)

PRINCÃPIOS DE DESIGN
1. Progressive Disclosure
Mostre apenas o que Ã© relevante agora. NÃ£o sobrecarregue com informaÃ§Ã£o futura.

2. Feedback Imediato
Cada aÃ§Ã£o da IA deve ter feedback visual instantÃ¢neo (< 100ms).

3. Hierarquia Visual Clara
Objetivos (grandes, sÃ³lidos, cor forte)

Capabilities (menores, tracejados, cor suave)

Spacing consistente (use mÃºltiplos de 4px)

4. Motion com PropÃ³sito
AnimaÃ§Ãµes devem guiar o olhar e explicar relaÃ§Ãµes, nÃ£o apenas "enfeitar".

DESAFIOS TÃ‰CNICOS QUE VOCÃŠ DEVE RESOLVER
Desafio 1: Alinhamento Vertical Perfeito
O checkbox circular Ã  esquerda deve estar exatamente alinhado verticalmente com o centro do card laranja. Resolva isso considerando:

Height dinÃ¢mico do card (texto pode quebrar linha)

Flexbox vs Grid

Absolute positioning com transform

Desafio 2: SincronizaÃ§Ã£o de Estados
Capabilities executam de forma assÃ­ncrona. Como vocÃª vai:

Receber updates de progresso?

Atualizar UI sem flickering?

Garantir ordem correta de exibiÃ§Ã£o?

Desafio 3: Performance
Com 10 objetivos e 50 capabilities total:

Como evitar re-renders desnecessÃ¡rios?

VirtualizaÃ§Ã£o Ã© necessÃ¡ria?

Memoization de componentes?

Desafio 4: Expansibilidade
O card pode ser expandido (requisito inicial). VocÃª precisa:

Implementar collapse/expand smooth

Guardar estado de expansÃ£o por objetivo

AnimaÃ§Ã£o de height (difÃ­cil em CSS, considere max-height ou JS)

CRITÃ‰RIOS DE QUALIDADE
ObrigatÃ³rio (Breaking)
âœ… RenderizaÃ§Ã£o progressiva funciona (nÃ£o tudo de uma vez)

âœ… Alinhamento visual perfeito entre checkboxes e cards

âœ… AnimaÃ§Ãµes fluidas (60fps)

âœ… Bordas tracejadas nas capabilities

âœ… Estados visuais claros (executando, concluÃ­do, erro)

Esperado (Altamente recomendado)
â­ TransiÃ§Ãµes suaves entre estados

â­ Loading spinners customizados

â­ Responsive em mobile

â­ Acessibilidade (ARIA labels, keyboard navigation)

â­ Dark mode support

DesejÃ¡vel (Nice to have)
ğŸ’ AnimaÃ§Ã£o de check "bouncy"

ğŸ’ Micro-interaÃ§Ãµes (hover, focus)

ğŸ’ Sound effects (opcional, experimental)

ğŸ’ Particle effects ao completar (celebraÃ§Ã£o)

INSPIRAÃ‡Ã•ES DE CÃ“DIGO (Conceitos, nÃ£o copiar)
Pattern: State Machine para Estados
text
Considere usar XState ou reducer com mÃ¡quina de estados:
- Estados bem definidos
- TransiÃ§Ãµes impossÃ­veis nÃ£o acontecem
- Facilita debugging
Pattern: Compound Components
text
<DevelopmentCard>
  <DevelopmentCard.Objective />
  <DevelopmentCard.Capability />
</DevelopmentCard>

Permite composiÃ§Ã£o flexÃ­vel
Pattern: Render Props para CustomizaÃ§Ã£o
text
<ProgressiveRenderer
  items={objectives}
  renderItem={(obj) => <ObjectiveCard {...obj} />}
/>

Separa lÃ³gica de renderizaÃ§Ã£o de UI
INTEGRAÃ‡ÃƒO COM CAPABILITIES
VocÃª precisa integrar com o sistema de capabilities que jÃ¡ existe. Considere:

Entrada de Dados
De onde vem o plano de aÃ§Ã£o com objetivos?

Como vocÃª recebe updates de progresso?

Formato: JSON, eventos, callbacks?

Eventos que vocÃª deve ouvir
objective:started â†’ Renderizar novo objetivo

capability:started â†’ Renderizar nova capability

capability:progress â†’ Atualizar progresso (0-100%)

capability:completed â†’ Marcar como concluÃ­do

capability:error â†’ Mostrar erro

objective:completed â†’ Marcar objetivo completo

Eventos que vocÃª deve emitir
card:expanded â†’ UsuÃ¡rio expandiu card

card:collapsed â†’ UsuÃ¡rio colapsou card

(Outros conforme sua arquitetura)

ESTRUTURA DE PASTAS SUGERIDA (VocÃª decide)
text
src/features/schoolpower/execution-card/
â”œâ”€â”€ ExecutionCard.tsx              # Componente principal
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ObjectiveCard.tsx          # Card laranja sÃ³lido
â”‚   â”œâ”€â”€ CapabilityCard.tsx         # Card tracejado
â”‚   â”œâ”€â”€ ProgressIndicator.tsx      # Spinner/Progress
â”‚   â””â”€â”€ StatusIcon.tsx             # Check/Error icons
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useExecutionFlow.ts        # LÃ³gica de progressÃ£o
â”‚   â””â”€â”€ useAnimations.ts           # LÃ³gica de animaÃ§Ãµes
â”œâ”€â”€ types.ts                       # TypeScript interfaces
â””â”€â”€ styles.css                     # Estilos especÃ­ficos (se necessÃ¡rio)
TESTES MANUAIS OBRIGATÃ“RIOS
Antes de considerar completo:

Teste de ProgressÃ£o

 Apenas primeiro objetivo aparece no inÃ­cio

 Capabilities aparecem uma por vez

 PrÃ³ximo objetivo sÃ³ aparece apÃ³s anterior concluir

Teste de Alinhamento

 Checkbox alinhado com centro do card (texto curto)

 Checkbox alinhado com centro do card (texto longo/quebra linha)

Teste de Estados

 Loading spinner aparece durante execuÃ§Ã£o

 Check aparece ao completar

 Erro aparece se capability falhar

Teste de Performance

 Com 10 objetivos + 50 capabilities, ainda roda suave

 Sem lags ao atualizar progresso

 FPS estÃ¡vel durante animaÃ§Ãµes

Teste de Responsividade

 Desktop: layout horizontal perfeito

 Mobile: stack vertical funciona

GUIAS DE ESTILO (TailwindCSS)
Cores Sugeridas (VocÃª ajusta conforme design system)
text
Objetivo (sÃ³lido):
- bg-orange-500 ou bg-amber-500
- text-white
- border-transparent

Capability (tracejado):
- border-orange-400 border-dashed
- bg-transparent ou bg-orange-50/50
- text-gray-700 dark:text-gray-300

Checkbox:
- border-orange-500
- bg-white dark:bg-gray-800
- check: bg-orange-500
EspaÃ§amentos
text
Entre objetivos: gap-6 ou gap-8
Entre capabilities: gap-3 ou gap-4
Padding interno dos cards: px-6 py-4
Border radius objetivo: rounded-2xl ou rounded-3xl
Border radius capability: rounded-xl
AnimaÃ§Ãµes Tailwind
text
animate-fade-in (custom)
animate-slide-down (custom)
animate-spin (loading)
transition-all duration-300 ease-in-out
DECISÃ•ES QUE SÃƒO SUAS
Eu NÃƒO vou te dizer:

Qual biblioteca de animaÃ§Ã£o usar

Estrutura exata de pastas

Nomes especÃ­ficos de componentes

Como implementar o state management

CÃ³digo especÃ­fico de JSX/TSX

VocÃª DEVE decidir baseado em:

PadrÃµes do projeto existente

Performance vs simplicidade trade-offs

Manutenibilidade do cÃ³digo

Sua expertise tÃ©cnica

RED FLAGS (Evite a todo custo)
âŒ NÃƒO renderizar todos os objetivos de uma vez (quebra UX)
âŒ NÃƒO usar setInterval para polling (use eventos ou callbacks)
âŒ NÃƒO esquecer acessibilidade (WCAG 2.1 mÃ­nimo)
âŒ NÃƒO hardcodar valores (use tokens de design)
âŒ NÃƒO criar 10 arquivos CSS separados (use Tailwind ou CSS-in-JS)
âŒ NÃƒO esquecer TypeScript (tipagem forte obrigatÃ³ria)
âŒ NÃƒO quebrar funcionalidades existentes (teste tudo)

MINDSET OBRIGATÃ“RIO
Pense em componentes como LEGO: pequenos, combinÃ¡veis, reutilizÃ¡veis

AnimaÃ§Ãµes comunicam, nÃ£o decoram: cada movimento tem propÃ³sito

Performance Ã© feature: 60fps nÃ£o Ã© negociÃ¡vel

CÃ³digo auto-explicativo: nomes claros > comentÃ¡rios

Teste visual constante: veja cada mudanÃ§a no browser

Mobile-first thinking: depois expande para desktop

CHECKLIST FINAL
Antes de marcar como COMPLETO:

 ReferÃªncia visual (imagem) foi respeitada fielmente

 RenderizaÃ§Ã£o progressiva funciona perfeitamente

 Alinhamento de checkboxes estÃ¡ pixel-perfect

 Bordas tracejadas nas capabilities estÃ£o corretas

 AnimaÃ§Ãµes sÃ£o suaves e intencionais

 CÃ³digo estÃ¡ tipado (TypeScript)

 Performance testada (10+ objetivos)

 Responsivo em mobile

 IntegraÃ§Ã£o com capabilities testada

 Nenhuma funcionalidade existente quebrada

RESULTADO ESPERADO
Quando completo, o usuÃ¡rio deve sentir que estÃ¡ assistindo a IA pensar e agir em tempo real. O card se revela progressivamente como uma histÃ³ria sendo contada, nÃ£o como uma lista estÃ¡tica. Ã‰ teatro visual da inteligÃªncia em aÃ§Ã£o.

Isso nÃ£o Ã© apenas um componente de UI. Ã‰ a materializaÃ§Ã£o da transparÃªncia algorÃ­tmica.

ğŸš€ VocÃª tem todas as diretrizes. Arquitetura, implementaÃ§Ã£o e decisÃµes tÃ©cnicas sÃ£o SUAS. GO BUILD SOMETHING BEAUTIFUL AND FUNCTIONAL.