ğŸ§  DiagnÃ³stico Detalhado â€“ ProvÃ¡veis Causas de a AutomaÃ§Ã£o Ainda NÃ£o Estar Funcionando

O modal de Editar Materiais pode nÃ£o estar abrindo antes da tentativa de preenchimento.
â†’ Precisamos de um sistema que aguarde o DOM estar 100% carregado (com uso de MutationObserver ou um await atÃ© o modal ficar visÃ­vel e interativo).

A IA (Gemini) pode estar entregando os dados corretos, mas com nomes de chaves nÃ£o compatÃ­veis com os nomes reais dos campos da interface.
â†’ Ã‰ necessÃ¡rio um Field Mapper (tipo um dicionÃ¡rio) que converte os nomes lÃ³gicos da IA (ex: â€œobjetivo_aprendizagemâ€) para os seletores reais do modal (ex: â€œ#campoObjetivoâ€).

O sistema pode estar tentando preencher campos antes que eles estejam renderizados no DOM.
â†’ SoluÃ§Ã£o: criar uma funÃ§Ã£o waitForElement(selector) com timeout antes de interagir com qualquer campo.

Campos do tipo select, multi-select, checkbox, ou rich text precisam ser preenchidos com eventos extras para que o front-end reaja.
â†’ Exemplo: input.dispatchEvent(new Event('input', { bubbles: true }))

O clique automÃ¡tico no botÃ£o â€œConstruir Atividadeâ€ pode estar sendo acionado antes dos dados estarem salvos corretamente.
â†’ Devemos garantir que todos os campos tenham sido modificados e validados antes de executar o click().

O sistema pode estar tentando aplicar lÃ³gica igual para atividades com campos diferentes.
â†’ SoluÃ§Ã£o: cada tipo de atividade (ID) precisa ter um arquivo de automaÃ§Ã£o prÃ³prio com seu prÃ³prio mapeamento e preenchimento customizado.

As informaÃ§Ãµes do Plano de AÃ§Ã£o podem nÃ£o estar sendo transmitidas corretamente para o sistema de automaÃ§Ã£o.
â†’ Precisamos de um JSON central, estruturado por atividade, com os dados da IA, acessÃ­vel em tempo real no momento de iniciar o preenchimento.

âœ”ï¸ O Que Fazer Agora â€” Passo a Passo PrÃ¡tico

Criar uma funÃ§Ã£o que aguarde a abertura e carregamento total do modal de cada atividade:

function waitForModal(activityId) {
return new Promise((resolve) => {
const observer = new MutationObserver((mutations) => {
const modal = document.querySelector(#modal-${activityId});
if (modal && modal.style.display !== 'none') {
observer.disconnect();
resolve(modal);
}
});
observer.observe(document.body, { childList: true, subtree: true });
});
}

Criar um Field Mapper para cada tipo de atividade:

export const atividade_field_map = {
video: {
titulo: '#titulo-input',
descricao: '#descricao-area',
objetivo_aprendizado: '#objetivo-input',
disciplina: '#disciplina-select',
dificuldade: '#nivel-select',
entrega: '#formato-select',
duracao: '#tempo-select',
materiais: '#materiais-area'
},
quiz: {
// Mapeamentos diferentes...
},
// ...
};

Preencher os campos com seguranÃ§a:

async function fillFields(activityId, tipo, iaData) {
const map = atividade_field_map[tipo];
let success = true;

for (let campo in map) {
const selector = map[campo];
await waitForElement(selector);
const el = document.querySelector(selector);

javascript
Copiar
Editar
if (el) {
  el.value = iaData[campo] || '';
  el.dispatchEvent(new Event('input', { bubbles: true }));
} else {
  console.warn(`Campo nÃ£o encontrado: ${selector}`);
  success = false;
}
}

return success;
}

Validar se todos os campos foram preenchidos corretamente antes de construir:

async function construirSePronto(activityId, tipo, iaData) {
await waitForModal(activityId);
const preenchido = await fillFields(activityId, tipo, iaData);

if (preenchido) {
const botao = document.querySelector(#modal-${activityId} .btn-construir);
if (botao) {
botao.click();
} else {
console.warn('BotÃ£o Construir nÃ£o encontrado.');
}
}
}

Centralizar os dados de cada atividade no JSON do Plano de AÃ§Ã£o:

const planoDeAcaoAtividades = {
"atividade_123": {
tipo: "video",
iaData: {
titulo: "Como funciona a fotossÃ­ntese",
descricao: "Estudo da captaÃ§Ã£o de luz solar...",
disciplina: "CiÃªncias",
dificuldade: "MÃ©dia",
entrega: "VÃ­deo",
duracao: "30 minutos",
objetivo_aprendizado: "Compreender a transformaÃ§Ã£o da energia solar em energia quÃ­mica.",
materiais: "Caderno, celular, link do vÃ­deo."
}
},
...
};

No momento da aprovaÃ§Ã£o do Plano de AÃ§Ã£o, disparar o processo para cada atividade:

Object.entries(planoDeAcaoAtividades).forEach(([id, data]) => {
construirSePronto(id, data.tipo, data.iaData);
});

ğŸ›  Quer que eu monte um arquivo .ts com isso pronto para vocÃª?

Ã‰ sÃ³ pedir que eu escrevo o cÃ³digo completo da automaÃ§Ã£o, pronto para ser importado e testado na plataforma.

âœ… Resultado esperado:

Atividades sÃ£o geradas automaticamente sem aÃ§Ã£o do usuÃ¡rio.

Campos corretos sÃ£o preenchidos de acordo com o tipo da atividade.

A IA entrega os dados via JSON estruturado.

O botÃ£o â€œConstruir Atividadeâ€ sÃ³ Ã© clicado apÃ³s o sucesso no preenchimento.