[plugin:vite:react-swc] Ã— the name `conversationHistory` is defined multiple times
      â•­â”€[/home/runner/workspace/src/services/aiChatService.ts:16:1]
   16 â”‚ }
   17 â”‚ 
   18 â”‚ // HistÃ³rico de conversas
   19 â”‚ let conversationHistory: Record<string, ChatMessage[]> = {};
      Â·     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Â·              â•°â”€â”€ previous definition of `conversationHistory` here
   20 â”‚ 
   21 â”‚ // Inicializar o histÃ³rico do localStorage quando o mÃ³dulo carrega
   22 â”‚ try {
   23 â”‚   const savedSessions = localStorage.getItem('aiChatSessions');
   24 â”‚   if (savedSessions) {
   25 â”‚     const parsedSessions = JSON.parse(savedSessions);
   26 â”‚     // Verificar se Ã© um objeto vÃ¡lido
   27 â”‚     if (parsedSessions && typeof parsedSessions === 'object') {
   28 â”‚       // Para cada sessÃ£o, converter as datas de string para Date
   29 â”‚       Object.keys(parsedSessions).forEach(sessionId => {
   30 â”‚         if (Array.isArray(parsedSessions[sessionId])) {
   31 â”‚           conversationHistory[sessionId] = parsedSessions[sessionId].map(msg => ({
   32 â”‚             ...msg,
   33 â”‚             timestamp: msg.timestamp ? new Date(msg.timestamp) : new Date()
   34 â”‚           }));
   35 â”‚         }
   36 â”‚       });
   37 â”‚       console.log(`Carregadas ${Object.keys(conversationHistory).length} sessÃµes de chat do localStorage`);
   38 â”‚     }
   39 â”‚   }
   40 â”‚ } catch (error) {
   41 â”‚   console.error('Erro ao carregar histÃ³rico de conversas do localStorage:', error);
   42 â”‚ }
   43 â”‚ 
   44 â”‚ // FunÃ§Ã£o para obter dados do usuÃ¡rio atual com acesso expandido e completo
   45 â”‚ async function getUserContext() {
   46 â”‚   try {
   47 â”‚     // Obter dados do localStorage e sessionStorage
   48 â”‚     const usernameSources = {
   49 â”‚       localStorage: localStorage.getItem('username'),
   50 â”‚       sessionStorage: sessionStorage.getItem('username'),
   51 â”‚       profile: null,
   52 â”‚       metadata: null,
   53 â”‚       email: localStorage.getItem('userEmail') || sessionStorage.getItem('userEmail')
   54 â”‚     };
   55 â”‚ 
   56 â”‚     // Importar serviÃ§os e utilitÃ¡rios necessÃ¡rios
   57 â”‚     let profileService;
   58 â”‚     let supabase;
   59 â”‚     let completeUserProfile = null;
   60 â”‚     let userClasses = [];
   61 â”‚     let userSeries = [];
   62 â”‚     let followersCount = 0;
   63 â”‚ 
   64 â”‚     try {
   65 â”‚       // Importar o serviÃ§o de perfil e o cliente Supabase
   66 â”‚       profileService = (await import('@/services/profileService')).profileService;
   67 â”‚       supabase = (await import('@/lib/supabase')).supabase;
   68 â”‚ 
   69 â”‚       // Obter perfil completo do usuÃ¡rio com todos os detalhes
   70 â”‚       completeUserProfile = await profileService.getCurrentUserProfile();
   71 â”‚ 
   72 â”‚       // Obter session para determinar o ID do usuÃ¡rio atual
   73 â”‚       const { data: sessionData } = await supabase.auth.getSession();
   74 â”‚       const currentUserId = sessionData?.session?.user?.id;
   75 â”‚ 
   76 â”‚       if (currentUserId && completeUserProfile) {
   77 â”‚         // Obter turmas do usuÃ¡rio
   78 â”‚         const { data: classesData } = await supabase
   79 â”‚           .from('user_classes')
   80 â”‚           .select('*, class:classes(*)')
   81 â”‚           .eq('user_id', currentUserId);
   82 â”‚ 
   83 â”‚         if (classesData) {
   84 â”‚           userClasses = classesData;
   85 â”‚         }
   86 â”‚ 
   87 â”‚         // Obter sÃ©ries do usuÃ¡rio
   88 â”‚         const { data: seriesData } = await supabase
   89 â”‚           .from('user_series')
   90 â”‚           .select('*, serie:series(*)')
   91 â”‚           .eq('user_id', currentUserId);
   92 â”‚ 
   93 â”‚         if (seriesData) {
   94 â”‚           userSeries = seriesData;
   95 â”‚         }
   96 â”‚ 
   97 â”‚         // Obter contagem de seguidores
   98 â”‚         const { count } = await supabase
   99 â”‚           .from('user_followers')
  100 â”‚           .select('*', { count: 'exact' })
  101 â”‚           .eq('followed_id', currentUserId);
  102 â”‚ 
  103 â”‚         if (count !== null) {
  104 â”‚           followersCount = count;
  105 â”‚         }
  106 â”‚       }
  107 â”‚     } catch (error) {
  108 â”‚       console.error('Erro ao obter dados completos do perfil:', error);
  109 â”‚     }
  110 â”‚ 
  111 â”‚     // Tentar obter dados expandidos do perfil via username-utils (fallback)
  112 â”‚     let basicProfileData = {};
  113 â”‚     let metadataUsername = null;
  114 â”‚ 
  115 â”‚     try {
  116 â”‚       const usernameUtils = await import('@/lib/username-utils');
  117 â”‚       if (usernameUtils && usernameUtils.getUserProfile) {
  118 â”‚         basicProfileData = await usernameUtils.getUserProfile();
  119 â”‚ 
  120 â”‚         if (usernameUtils.getCurrentUsername) {
  121 â”‚           metadataUsername = await usernameUtils.getCurrentUsername();
  122 â”‚           usernameSources.metadata = metadataUsername;
  123 â”‚         }
  124 â”‚ 
  125 â”‚         if (basicProfileData && basicProfileData.username) {
  126 â”‚           usernameSources.profile = basicProfileData.username;
  127 â”‚         }
  128 â”‚       }
  129 â”‚     } catch (error) {
  130 â”‚       console.log('Erro ao obter perfil via username-utils:', error);
  131 â”‚     }
  132 â”‚ 
  133 â”‚     // Determinar o melhor username para usar (prioridade: perfil completo > metadata > localStorage > sessionStorage)
  134 â”‚     const bestUsername = 
  135 â”‚       (completeUserProfile?.username || completeUserProfile?.display_name) || 
  136 â”‚       metadataUsername || 
  137 â”‚       usernameSources.localStorage || 
  138 â”‚       usernameSources.sessionStorage || 
  139 â”‚       usernameSources.profile || 
  140 â”‚       'UsuÃ¡rio';
  141 â”‚ 
  142 â”‚     // Construir contexto completo do usuÃ¡rio
  143 â”‚     const userContext = {
  144 â”‚       // Dados bÃ¡sicos
  145 â”‚       username: bestUsername,
  146 â”‚       email: completeUserProfile?.email || usernameSources.email || 'email@exemplo.com',
  147 â”‚ 
  148 â”‚       // Dados completos do perfil
  149 â”‚       profile: completeUserProfile || basicProfileData,
  150 â”‚ 
  151 â”‚       // Dados especÃ­ficos para fÃ¡cil acesso
  152 â”‚       userId: completeUserProfile?.user_id || 'ID nÃ£o disponÃ­vel',
  153 â”‚       fullName: completeUserProfile?.full_name || 'Nome nÃ£o disponÃ­vel',
  154 â”‚       displayName: completeUserProfile?.display_name || bestUsername,
  155 â”‚       createdAt: completeUserProfile?.created_at || 'Data nÃ£o disponÃ­vel',
  156 â”‚       planType: completeUserProfile?.plan_type || 'lite',
  157 â”‚       userLevel: completeUserProfile?.level || 1,
  158 â”‚       followersCount: followersCount,
  159 â”‚ 
  160 â”‚       // Dados de contexto de uso
  161 â”‚       currentPage: window.location.pathname,
  162 â”‚       lastActivity: localStorage.getItem('lastActivity') || 'Nenhuma atividade recente',
  163 â”‚ 
  164 â”‚       // Dados das turmas e sÃ©ries
  165 â”‚       classes: userClasses,
  166 â”‚       series: userSeries,
  167 â”‚ 
  168 â”‚       // Dados do dispositivo e ambiente
  169 â”‚       userAgent: navigator.userAgent,
  170 â”‚       platform: navigator.platform,
  171 â”‚       screenSize: `${window.innerWidth}x${window.innerHeight}`,
  172 â”‚       darkMode: window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches,
  173 â”‚ 
  174 â”‚       // Dados do localStorage
  175 â”‚       localStorageData: Object.keys(localStorage).filter(key => 
  176 â”‚         key.startsWith('user_') || 
  177 â”‚         key.startsWith('ponto_') || 
  178 â”‚         key.startsWith('study_')
  179 â”‚       ).reduce((acc, key) => {
  180 â”‚         acc[key] = localStorage.getItem(key);
  181 â”‚         return acc;
  182 â”‚       }, {})
  183 â”‚     };
  184 â”‚ 
  185 â”‚     // Obter atividades recentes
  186 â”‚     try {
  187 â”‚       const recentActivities = JSON.parse(localStorage.getItem('user_recent_activities') || '[]');
  188 â”‚       if (Array.isArray(recentActivities) && recentActivities.length > 0) {
  189 â”‚         userContext.recentActivities = recentActivities;
  190 â”‚       }
  191 â”‚     } catch (e) {
  192 â”‚       console.log('Erro ao obter atividades recentes:', e);
  193 â”‚     }
  194 â”‚ 
  195 â”‚     return userContext;
  196 â”‚   } catch (error) {
  197 â”‚     console.error('Erro ao obter contexto do usuÃ¡rio:', error);
  198 â”‚     return { username: 'UsuÃ¡rio' };
  199 â”‚   }
  200 â”‚ }
  201 â”‚ 
  202 â”‚ 
  203 â”‚ // FunÃ§Ã£o para gerar resposta usando a API xAI
  204 â”‚ export async function generateXAIResponse(
  205 â”‚   message: string, 
  206 â”‚   sessionId: string,
  207 â”‚   options?: { 
  208 â”‚     intelligenceLevel?: 'basic' | 'normal' | 'advanced',
  209 â”‚     languageStyle?: 'casual' | 'formal' | 'technical'
  210 â”‚   }
  211 â”‚ ): Promise<string> {
  212 â”‚   try {
  213 â”‚     // Verificar se a mensagem contÃ©m comando para acessar ou modificar o perfil
  214 â”‚     const isProfileInfoRequest = /qual (Ã©|e) (o )?meu (ID|id)|me (mostre|mostra|diga|informe) (o )?meu (ID|id)|informaÃ§Ãµes da minha conta|dados da minha conta|meu perfil completo/i.test(message);
  215 â”‚     const isProfileUpdateRequest = /atualiz(e|ar) (minha|a) (bio|biografia)|mudar (minha|a) (bio|biografia)|modificar (minha|a) bio|mudar (meu|o) nome de exibiÃ§Ã£o|atualizar (meu|o) nome de exibiÃ§Ã£o|mudar (meu|o) telefone/i.test(message);
  216 â”‚     const isRedirectRequest = /(me\s+(redirecione|encaminhe|leve|direcione|mande|envie)\s+(para|ao|Ã |a|atÃ©)|quero\s+(ir|acessar|entrar|ver)|me\s+(mostre|mostra)|abrir?|abra|acesse|acessar|ver|veja)\s+(a\s+)?(pÃ¡gina\s+(de|do|da)\s+)?([a-zÃ -Ãº\s]+)/i.test(message);
  217 â”‚ 
  218 â”‚     // Importar o serviÃ§o de modificaÃ§Ã£o de perfil se necessÃ¡rio
  219 â”‚     let ProfileModificationService;
  220 â”‚     if (isProfileInfoRequest || isProfileUpdateRequest) {
  221 â”‚       try {
  222 â”‚         ProfileModificationService = (await import('./profileModificationService')).ProfileModificationService;
  223 â”‚       } catch (e) {
  224 â”‚         console.error('Erro ao importar ProfileModificationService:', e);
  225 â”‚       }
  226 â”‚     }
  227 â”‚ 
  228 â”‚     // Obter contexto do usuÃ¡rio - fazer isso logo no inÃ­cio
  229 â”‚     const userContext = await getUserContext();
  230 â”‚ 
  231 â”‚     // Extrair o primeiro nome do usuÃ¡rio para uso personalizado nas respostas
  232 â”‚     const firstName = userContext.fullName ? 
  233 â”‚       userContext.fullName.split(' ')[0] : 
  234 â”‚       (userContext.displayName || userContext.username || 'UsuÃ¡rio');
  235 â”‚ 
  236 â”‚     // Inicializar o histÃ³rico se nÃ£o existir
  237 â”‚     if (!conversationHistory[sessionId]) {
  238 â”‚       initializeConversationHistory(sessionId, userContext);
  239 â”‚     }
  240 â”‚ 
  241 â”‚     // Adiciona a mensagem do usuÃ¡rio ao histÃ³rico
  242 â”‚     conversationHistory[sessionId].push({ 
  243 â”‚       role: 'user', 
  244 â”‚       content: message,
  245 â”‚       timestamp: new Date() 
  246 â”‚     });
  247 â”‚ 
  248 â”‚     // Processar solicitaÃ§Ã£o de informaÃ§Ãµes do perfil
  249 â”‚     if (isProfileInfoRequest && ProfileModificationService) {
  250 â”‚       try {
  251 â”‚         const { profile, formattedInfo } = await ProfileModificationService.getDetailedUserProfile();
  252 â”‚ 
  253 â”‚         // Se conseguiu obter as informaÃ§Ãµes, criar uma resposta personalizada
  254 â”‚         if (profile) {
  255 â”‚           // Criar resposta amigÃ¡vel com as informaÃ§Ãµes
  256 â”‚           const response = `Claro, ${firstName}! Aqui estÃ£o as informaÃ§Ãµes da sua conta:
  257 â”‚ 
  258 â”‚ ${formattedInfo}
  259 â”‚ 
  260 â”‚ VocÃª pode visualizar e editar seu perfil completo acessando [sua pÃ¡gina de perfil](https://pontoschool.com/profile).
  261 â”‚ 
  262 â”‚ Posso te ajudar a atualizar algumas dessas informaÃ§Ãµes diretamente por aqui, como sua biografia ou nome de exibiÃ§Ã£o. Ã‰ sÃ³ me pedir!`;
  263 â”‚ 
  264 â”‚           // Adicionar a resposta ao histÃ³rico
  265 â”‚           conversationHistory[sessionId].push({ 
  266 â”‚             role: 'assistant', 
  267 â”‚             content: response,
  268 â”‚             timestamp: new Date()
  269 â”‚           });
  270 â”‚ 
  271 â”‚           await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  272 â”‚           return response;
  273 â”‚         }
  274 â”‚       } catch (e) {
  275 â”‚         console.error('Erro ao processar solicitaÃ§Ã£o de informaÃ§Ãµes do perfil:', e);
  276 â”‚       }
  277 â”‚     }
  278 â”‚ 
  279 â”‚     // Processar solicitaÃ§Ã£o de atualizaÃ§Ã£o de perfil
  280 â”‚     if (isProfileUpdateRequest && ProfileModificationService) {
  281 â”‚       // Reconhecer o tipo de atualizaÃ§Ã£o solicitada
  282 â”‚       const isBioUpdate = /atualiz(e|ar) (minha|a) (bio|biografia)|mudar (minha|a) (bio|biografia)|modificar (minha|a) bio/i.test(message);
  283 â”‚       const isDisplayNameUpdate = /mudar (meu|o) nome de exibiÃ§Ã£o|atualizar (meu|o) nome de exibiÃ§Ã£o/i.test(message);
  284 â”‚       const isContactInfoUpdate = /mudar (meu|o) telefone|atualizar (meu|o) telefone|mudar (minha|a) localizaÃ§Ã£o|atualizar (minha|a) localizaÃ§Ã£o/i.test(message);
  285 â”‚ 
  286 â”‚       // Extrair o conteÃºdo a ser atualizado
  287 â”‚       try {
  288 â”‚         // Determinar qual atualizaÃ§Ã£o fazer e responder apropriadamente
  289 â”‚         let response = '';
  290 â”‚ 
  291 â”‚         if (isBioUpdate) {
  292 â”‚           // Extrair a nova biografia da mensagem
  293 â”‚           const bioRegex = /(?:para|como|com) ["|'|"](.+?)["|'|"]/i;
  294 â”‚           const bioMatch = message.match(bioRegex);
  295 â”‚ 
  296 â”‚           if (bioMatch && bioMatch[1]) {
  297 â”‚             const newBio = bioMatch[1].trim();
  298 â”‚             const result = await ProfileModificationService.updateUserBio(newBio);
  299 â”‚ 
  300 â”‚             if (result.success) {
  301 â”‚               response = `Ã“timo, ${firstName}! Sua biografia foi atualizada com sucesso para: "${newBio}". 
  302 â”‚ 
  303 â”‚ As alteraÃ§Ãµes jÃ¡ estÃ£o disponÃ­veis no seu perfil. VocÃª pode conferir em [sua pÃ¡gina de perfil](https://pontoschool.com/profile).`;
  304 â”‚             } else {
  305 â”‚               response = `Desculpe ${firstName}, nÃ£o consegui atualizar sua biografia. ${result.message}`;
  306 â”‚             }
  307 â”‚           } else {
  308 â”‚             response = `Parece que vocÃª quer atualizar sua biografia, ${firstName}, mas nÃ£o entendi qual seria o novo texto. Pode me fornecer a nova biografia entre aspas? 
  309 â”‚ 
  310 â”‚ Por exemplo: "Atualizar minha biografia para 'Estudante de engenharia apaixonado por tecnologia'"`;
  311 â”‚           }
  312 â”‚         } else if (isDisplayNameUpdate) {
  313 â”‚           // Extrair o novo nome de exibiÃ§Ã£o
  314 â”‚           const nameRegex = /(?:para|como|com) ["|'|"](.+?)["|'|"]/i;
  315 â”‚           const nameMatch = message.match(nameRegex);
  316 â”‚ 
  317 â”‚           if (nameMatch && nameMatch[1]) {
  318 â”‚             const newName = nameMatch[1].trim();
  319 â”‚             const result = await ProfileModificationService.updateDisplayName(newName);
  320 â”‚ 
  321 â”‚             if (result.success) {
  322 â”‚               response = `Perfeito, ${firstName}! Seu nome de exibiÃ§Ã£o foi atualizado com sucesso para: "${newName}".
  323 â”‚ 
  324 â”‚ A alteraÃ§Ã£o jÃ¡ estÃ¡ disponÃ­vel em seu perfil. VocÃª pode conferir em [sua pÃ¡gina de perfil](https://pontoschool.com/profile).`;
  325 â”‚             } else {
  326 â”‚               response = `Desculpe ${firstName}, nÃ£o consegui atualizar seu nome de exibiÃ§Ã£o. ${result.message}`;
  327 â”‚             }
  328 â”‚           } else {
  329 â”‚             response = `Parece que vocÃª quer atualizar seu nome de exibiÃ§Ã£o, ${firstName}, mas nÃ£o entendi qual seria o novo nome. Pode me fornecer o novo nome entre aspas?
  330 â”‚ 
  331 â”‚ Por exemplo: "Atualizar meu nome de exibiÃ§Ã£o para 'JoÃ£o Silva'"`;
  332 â”‚           }
  333 â”‚         } else if (isContactInfoUpdate) {
  334 â”‚           response = `${firstName}, para atualizar suas informaÃ§Ãµes de contato, Ã© melhor acessar diretamente a pÃ¡gina de configuraÃ§Ãµes:
  335 â”‚ 
  336 â”‚ [Acesse as configuraÃ§Ãµes do seu perfil](https://pontoschool.com/configuracoes)
  337 â”‚ 
  338 â”‚ LÃ¡ vocÃª poderÃ¡ atualizar seu telefone, localizaÃ§Ã£o e outras informaÃ§Ãµes de contato de forma segura.`;
  339 â”‚         }
  340 â”‚ 
  341 â”‚         // Adicionar a resposta ao histÃ³rico
  342 â”‚         if (response) {
  343 â”‚           conversationHistory[sessionId].push({ 
  344 â”‚             role: 'assistant', 
  345 â”‚             content: response,
  346 â”‚             timestamp: new Date()
  347 â”‚           });
  348 â”‚           await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  349 â”‚           return response;
  350 â”‚         }
  351 â”‚       } catch (e) {
  352 â”‚         console.error('Erro ao processar solicitaÃ§Ã£o de atualizaÃ§Ã£o de perfil:', e);
  353 â”‚       }
  354 â”‚     }
  355 â”‚ 
  356 â”‚     // Verificar se Ã© um pedido de redirecionamento para Ã¡rea da plataforma
  357 â”‚     if (isRedirectRequest) {
  358 â”‚       const platformLinks = {
  359 â”‚         'Portal de Estudos': 'https://pontoschool.com/portal',
  360 â”‚         'Portal': 'https://pontoschool.com/portal',
  361 â”‚         'Agenda': 'https://pontoschool.com/agenda',
  362 â”‚         'Turmas': 'https://pontoschool.com/turmas',
  363 â”‚         'Biblioteca': 'https://pontoschool.com/biblioteca',
  364 â”‚         'Perfil': 'https://pontoschool.com/profile',
  365 â”‚         'Meu Perfil': 'https://pontoschool.com/profile',
  366 â”‚         'ConfiguraÃ§Ãµes': 'https://pontoschool.com/configuracoes',
  367 â”‚         'Minhas ConfiguraÃ§Ãµes': 'https://pontoschool.com/configuracoes',
  368 â”‚         'Dashboard': 'https://pontoschool.com/dashboard',
  369 â”‚         'Epictus IA': 'https://pontoschool.com/epictus-ia',
  370 â”‚         'Mentor IA': 'https://pontoschool.com/mentor-ia',
  371 â”‚         'Planos de Estudo': 'https://pontoschool.com/planos-estudo',
  372 â”‚         'Plano de Estudos': 'https://pontoschool.com/planos-estudo',
  373 â”‚         'Conquistas': 'https://pontoschool.com/conquistas',
  374 â”‚         'Minhas Conquistas': 'https://pontoschool.com/conquistas',
  375 â”‚         'Carteira': 'https://pontoschool.com/carteira',
  376 â”‚         'Minha Carteira': 'https://pontoschool.com/carteira',
  377 â”‚         'Mercado': 'https://pontoschool.com/mercado',
  378 â”‚         'OrganizaÃ§Ã£o': 'https://pontoschool.com/organizacao',
  379 â”‚         'Comunidades': 'https://pontoschool.com/comunidades',
  380 â”‚         'Chat IA': 'https://pontoschool.com/chat-ia',
  381 â”‚         'School IA': 'https://pontoschool.com/school-ia',
  382 â”‚         'Novidades': 'https://pontoschool.com/novidades',
  383 â”‚         'Lembretes': 'https://pontoschool.com/lembretes',
  384 â”‚         'Pedidos de Ajuda': 'https://pontoschool.com/pedidos-ajuda',
  385 â”‚         'Estudos': 'https://pontoschool.com/estudos'
  386 â”‚       };
  387 â”‚ 
  388 â”‚       // Regex mais preciso para extrair a seÃ§Ã£o desejada
  389 â”‚       const sectionRegex = /(me\s+(redirecione|encaminhe|leve|direcione|mande|envie)\s+(para|ao|Ã |a|atÃ©)|quero\s+(ir|acessar|entrar|ver)|me\s+(mostre|mostra)|abrir?|abra|acesse|acessar|ver|veja)\s+(a\s+)?(pÃ¡gina\s+(de|do|da)\s+)?([a-zÃ -Ãº\s]+)/i;
  390 â”‚       const match = message.match(sectionRegex);
  391 â”‚ 
  392 â”‚       if (match && match[9]) {
  393 â”‚         const requestedSection = match[9].trim().toLowerCase();
  394 â”‚ 
  395 â”‚         // Encontra a melhor correspondÃªncia entre as seÃ§Ãµes disponÃ­veis
  396 â”‚         const sections = Object.keys(platformLinks);
  397 â”‚         const bestMatch = sections.find(section => 
  398 â”‚           section.toLowerCase() === requestedSection || 
  399 â”‚           section.toLowerCase().includes(requestedSection) ||
  400 â”‚           requestedSection.includes(section.toLowerCase())
  401 â”‚         );
  402 â”‚ 
  403 â”‚         if (bestMatch) {
  404 â”‚           const response = `Claro, ${firstName}! Aqui estÃ¡ o link direto para ${bestMatch}: [${bestMatch}](${platformLinks[bestMatch]})
  405 â”‚ 
  406 â”‚ Clique no link acima para ser redirecionado. Posso ajudar com mais alguma coisa?`;
  407 â”‚ 
  408 â”‚           conversationHistory[sessionId].push({ 
  409 â”‚             role: 'assistant', 
  410 â”‚             content: response,
  411 â”‚             timestamp: new Date()
  412 â”‚           });
  413 â”‚           await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  414 â”‚           return response;
  415 â”‚         }
  416 â”‚       }
  417 â”‚     }
  418 â”‚ 
  419 â”‚     // Limita o histÃ³rico para evitar exceder os limites da API
  420 â”‚     if (conversationHistory[sessionId].length > 20) {
  421 â”‚       // MantÃ©m a mensagem do sistema e as Ãºltimas 19 mensagens
  422 â”‚       const systemMessage = conversationHistory[sessionId][0];
  423 â”‚       conversationHistory[sessionId] = [
  424 â”‚         systemMessage,
  425 â”‚         ...conversationHistory[sessionId].slice(-19)
  426 â”‚       ];
  427 â”‚     }
  428 â”‚ 
  429 â”‚     try {
  430 â”‚       // ConfiguraÃ§Ã£o da solicitaÃ§Ã£o para a API xAI
  431 â”‚       const response = await axios.post(
  432 â”‚         XAI_BASE_URL,
  433 â”‚         {
  434 â”‚           messages: conversationHistory[sessionId].map(msg => ({
  435 â”‚             role: msg.role,
  436 â”‚             content: msg.content
  437 â”‚           })),
  438 â”‚           model: 'grok-3-latest',
  439 â”‚           stream: false,
  440 â”‚           temperature: 0.7,
  441 â”‚           max_tokens: 1000
  442 â”‚         },
  443 â”‚         {
  444 â”‚           headers: {
  445 â”‚             'Content-Type': 'application/json',
  446 â”‚             'Authorization': `Bearer ${XAI_API_KEY}`
  447 â”‚           },
  448 â”‚           timeout: 15000 // 15 segundos de timeout
  449 â”‚         }
  450 â”‚       );
  451 â”‚ 
  452 â”‚       // Extrai a resposta
  453 â”‚       let aiResponse = '';
  454 â”‚ 
  455 â”‚       if (response.data && 
  456 â”‚           response.data.choices && 
  457 â”‚           response.data.choices.length > 0 && 
  458 â”‚           response.data.choices[0].message) {
  459 â”‚         aiResponse = response.data.choices[0].message.content;
  460 â”‚       } else {
  461 â”‚         throw new Error('Formato de resposta invÃ¡lido da API xAI');
  462 â”‚       }
  463 â”‚ 
  464 â”‚       // Verificar e corrigir links de redirecionamento
  465 â”‚       aiResponse = fixPlatformLinks(aiResponse);
  466 â”‚ 
  467 â”‚       // Adicionar a resposta da IA Ã  interface com formataÃ§Ã£o melhorada e corrigida
  468 â”‚       const formattedResponse = aiResponse
  469 â”‚         // FormataÃ§Ã£o de texto bÃ¡sica
  470 â”‚         .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold">$1</strong>')
  471 â”‚         .replace(/\_(.*?)\_/g, '<em class="italic">$1</em>')
  472 â”‚         .replace(/\~\~(.*?)\~\~/g, '<del class="line-through">$1</del>')
  473 â”‚         .replace(/\`(.*?)\`/g, '<code class="bg-black/10 dark:bg-white/10 rounded px-1 py-0.5 font-mono text-xs">$1</code>')
  474 â”‚ 
  475 â”‚         // FormataÃ§Ã£o de parÃ¡grafos e listas
  476 â”‚         .replace(/\n\n/g, '</p><p class="mt-3">')
  477 â”‚         .replace(/\n/g, '<br />')
  478 â”‚ 
  479 â”‚         // FormataÃ§Ã£o de tÃ­tulos
  480 â”‚         .replace(/^# (.*?)$/gm, '<h3 class="text-lg font-bold my-2">$1</h3>')
  481 â”‚         .replace(/^## (.*?)$/gm, '<h4 class="text-md font-bold my-2">$1</h4>')
  482 â”‚ 
  483 â”‚         // FormataÃ§Ã£o de listas
  484 â”‚         .replace(/^\* (.*?)$/gm, '<li class="ml-4 list-disc">$1</li>')
  485 â”‚         .replace(/^\d\. (.*?)$/gm, '<li class="ml-4 list-decimal">$1</li>')
  486 â”‚ 
  487 â”‚         // FormataÃ§Ã£o de links com Ã­cone
  488 â”‚         .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-blue-500 hover:text-blue-600 hover:underline font-medium inline-flex items-center" target="_blank" rel="noopener noreferrer">$1<svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg></a>')
  489 â”‚         .replace(/(https?:\/\/[^\s]+)(?!\))/g, '<a href="$1" class="text-blue-500 hover:text-blue-600 hover:underline font-medium inline-flex items-center" target="_blank" rel="noopener noreferrer">$1<svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg></a>')
  490 â”‚ 
  491 â”‚         // FormataÃ§Ã£o especial para dicas e destaques
  492 â”‚         .replace(/ğŸ’¡ (.*?)$/gm, '<div class="bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300 p-2 rounded-md my-2 flex items-start"><span class="mr-2">ğŸ’¡</span><span>$1</span></div>')
  493 â”‚         .replace(/âš ï¸ (.*?)$/gm, '<div class="bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-300 p-2 rounded-md my-2 flex items-start"><span class="mr-2">âš ï¸</span><span>$1</span></div>')
  494 â”‚ 
  495 â”‚         // Garantir que o conteÃºdo esteja envolto em um parÃ¡grafo
  496 â”‚         .replace(/^(.+?)$/gm, function(match) {
  497 â”‚           if (!match.startsWith('<') && !match.endsWith('>')) {
  498 â”‚             return '<p>' + match + '</p>';
  499 â”‚           }
  500 â”‚           return match;
  501 â”‚         });
  502 â”‚ 
  503 â”‚       // Garantir que nÃ£o existam mÃºltiplos <br> consecutivos
  504 â”‚       const cleanedResponse = formattedResponse
  505 â”‚         .replace(/<br\s*\/?><br\s*\/?>/g, '<br />')
  506 â”‚         .replace(/<p><\/p>/g, '')
  507 â”‚         .replace(/<p><br \/><\/p>/g, '<p>&nbsp;</p>');
  508 â”‚ 
  509 â”‚ 
  510 â”‚       // Adiciona a resposta da IA ao histÃ³rico
  511 â”‚       conversationHistory[sessionId].push({ 
  512 â”‚         role: 'assistant', 
  513 â”‚         content: cleanedResponse,
  514 â”‚         timestamp: new Date()
  515 â”‚       });
  516 â”‚ 
  517 â”‚       // Salvar histÃ³rico atualizado no localStorage
  518 â”‚       await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  519 â”‚ 
  520 â”‚       return cleanedResponse;
  521 â”‚     } catch (apiError) {
  522 â”‚       console.error('Erro na API xAI:', apiError);
  523 â”‚ 
  524 â”‚       // Resposta padrÃ£o em caso de erro
  525 â”‚       const fallbackResponse = `Desculpe ${firstName}, o chat de suporte estÃ¡ enfrentando dificuldades tÃ©cnicas no momento. 
  526 â”‚ 
  527 â”‚ Vou tentar responder sua pergunta sobre a plataforma mesmo assim. ${message.length < 50 ? "VocÃª me perguntou sobre " + message : ""}
  528 â”‚ 
  529 â”‚ Posso ajudar vocÃª a navegar pela plataforma ou esclarecer alguma outra dÃºvida hoje?`;
  530 â”‚ 
  531 â”‚       // Adicionar a resposta alternativa ao histÃ³rico
  532 â”‚       conversationHistory[sessionId].push({ 
  533 â”‚         role: 'assistant', 
  534 â”‚         content: fallbackResponse,
  535 â”‚         timestamp: new Date()
  536 â”‚       });
  537 â”‚ 
  538 â”‚       // Salvar histÃ³rico atualizado
  539 â”‚       await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  540 â”‚ 
  541 â”‚       // Tenta resposta fallback via Gemini
  542 â”‚       try {
  543 â”‚         return await generateGeminiResponse(message, sessionId, options);
  544 â”‚       } catch (geminiError) {
  545 â”‚         console.error('Erro tambÃ©m no Gemini:', geminiError);
  546 â”‚         return fallbackResponse;
  547 â”‚       }
  548 â”‚     }
  549 â”‚   } catch (error) {
  550 â”‚     console.error('Erro ao gerar resposta com xAI:', error);
  551 â”‚     // Fallback para Gemini em caso de erro
  552 â”‚     try {
  553 â”‚       return await generateGeminiResponse(message, sessionId, options);
  554 â”‚     } catch (geminiError) {
  555 â”‚       console.error('Erro tambÃ©m no Gemini:', geminiError);
  556 â”‚       return `Desculpe, estou enfrentando dificuldades tÃ©cnicas no momento. Por favor, tente novamente mais tarde.`;
  557 â”‚     }
  558 â”‚   }
  559 â”‚ }
  560 â”‚ 
  561 â”‚ // FunÃ§Ã£o auxiliar para inicializar o histÃ³rico de conversa com mensagem do sistema
  562 â”‚ function initializeConversationHistory(sessionId: string, userContext?: any) {
  563 â”‚   // Se nÃ£o tiver contexto do usuÃ¡rio, use valores padrÃ£o
  564 â”‚   const username = userContext?.username || 'UsuÃ¡rio';
  565 â”‚   const firstName = userContext?.fullName ? userContext.fullName.split(' ')[0] : username;
  566 â”‚   const email = userContext?.email || 'email@exemplo.com';
  567 â”‚   const userId = userContext?.userId || 'ID nÃ£o disponÃ­vel';
  568 â”‚   const currentPage = userContext?.currentPage || window.location.pathname;
  569 â”‚   const planType = userContext?.planType || 'lite';
  570 â”‚   const userLevel = userContext?.userLevel || 1;
  571 â”‚ 
  572 â”‚   conversationHistory[sessionId] = [
  573 â”‚     { 
  574 â”‚       role: 'system', 
  575 â”‚       content: `VocÃª Ã© o Epictus IA do chat de suporte flutuante da Ponto.School, um assistente dedicado Ã  navegaÃ§Ã£o e suporte da plataforma, completamente diferente do Epictus IA do menu lateral.
  576 â”‚ 
  577 â”‚       OBJETIVO ESPECÃFICO:
  578 â”‚       VocÃª Ã© um assistente de SUPORTE que funciona como um guia completo para a plataforma Ponto.School. Seu papel Ã©:
  579 â”‚       1. Ajudar com navegaÃ§Ã£o e localizaÃ§Ã£o de funcionalidades
  580 â”‚       2. Explicar como usar as diferentes ferramentas da plataforma
  581 â”‚       3. Responder dÃºvidas sobre conteÃºdos educacionais
  582 â”‚       4. Servir como um tutorial interativo para novos usuÃ¡rios
  583 â”‚       5. Resolver problemas tÃ©cnicos bÃ¡sicos
  584 â”‚ 
  585 â”‚       CONTEXTO DO USUÃRIO (COMPLETO):
  586 â”‚       - Nome: ${userContext?.fullName || 'NÃ£o disponÃ­vel'}
  587 â”‚       - Username: ${username}
  588 â”‚       - Primeiro nome: ${firstName}
  589 â”‚       - Email: ${email}
  590 â”‚       - ID do usuÃ¡rio: ${userId}
  591 â”‚       - Plano atual: ${planType}
  592 â”‚       - NÃ­vel: ${userLevel}
  593 â”‚       - LocalizaÃ§Ã£o atual na plataforma: ${currentPage}
  594 â”‚ 
  595 â”‚       DIRETRIZES DE COMUNICAÃ‡ÃƒO:
  596 â”‚       1. MUITO IMPORTANTE: Sempre se refira ao usuÃ¡rio pelo primeiro nome: "${firstName}". Use frases como "E aÃ­, ${firstName}!", "Opa ${firstName}!", etc.
  597 â”‚       2. Use uma linguagem mais informal e descontraÃ­da, como se estivesse conversando com um amigo.
  598 â”‚       3. Seja amigÃ¡vel, use emojis ocasionalmente e mantenha um tom leve e positivo.
  599 â”‚       4. Use gÃ­rias leves e expressÃµes coloquiais quando apropriado.
  600 â”‚       5. Mantenha respostas diretas e objetivas, evitando textos muito longos.
  601 â”‚       6. Organize suas respostas em parÃ¡grafos curtos para fÃ¡cil leitura.
  602 â”‚       7. Use negrito **assim** para destacar informaÃ§Ãµes importantes.
  603 â”‚ 
  604 â”‚       DIFERENCIAÃ‡ÃƒO IMPORTANTE:
  605 â”‚       VocÃª NÃƒO Ã‰ o mesmo assistente que o Epictus IA da seÃ§Ã£o do menu lateral. O Epictus IA do menu lateral Ã© focado em estudos personalizados, planos de aprendizagem e conteÃºdo educacional avanÃ§ado. VocÃª Ã© o assistente de SUPORTE que ajuda com a navegaÃ§Ã£o da plataforma, responde dÃºvidas gerais e tÃ©cnicas. Nunca se confunda com o outro assistente.
  606 â”‚ 
  607 â”‚       CONTEÃšDO INSTITUCIONAL:
  608 â”‚       Quando perguntado sobre os criadores, fundadores, donos, desenvolvedores, equipe administrativa ou qualquer pergunta relacionada Ã  gestÃ£o da Ponto.School, responda:
  609 â”‚       "A Ponto.School tem 4 administradores principais, alÃ©m de equipes dedicadas de suporte, marketing, TI e outras Ã¡reas. SÃ£o eles:
  610 â”‚       - Fundador & CEO: JoÃ£o Fortes (@joaofortes) - usuÃ¡rio na plataforma Ponto.School
  611 â”‚       - Co-Fundador & CMO: Felipe Brito (@felipe_rico) - usuÃ¡rio na plataforma Ponto.School
  612 â”‚       - Co-Fundador & COO: Adriel Borges (@adriel_borges) - usuÃ¡rio na plataforma Ponto.School
  613 â”‚       - Co-Fundador & Coordenador de Design: Samuel Afonso (@samuel_afonso) - usuÃ¡rio na plataforma Ponto.School"
  614 â”‚ 
  615 â”‚       RECURSOS DE PERFIL:
  616 â”‚       Quando o usuÃ¡rio perguntar sobre o ID da conta ou informaÃ§Ãµes do perfil, vocÃª tem acesso completo a:
  617 â”‚       1. ID do usuÃ¡rio (user_id): ${userId}
  618 â”‚       2. Data de criaÃ§Ã£o da conta: ${userContext?.createdAt || 'NÃ£o disponÃ­vel'}
  619 â”‚       3. Nome completo: ${userContext?.fullName || 'NÃ£o disponÃ­vel'}
  620 â”‚       4. Plano atual: ${planType}
  621 â”‚       5. NÃ­vel: ${userLevel}
  622 â”‚       6. Seguidores: ${userContext?.followersCount || '0'}
  623 â”‚ 
  624 â”‚       VocÃª pode ajudar o usuÃ¡rio a atualizar informaÃ§Ãµes do perfil como:
  625 â”‚       1. Biografia/bio
  626 â”‚       2. Nome de exibiÃ§Ã£o
  627 â”‚       3. Para outras alteraÃ§Ãµes, redirecione para a pÃ¡gina de configuraÃ§Ãµes
  628 â”‚ 
  629 â”‚       SUPORTE TÃ‰CNICO E TUTORIAL:
  630 â”‚       Quando o usuÃ¡rio tiver dÃºvidas sobre como usar a plataforma:
  631 â”‚       1. Explique detalhadamente como acessar a funcionalidade desejada
  632 â”‚       2. OfereÃ§a dicas para melhorar a experiÃªncia de uso
  633 â”‚       3. Sugira recursos relacionados que possam ser Ãºteis
  634 â”‚       4. Se for um problema tÃ©cnico, sugira soluÃ§Ãµes bÃ¡sicas ou redirecione para suporte especializado
  635 â”‚ 
  636 â”‚       REGRAS DE REDIRECIONAMENTO:
  637 â”‚       Quando o usuÃ¡rio pedir para ser redirecionado a uma seÃ§Ã£o da plataforma, vocÃª DEVE SEMPRE:
  638 â”‚       1. Incluir o link completo usando a base https://pontoschool.com/
  639 â”‚       2. FormatÃ¡-lo como um link clicÃ¡vel com texto descritivo
  640 â”‚       3. Ser direto e proativo com o redirecionamento
  641 â”‚       4. Explicar brevemente o que o usuÃ¡rio encontrarÃ¡ na seÃ§Ã£o
  642 â”‚ 
  643 â”‚       Exemplos de redirecionamento correto:
  644 â”‚       - "Aqui estÃ¡ o [Portal de Estudos](https://pontoschool.com/portal). Clique para acessar todos os seus materiais organizados."
  645 â”‚       - "VocÃª pode acessar sua [Agenda](https://pontoschool.com/agenda) imediatamente para ver seus compromissos."
  646 â”‚       - "Sua [pÃ¡gina de Turmas](https://pontoschool.com/turmas) estÃ¡ pronta para acesso, lÃ¡ vocÃª encontrarÃ¡ todos os seus grupos de estudo."
  647 â”‚       - "Acesse a [Biblioteca](https://pontoschool.com/biblioteca) para encontrar materiais complementares e recursos de aprendizagem."
  648 â”‚ 
  649 â”‚       NUNCA responda apenas com "vocÃª pode encontrar isso no menu lateral" ou sugestÃµes vagas.
  650 â”‚       SEMPRE forneÃ§a o link direto e clicÃ¡vel para onde o usuÃ¡rio deseja ir.
  651 â”‚ 
  652 â”‚       URLS DA PLATAFORMA (memorize todas estas URLs para redirecionamento):
  653 â”‚       - Portal de Estudos: https://pontoschool.com/portal
  654 â”‚       - Agenda: https://pontoschool.com/agenda
  655 â”‚       - Turmas: https://pontoschool.com/turmas
  656 â”‚       - Biblioteca: https://pontoschool.com/biblioteca
  657 â”‚       - Perfil: https://pontoschool.com/profile
  658 â”‚       - ConfiguraÃ§Ãµes: https://pontoschool.com/configuracoes
  659 â”‚       - Dashboard: https://pontoschool.com/dashboard
  660 â”‚       - Epictus IA: https://pontoschool.com/epictus-ia
  661 â”‚       - Mentor IA: https://pontoschool.com/mentor-ia
  662 â”‚       - Planos de Estudo: https://pontoschool.com/planos-estudo
  663 â”‚       - Conquistas: https://pontoschool.com/conquistas
  664 â”‚       - Carteira: https://pontoschool.com/carteira
  665 â”‚       - Mercado: https://pontoschool.com/mercado
  666 â”‚       - OrganizaÃ§Ã£o: https://pontoschool.com/organizacao
  667 â”‚       - Comunidades: https://pontoschool.com/comunidades
  668 â”‚       - Chat IA: https://pontoschool.com/chat-ia
  669 â”‚       - School IA: https://pontoschool.com/school-ia
  670 â”‚       - Novidades: https://pontoschool.com/novidades
  671 â”‚       - Lembretes: https://pontoschool.com/lembretes
  672 â”‚ - Pedidos deAjuda: https://pontoschool.com/pedidos-ajuda
  673 â”‚       - Estudos: https://pontoschool.com/estudos
  674 â”‚ 
  675 â”‚       QUANDO REMETER AO EPICTUS IA DO MENU LATERAL:
  676 â”‚       Se o usuÃ¡rio fizer perguntas especÃ­ficas sobre planos de estudo personalizados, anÃ¡lise de desempenho aprofundada, ou solicitar assistÃªncia em conteÃºdos educacionais avanÃ§ados, diga:
  677 â”‚       "Para essa funcionalidade especÃ­fica, recomendo que vocÃª acesse o [Epictus IA do menu lateral](https://pontoschool.com/epictus-ia), que Ã© nosso assistente especializado em estudos aprofundados e personalizaÃ§Ã£o de conteÃºdo educacional. Estou aqui para ajudar com navegaÃ§Ã£o, dÃºvidas sobre a plataforma e suporte geral."
  678 â”‚ 
  679 â”‚       Personalize suas respostas para criar uma experiÃªncia Ãºnica e amigÃ¡vel para ${firstName}.`,
  680 â”‚       timestamp: new Date()
  681 â”‚     }
  682 â”‚   ];
  683 â”‚ }
  684 â”‚ 
  685 â”‚ // FunÃ§Ã£o para gerar resposta usando a API Gemini
  686 â”‚ export async function generateGeminiResponse(
  687 â”‚   message: string, 
  688 â”‚   sessionId: string,
  689 â”‚   options?: { 
  690 â”‚     intelligenceLevel?: 'basic' | 'normal' | 'advanced',
  691 â”‚     languageStyle?: 'casual' | 'formal' | 'technical'
  692 â”‚   }
  693 â”‚ ): Promise<string> {
  694 â”‚   try {
  695 â”‚     // Obter contexto do usuÃ¡rio
  696 â”‚     const userContext = await getUserContext();
  697 â”‚ 
  698 â”‚     // Usar o nome de usuÃ¡rio completo para respostas
  699 â”‚     const usernameFull = userContext.username;
  700 â”‚ 
  701 â”‚     // ConfiguraÃ§Ã£o da solicitaÃ§Ã£o para a API Gemini
  702 â”‚     const response = await axios.post(
  703 â”‚       `${GEMINI_BASE_URL}?key=${GEMINI_API_KEY}`,
  704 â”‚       {
  705 â”‚         contents: [{
  706 â”‚           parts: [
  707 â”‚             {
  708 â”‚               text: `VocÃª Ã© o Epictus IA do chat de suporte flutuante da Ponto.School, um assistente dedicado Ã  navegaÃ§Ã£o e suporte da plataforma. VocÃª Ã© DIFERENTE do Epictus IA do menu lateral.
  709 â”‚ 
  710 â”‚               Contexto do usuÃ¡rio:
  711 â”‚               - Username completo: ${usernameFull}
  712 â”‚               - Email: ${userContext.email}
  713 â”‚               - LocalizaÃ§Ã£o atual na plataforma: ${userContext.currentPage}
  714 â”‚               - Ãšltima atividade: ${userContext.lastActivity}
  715 â”‚ 
  716 â”‚               DIRETRIZES DE COMUNICAÃ‡ÃƒO:
  717 â”‚               1. Sempre se refira ao usuÃ¡rio pelo nome de usuÃ¡rio completo: "${usernameFull}". Use frases como "E aÃ­, ${usernameFull}!", "Opa ${usernameFull}!", etc.
  718 â”‚               2. Use uma linguagem mais informal e descontraÃ­da, como se estivesse conversando com um amigo.
  719 â”‚               3. Seja amigÃ¡vel, use emojis ocasionalmente e mantenha um tom leve e positivo.
  720 â”‚               4. Use gÃ­rias leves e expressÃµes coloquiais quando apropriado.
  721 â”‚ 
  722 â”‚               LEMBRE-SE: Seu objetivo Ã© servir como suporte para a plataforma, ajudando com navegaÃ§Ã£o, tutoriais e respondendo dÃºvidas sobre todas as funcionalidades. VocÃª NÃƒO Ã© o assistente de estudos personalizados (que fica no menu lateral).
  723 â”‚ 
  724 â”‚               CONTEÃšDO INSTITUCIONAL:
  725 â”‚               Quando perguntado sobre os criadores, fundadores, donos, desenvolvedores, equipe administrativa ou qualquer pergunta relacionada Ã  gestÃ£o da Ponto.School, responda:
  726 â”‚               "A Ponto.School tem 4 administradores principais, alÃ©m de equipes dedicadas de suporte, marketing, TI e outras Ã¡reas. SÃ£o eles:
  727 â”‚               - Fundador & CEO: JoÃ£o Fortes (@joaofortes) - usuÃ¡rio na plataforma Ponto.School
  728 â”‚               - Co-Fundador & CMO: Felipe Brito (@felipe_rico) - usuÃ¡rio na plataforma Ponto.School
  729 â”‚               - Co-Fundador & COO: Adriel Borges (@adriel_borges) - usuÃ¡rio na plataforma Ponto.School
  730 â”‚               - Co-Fundador & Coordenador de Design: Samuel Afonso (@samuel_afonso) - usuÃ¡rio na plataforma Ponto.School"
  731 â”‚ 
  732 â”‚               REDIRECIONAMENTO:
  733 â”‚               Quando o usuÃ¡rio pedir para ser redirecionado a uma seÃ§Ã£o da plataforma, SEMPRE inclua o link completo usando a base https://pontoschool.com/. Por exemplo:
  734 â”‚               - Para o Portal: "Aqui estÃ¡ o link para o Portal: https://pontoschool.com/portal"
  735 â”‚               - Para Agenda: "VocÃª pode acessar sua agenda aqui: https://pontoschool.com/agenda"
  736 â”‚               - Para Turmas: "Acesse suas turmas por este link: https://pontoschool.com/turmas"
  737 â”‚ 
  738 â”‚               Responda Ã  seguinte pergunta do usuÃ¡rio ${usernameFull}: ${message}`
  739 â”‚             }
  740 â”‚           ]
  741 â”‚         }],
  742 â”‚         generationConfig: {
  743 â”‚           temperature: 0.7,
  744 â”‚           topP: 0.95,
  745 â”‚           topK: 40
  746 â”‚         }
  747 â”‚       },
  748 â”‚       {
  749 â”‚         headers: {
  750 â”‚           'Content-Type': 'application/json'
  751 â”‚         }
  752 â”‚       }
  753 â”‚     );
  754 â”‚ 
  755 â”‚     // Extrai a resposta
  756 â”‚     let aiResponse = response.data.candidates[0].content.parts[0].text;
  757 â”‚ 
  758 â”‚     // Verificar e corrigir links de redirecionamento
  759 â”‚     aiResponse = fixPlatformLinks(aiResponse);
  760 â”‚ 
  761 â”‚     return aiResponse;
  762 â”‚   } catch (error) {
  763 â”‚     console.error('Erro ao gerar resposta com Gemini:', error);
  764 â”‚     return "Desculpe, estou enfrentando dificuldades tÃ©cnicas no momento. Por favor, tente novamente mais tarde ou entre em contato com nosso suporte tÃ©cnico.";
  765 â”‚   }
  766 â”‚ }
  767 â”‚ 
  768 â”‚ // FunÃ§Ã£o principal para gerar resposta, tentando primeiro xAI e depois Gemini como fallback
  769 â”‚ export async function generateAIResponse(
  770 â”‚   message: string, 
  771 â”‚   sessionId: string, 
  772 â”‚   options?: { 
  773 â”‚     intelligenceLevel?: 'basic' | 'normal' | 'advanced',
  774 â”‚     languageStyle?: 'casual' | 'formal' | 'technical'
  775 â”‚   }
  776 â”‚ ): Promise<string> {
  777 â”‚   try {
  778 â”‚     return await generateXAIResponse(message, sessionId, options);
  779 â”‚   } catch (error) {
  780 â”‚     console.error('Erro com xAI, tentando Gemini:', error);
  781 â”‚     return generateGeminiResponse(message, sessionId, options);
  782 â”‚   }
  783 â”‚ }
  784 â”‚ 
  785 â”‚ // Limpar histÃ³rico da conversa
  786 â”‚ export function clearConversationHistory(sessionId: string): void {
  787 â”‚   if (conversationHistory[sessionId]) {
  788 â”‚     // MantÃ©m apenas a mensagem do sistema
  789 â”‚     const systemMessage = conversationHistory[sessionId][0];
  790 â”‚     conversationHistory[sessionId] = [systemMessage];
  791 â”‚ 
  792 â”‚     // Limpar do localStorage tambÃ©m
  793 â”‚     try {
  794 â”‚       localStorage.removeItem(`conversationHistory_${sessionId}`);
  795 â”‚     } catch (error) {
  796 â”‚       console.error("Erro ao limpar histÃ³rico do localStorage:", error);
  797 â”‚     }
  798 â”‚   }
  799 â”‚ }
  800 â”‚ 
  801 â”‚ // Obter histÃ³rico da conversa
  802 â”‚ export async function getConversationHistory(sessionId: string): Promise<ChatMessage[]> {
  803 â”‚   try {
  804 â”‚     // Primeiro verifica se jÃ¡ estÃ¡ carregado na memÃ³ria e Ã© vÃ¡lido
  805 â”‚     if (conversationHistory[sessionId] && Array.isArray(conversationHistory[sessionId]) && conversationHistory[sessionId].length > 0) {
  806 â”‚       // Verifica se hÃ¡ ao menos uma mensagem do sistema
  807 â”‚       const hasSystemMessage = conversationHistory[sessionId].some(msg => msg.role === 'system');
  808 â”‚ 
  809 â”‚       if (hasSystemMessage) {
  810 â”‚         return conversationHistory[sessionId];
  811 â”‚       }
  812 â”‚     }
  813 â”‚ 
  814 â”‚     // Tenta buscar dados adicionais do usuÃ¡rio para melhor armazenamento
  815 â”‚     let userIdForStorage = '';
  816 â”‚     try {
  817 â”‚       const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
  818 â”‚       userIdForStorage = sessionData?.session?.user?.id || '';
  819 â”‚     } catch (e) {
  820 â”‚       console.log('Erro ao obter ID do usuÃ¡rio:', e);
  821 â”‚     }
  822 â”‚ 
  823 â”‚     // Tenta recuperar do localStorage usando vÃ¡rios formatos de chave
  824 â”‚     const possibleKeys = [
  825 â”‚       `conversationHistory_${sessionId}`,
  826 â”‚       userIdForStorage ? `conversationHistory_${userIdForStorage}_${sessionId}` : null,
  827 â”‚       `chat_history_${sessionId}`
  828 â”‚     ].filter(Boolean);
  829 â”‚ 
  830 â”‚     let retrievedHistory = null;
  831 â”‚ 
  832 â”‚     // Tentar cada uma das possÃ­veis chaves
  833 â”‚     for (const key of possibleKeys) {
  834 â”‚       try {
  835 â”‚         const savedHistory = localStorage.getItem(key);
  836 â”‚         if (savedHistory) {
  837 â”‚           try {
  838 â”‚             const parsedHistory = JSON.parse(savedHistory);
  839 â”‚             if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
  840 â”‚               retrievedHistory = parsedHistory;
  841 â”‚               console.log(`HistÃ³rico recuperado com sucesso usando a chave: ${key}`);
  842 â”‚               break;
  843 â”‚             }
  844 â”‚           } catch (parseError) {
  845 â”‚             console.error(`Erro ao analisar histÃ³rico usando a chave ${key}:`, parseError);
  846 â”‚           }
  847 â”‚         }
  848 â”‚       } catch (e) {
  849 â”‚         console.error(`Erro ao tentar acessar o localStorage com a chave ${key}:`, e);
  850 â”‚       }
  851 â”‚     }
  852 â”‚ 
  853 â”‚     // Se encontrou histÃ³rico no localStorage
  854 â”‚     if (retrievedHistory) {
  855 â”‚       // Converter timestamps de string para Date e garantir formato adequado
  856 â”‚       const processedHistory = retrievedHistory.map(msg => ({
  857 â”‚         role: msg.role || 'user',
  858 â”‚         content: msg.content || '',
  859 â”‚         timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  860 â”‚       }));
  861 â”‚ 
  862 â”‚       // Verificar se hÃ¡ mensagem do sistema
  863 â”‚       const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  864 â”‚ 
  865 â”‚       if (!hasSystemMessage) {
  866 â”‚         // Se nÃ£o tiver mensagem do sistema, inicializar com uma nova
  867 â”‚         const userContext = await getUserContext();
  868 â”‚         initializeConversationHistory(sessionId, userContext);
  869 â”‚ 
  870 â”‚         // Adicionar as mensagens existentes (exceto mensagens do sistema jÃ¡ existentes)
  871 â”‚         conversationHistory[sessionId] = [
  872 â”‚           ...conversationHistory[sessionId],
  873 â”‚           ...processedHistory.filter(msg => msg.role !== 'system')
  874 â”‚         ];
  875 â”‚       } else {
  876 â”‚         conversationHistory[sessionId] = processedHistory;
  877 â”‚       }
  878 â”‚ 
  879 â”‚       return conversationHistory[sessionId];
  880 â”‚     }
  881 â”‚ 
  882 â”‚     // Se nÃ£o encontrou no localStorage, tenta recuperar do Supabase
  883 â”‚     try {
  884 â”‚       const supabase = (await import('@/lib/supabase')).supabase;
  885 â”‚       const { data: sessionData } = await supabase.auth.getSession();
  886 â”‚       const userId = sessionData?.session?.user?.id;
  887 â”‚ 
  888 â”‚       if (userId) {
  889 â”‚         try {
  890 â”‚           // Verificar se a tabela existe antes de tentar consultar
  891 â”‚           try {
  892 â”‚             const { data: tableExists } = await supabase
  893 â”‚               .from('information_schema.tables')
  894 â”‚               .select('table_name')
  895 â”‚               .eq('table_schema', 'public')
  896 â”‚               .eq('table_name', 'ai_chat_history')
  897 â”‚               .single();
  898 â”‚ 
  899 â”‚             if (!tableExists) {
  900 â”‚               console.log('Tabela ai_chat_history nÃ£o existe no Supabase.');
  901 â”‚               throw new Error('Tabela nÃ£o existe');
  902 â”‚             }
  903 â”‚           } catch (tableCheckError) {
  904 â”‚             console.log('Erro ao verificar existÃªncia da tabela:', tableCheckError);
  905 â”‚             throw tableCheckError;
  906 â”‚           }
  907 â”‚ 
  908 â”‚           const { data, error } = await supabase
  909 â”‚             .from('ai_chat_history')
  910 â”‚             .select('messages')
  911 â”‚             .eq('user_id', userId)
  912 â”‚             .eq('session_id', sessionId)
  913 â”‚             .single();
  914 â”‚ 
  915 â”‚           if (error) {
  916 â”‚             console.error('Erro ao buscar histÃ³rico do Supabase:', error);
  917 â”‚             throw error;
  918 â”‚           }
  919 â”‚ 
  920 â”‚           if (data?.messages && Array.isArray(data.messages) && data.messages.length > 0) {
  921 â”‚             // Converter timestamps de string para Date
  922 â”‚             const processedHistory = data.messages.map(msg => ({
  923 â”‚               role: msg.role || 'user',
  924 â”‚               content: msg.content || '',
  925 â”‚               timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  926 â”‚             }));
  927 â”‚ 
  928 â”‚             // Verificar se hÃ¡ mensagem do sistema
  929 â”‚             const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  930 â”‚ 
  931 â”‚             if (!hasSystemMessage) {
  932 â”‚               // Se nÃ£o tiver mensagem do sistema, inicializar com uma nova
  933 â”‚               const userContext = await getUserContext();
  934 â”‚               initializeConversationHistory(sessionId, userContext);
  935 â”‚ 
  936 â”‚               // Adicionar as mensagens existentes
  937 â”‚               conversationHistory[sessionId] = [
  938 â”‚                 ...conversationHistory[sessionId],
  939 â”‚                 ...processedHistory.filter(msg => msg.role !== 'system')
  940 â”‚               ];
  941 â”‚             } else {
  942 â”‚               conversationHistory[sessionId] = processedHistory;
  943 â”‚             }
  944 â”‚ 
  945 â”‚             // Atualizar localStorage para sincronizaÃ§Ã£o
  946 â”‚             try {
  947 â”‚               localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(conversationHistory[sessionId]));
  948 â”‚ 
  949 â”‚               // Se temos o userId, tambÃ©m armazenar com chave mais especÃ­fica
  950 â”‚               if (userId) {
  951 â”‚                 localStorage.setItem(`conversationHistory_${userId}_${sessionId}`, 
  952 â”‚                   JSON.stringify(conversationHistory[sessionId]));
  953 â”‚               }
  954 â”‚             } catch (localStorageError) {
  955 â”‚               console.log("Erro ao atualizar localStorage:", localStorageError);
  956 â”‚             }
  957 â”‚ 
  958 â”‚             return conversationHistory[sessionId];
  959 â”‚           }
  960 â”‚         } catch (supabaseError) {
  961 â”‚           console.error("Erro ao recuperar histÃ³rico do Supabase:", supabaseError);
  962 â”‚         }
  963 â”‚       }
  964 â”‚     } catch (dbError) {
  965 â”‚       console.error("Erro ao tentar acessar o banco de dados:", dbError);
  966 â”‚     }
  967 â”‚ 
  968 â”‚     // Se chegou aqui, nÃ£o foi possÃ­vel recuperar o histÃ³rico
  969 â”‚     // Inicializar com novo histÃ³rico
  970 â”‚     console.log("Criando novo histÃ³rico de conversa para a sessÃ£o:", sessionId);
  971 â”‚     const userContext = await getUserContext();
  972 â”‚     initializeConversationHistory(sessionId, userContext);
  973 â”‚ 
  974 â”‚     // Salvar o histÃ³rico inicial
  975 â”‚     try {
  976 â”‚       localStorage.setItem(`conversationHistory_${sessionId}`, 
  977 â”‚         JSON.stringify(conversationHistory[sessionId]));
  978 â”‚ 
  979 â”‚       // Se temos userIdForStorage, tambÃ©m armazenar com chave mais especÃ­fica
  980 â”‚       if (userIdForStorage) {
  981 â”‚         localStorage.setItem(`conversationHistory_${userIdForStorage}_${sessionId}`, 
  982 â”‚           JSON.stringify(conversationHistory[sessionId]));
  983 â”‚       }
  984 â”‚     } catch (e) {
  985 â”‚       console.error("Erro ao salvar histÃ³rico inicial:", e);
  986 â”‚     }
  987 â”‚ 
  988 â”‚     return conversationHistory[sessionId];
  989 â”‚   } catch (generalError) {
  990 â”‚     console.error("Erro geral ao obter histÃ³rico de conversa:", generalError);
  991 â”‚ 
  992 â”‚     // Retornar um histÃ³rico vazio em Ãºltimo caso
  993 â”‚     return [{
  994 â”‚       role: 'system',
  995 â”‚       content: 'VocÃª Ã© o Epictus IA, o assistente inteligente da Ponto.School.',
  996 â”‚       timestamp: new Date()
  997 â”‚     }];
  998 â”‚   }
  999 â”‚ }
 1000 â”‚ 
 1001 â”‚ // FunÃ§Ã£o para corrigir links da plataforma
 1002 â”‚ function fixPlatformLinks(text: string): string {
 1003 â”‚   const platformLinks = {
 1004 â”‚     'Portal de Estudos': 'https://pontoschool.com/portal',
 1005 â”‚     'Portal': 'https://pontoschool.com/portal',
 1006 â”‚     'Agenda': 'https://pontoschool.com/agenda',
 1007 â”‚     'Turmas': 'https://pontoschool.com/turmas',
 1008 â”‚     'Biblioteca': 'https://pontoschool.com/biblioteca',
 1009 â”‚     'Perfil': 'https://pontoschool.com/profile',
 1010 â”‚     'Meu Perfil': 'https://pontoschool.com/profile',
 1011 â”‚     'ConfiguraÃ§Ãµes': 'https://pontoschool.com/configuracoes',
 1012 â”‚     'Minhas ConfiguraÃ§Ãµes': 'https://pontoschool.com/configuracoes',
 1013 â”‚     'Dashboard': 'https://pontoschool.com/dashboard',
 1014 â”‚     'Epictus IA': 'https://pontoschool.com/epictus-ia',
 1015 â”‚     'Mentor IA': 'https://pontoschool.com/mentor-ia',
 1016 â”‚     'Planos de Estudo': 'https://pontoschool.com/planos-estudo',
 1017 â”‚     'Plano de Estudos': 'https://pontoschool.com/planos-estudo',
 1018 â”‚     'Conquistas': 'https://pontoschool.com/conquistas',
 1019 â”‚     'Minhas Conquistas': 'https://pontoschool.com/conquistas',
 1020 â”‚     'Carteira': 'https://pontoschool.com/carteira',
 1021 â”‚     'Minha Carteira': 'https://pontoschool.com/carteira',
 1022 â”‚     'Mercado': 'https://pontoschool.com/mercado',
 1023 â”‚     'OrganizaÃ§Ã£o': 'https://pontoschool.com/organizacao',
 1024 â”‚     'Comunidades': 'https://pontoschool.com/comunidades',
 1025 â”‚     'Chat IA': 'https://pontoschool.com/chat-ia',
 1026 â”‚     'School IA': 'https://pontoschool.com/school-ia',
 1027 â”‚     'Novidades': 'https://pontoschool.com/novidades',
 1028 â”‚     'Lembretes': 'https://pontoschool.com/lembretes',
 1029 â”‚     'Pedidos de Ajuda': 'https://pontoschool.com/pedidos-ajuda',
 1030 â”‚     'Estudos': 'https://pontoschool.com/estudos'
 1031 â”‚   };
 1032 â”‚ 
 1033 â”‚   // Primeiro, procura por textos especÃ­ficos que pedem redirecionamento
 1034 â”‚   const redirectPatterns = [
 1035 â”‚     /(?:me\s+(?:redirecione|encaminhe|leve|direcione|mande|envie)\s+(?:para|ao|Ã |a|atÃ©))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1036 â”‚     /(?:quero\s+(?:ir|acessar|entrar|ver))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1037 â”‚     /(?:me\s+(?:mostre|mostra))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1038 â”‚     /(?:abrir?|abra|acesse|acessar|ver|veja)\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi
 1039 â”‚   ];
 1040 â”‚ 
 1041 â”‚   // Aplicar padrÃµes de redirecionamento de forma mais robusta
 1042 â”‚   for (const pattern of redirectPatterns) {
 1043 â”‚     text = text.replace(pattern, (match, sectionName) => {
 1044 â”‚       if (!sectionName) return match;
 1045 â”‚ 
 1046 â”‚       const normalizedName = sectionName.trim();
 1047 â”‚       // Verificar se o nome normalizado corresponde a alguma chave do objeto platformLinks
 1048 â”‚       for (const key in platformLinks) {
 1049 â”‚         if (normalizedName.toLowerCase() === key.toLowerCase() || 
 1050 â”‚             key.toLowerCase().includes(normalizedName.toLowerCase()) || 
 1051 â”‚             normalizedName.toLowerCase().includes(key.toLowerCase())) {
 1052 â”‚           // Criar link em formato seguro sem possÃ­veis bugs de formataÃ§Ã£o
 1053 â”‚           return `VocÃª pode acessar [${key}](${platformLinks[key]})`;
 1054 â”‚         }
 1055 â”‚       }
 1056 â”‚       return match; // Se nÃ£o encontrou correspondÃªncia, mantÃ©m o texto original
 1057 â”‚     });
 1058 â”‚   }
 1059 â”‚ 
 1060 â”‚   // Verificar se o texto jÃ¡ contÃ©m links markdown
 1061 â”‚   const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
 1062 â”‚   const existingLinks = [];
 1063 â”‚   let match;
 1064 â”‚ 
 1065 â”‚   while ((match = markdownLinkRegex.exec(text)) !== null) {
 1066 â”‚     existingLinks.push({
 1067 â”‚       text: match[1],
 1068 â”‚       url: match[2],
 1069 â”‚       fullMatch: match[0]
 1070 â”‚     });
 1071 â”‚   }
 1072 â”‚ 
 1073 â”‚   // Depois, procurar menÃ§Ãµes a seÃ§Ãµes e converter para links (sÃ³ se nÃ£o forem jÃ¡ parte de um link)
 1074 â”‚   let newText = text;
 1075 â”‚ 
 1076 â”‚   // Aplicar substituiÃ§Ãµes de forma ordenada (das mais longas para as mais curtas)
 1077 â”‚   const orderedKeys = Object.keys(platformLinks).sort((a, b) => b.length - a.length);
 1078 â”‚ 
 1079 â”‚   for (const key of orderedKeys) {
 1080 â”‚     // Criar regex segura que nÃ£o captura dentro de links existentes
 1081 â”‚     const safeRegex = new RegExp(`(?<![\\[\\w])\\b(${escapeRegExp(key)})\\b(?![\\]\\w])`, 'g');
 1082 â”‚ 
 1083 â”‚     // Verificar cada ocorrÃªncia para garantir que nÃ£o estÃ¡ dentro de um link existente
 1084 â”‚     let lastIndex = 0;
 1085 â”‚     let result = '';
 1086 â”‚     let regexMatch;
 1087 â”‚ 
 1088 â”‚     while ((regexMatch = safeRegex.exec(newText)) !== null) {
 1089 â”‚       const matchStart = regexMatch.index;
 1090 â”‚       const matchEnd = matchStart + regexMatch[0].length;
 1091 â”‚ 
 1092 â”‚       // Verificar se esta ocorrÃªncia estÃ¡ dentro de algum link existente
 1093 â”‚       let isInsideExistingLink = false;
 1094 â”‚       for (const link of existingLinks) {
 1095 â”‚         const linkIndex = newText.indexOf(link.fullMatch);
 1096 â”‚         if (linkIndex <= matchStart && linkIndex + link.fullMatch.length >= matchEnd) {
 1097 â”‚           isInsideExistingLink = true;
 1098 â”‚           break;
 1099 â”‚         }
 1100 â”‚       }
 1101 â”‚ 
 1102 â”‚       if (!isInsideExistingLink) {
 1103 â”‚         result += newText.substring(lastIndex, matchStart);
 1104 â”‚         result += `[${regexMatch[1]}](${platformLinks[key]})`;
 1105 â”‚         lastIndex = matchEnd;
 1106 â”‚       }
 1107 â”‚     }
 1108 â”‚ 
 1109 â”‚     if (lastIndex > 0) {
 1110 â”‚       result += newText.substring(lastIndex);
 1111 â”‚       newText = result;
 1112 â”‚ 
 1113 â”‚       // Atualizar a lista de links existentes
 1114 â”‚       existingLinks.length = 0;
 1115 â”‚       while ((match = markdownLinkRegex.exec(newText)) !== null) {
 1116 â”‚         existingLinks.push({
 1117 â”‚           text: match[1],
 1118 â”‚           url: match[2],
 1119 â”‚           fullMatch: match[0]
 1120 â”‚         });
 1121 â”‚       }
 1122 â”‚     }
 1123 â”‚   }
 1124 â”‚ 
 1125 â”‚   // Remover qualquer formataÃ§Ã£o incorreta que possa ter sido introduzida
 1126 â”‚   newText = newText
 1127 â”‚     .replace(/\]\(\[/g, ']([') // Corrigir links aninhados
 1128 â”‚     .replace(/\]\(https:\/\/pontoschool\.com\/[a-z-]+\)\(https:\/\/pontoschool\.com\/[a-z-]+\)/g, match => {
 1129 â”‚       // Extrair o primeiro link vÃ¡lido
 1130 â”‚       const urlMatch = match.match(/\]\((https:\/\/pontoschool\.com\/[a-z-]+)\)/);
 1131 â”‚       if (urlMatch && urlMatch[1]) {
 1132 â”‚         return `](${urlMatch[1]})`;
 1133 â”‚       }
 1134 â”‚       return match;
 1135 â”‚     });
 1136 â”‚ 
 1137 â”‚   return newText;
 1138 â”‚ }
 1139 â”‚ 
 1140 â”‚ // FunÃ§Ã£o auxiliar para escapar caracteres especiais em regex
 1141 â”‚ function escapeRegExp(string) {
 1142 â”‚   return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 1143 â”‚ }
 1144 â”‚ 
 1145 â”‚ 
 1146 â”‚ // FunÃ§Ã£o para salvar o histÃ³rico da conversa no localStorage e sincronizar com Supabase
 1147 â”‚ async function saveConversationHistory(sessionId: string, history: ChatMessage[]): Promise<void> {
 1148 â”‚   try {
 1149 â”‚     if (!sessionId || !history) {
 1150 â”‚       console.error("Erro ao salvar histÃ³rico: sessionId ou history invÃ¡lidos");
 1151 â”‚       return;
 1152 â”‚     }
 1153 â”‚ 
 1154 â”‚     // Salvar localmente
 1155 â”‚     conversationHistory[sessionId] = history;
 1156 â”‚ 
 1157 â”‚     // Preparar o histÃ³rico para armazenamento (garantir que todos os objetos sÃ£o serializÃ¡veis)
 1158 â”‚     const serializableHistory = history.map(msg => ({
 1159 â”‚       role: msg.role,
 1160 â”‚       content: msg.content,
 1161 â”‚       timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1162 â”‚                 (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1163 â”‚     }));
 1164 â”‚ 
 1165 â”‚     try {
 1166 â”‚       // Salvar para o usuÃ¡rio atual com uma estrutura mais persistente
 1167 â”‚       // Usar formato conversationHistory_USER_ID_sessionId quando possÃ­vel
 1168 â”‚       let storageKey = `conversationHistory_${sessionId}`;
 1169 â”‚ 
 1170 â”‚       // Tentar obter dados de identificaÃ§Ã£o do usuÃ¡rio para melhor rastreamento
 1171 â”‚       try {
 1172 â”‚         const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
 1173 â”‚         const userId = sessionData?.session?.user?.id;
 1174 â”‚         if (userId) {
 1175 â”‚           storageKey = `conversationHistory_${userId}_${sessionId}`;
 1176 â”‚         }
 1177 â”‚       } catch (e) {
 1178 â”‚         console.log('Erro ao obter ID do usuÃ¡rio, usando chave padrÃ£o:', e);
 1179 â”‚       }
 1180 â”‚ 
 1181 â”‚       // Salvar com uma chave mais especÃ­fica para melhor identificaÃ§Ã£o
 1182 â”‚       localStorage.setItem(storageKey, JSON.stringify(serializableHistory));
 1183 â”‚ 
 1184 â”‚       // Para compatibilidade, tambÃ©m salvar com a chave antiga
 1185 â”‚       localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(serializableHistory));
 1186 â”‚ 
 1187 â”‚       // Manter um Ã­ndice de todas as conversas do usuÃ¡rio
 1188 â”‚       try {
 1189 â”‚         const userConversationsKey = 'userConversationsIndex';
 1190 â”‚         let conversationsIndex = {};
 1191 â”‚ 
 1192 â”‚         const savedIndex = localStorage.getItem(userConversationsKey);
 1193 â”‚         if (savedIndex) {
 1194 â”‚           conversationsIndex = JSON.parse(savedIndex);
 1195 â”‚         }
 1196 â”‚ 
 1197 â”‚         conversationsIndex[sessionId] = {
 1198 â”‚           lastUpdated: new Date().toISOString(),
 1199 â”‚           messageCount: serializableHistory.length,
 1200 â”‚           title: serializableHistory.length > 1 ? 
 1201 â”‚             serializableHistory[1].content.substring(0, 30) + "..." : 
 1202 â”‚             "Nova conversa"
 1203 â”‚         };
 1204 â”‚ 
 1205 â”‚         // Limitar o Ã­ndice a 50 conversas mais recentes
 1206 â”‚         const sortedEntries = Object.entries(conversationsIndex)
 1207 â”‚           .sort((a, b) => new Date(b[1].lastUpdated).getTime() - new Date(a[1].lastUpdated).getTime())
 1208 â”‚           .slice(0, 50);
 1209 â”‚ 
 1210 â”‚         const trimmedIndex = {};
 1211 â”‚         sortedEntries.forEach(([key, value]) => {
 1212 â”‚           trimmedIndex[key] = value;
 1213 â”‚         });
 1214 â”‚ 
 1215 â”‚         localStorage.setItem(userConversationsKey, JSON.stringify(trimmedIndex));
 1216 â”‚       } catch (indexError) {
 1217 â”‚         console.error("Erro ao atualizar Ã­ndice de conversas:", indexError);
 1218 â”‚       }
 1219 â”‚ 
 1220 â”‚       // Salvar todas as sessÃµes em um Ãºnico item no localStorage com limite de tamanho
 1221 â”‚       try {
 1222 â”‚         const allSessions = {};
 1223 â”‚         // SÃ³ armazenar as Ãºltimas 20 sessÃµes
 1224 â”‚         const sessionIds = Object.keys(conversationHistory).slice(-20);
 1225 â”‚ 
 1226 â”‚         for (const id of sessionIds) {
 1227 â”‚           const sessionHistory = conversationHistory[id];
 1228 â”‚           if (sessionHistory && sessionHistory.length > 0) {
 1229 â”‚             // Limitar cada sessÃ£o a 100 mensagens para melhor contexto
 1230 â”‚             allSessions[id] = sessionHistory.slice(-100).map(msg => ({
 1231 â”‚               role: msg.role,
 1232 â”‚               content: msg.content,
 1233 â”‚               timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1234 â”‚                         (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1235 â”‚             }));
 1236 â”‚           }
 1237 â”‚         }
 1238 â”‚ 
 1239 â”‚         localStorage.setItem('aiChatSessions', JSON.stringify(allSessions));
 1240 â”‚       } catch (batchSaveError) {
 1241 â”‚         console.error("Erro ao salvar todas as sessÃµes:", batchSaveError);
 1242 â”‚       }
 1243 â”‚     } catch (localStorageError) {
 1244 â”‚       console.error("Erro ao salvar no localStorage:", localStorageError);
 1245 â”‚       // Se falhar por exceder o limite, limpar o localStorage e tentar novamente sÃ³ com a sessÃ£o atual
 1246 â”‚       try {
 1247 â”‚         localStorage.removeItem('aiChatSessions');
 1248 â”‚         localStorage.setItem(`conversationHistory_${sessionId}`, 
 1249 â”‚           JSON.stringify(serializableHistory.slice(-50))); // Salvar sÃ³ as Ãºltimas 50 mensagens
 1250 â”‚       } catch (retryError) {
 1251 â”‚         console.error("Falha na segunda tentativa de salvar no localStorage:", retryError);
 1252 â”‚       }
 1253 â”‚     }
 1254 â”‚ 
 1255 â”‚     // Sincronizar com Supabase se disponÃ­vel
 1256 â”‚     try {
 1257 â”‚       const supabase = (await import('@/lib/supabase')).supabase;
 1258 â”‚       const { data: sessionData } = await supabase.auth.getSession();
 1259 â”‚       const userId = sessionData?.session?.user?.id;
 1260 â”‚ 
 1261 â”‚       if (userId) {
 1262 â”‚         try {
 1263 â”‚           // Criar tabela ai_chat_history se nÃ£o existir (verificar primeiro)
 1264 â”‚           const { data: tablesData } = await supabase
 1265 â”‚             .from('information_schema.tables')
 1266 â”‚             .select('table_name')
 1267 â”‚             .eq('table_schema', 'public')
 1268 â”‚             .eq('table_name', 'ai_chat_history');
 1269 â”‚ 
 1270 â”‚           if (!tablesData || tablesData.length === 0) {
 1271 â”‚             // Tabela nÃ£o existe, tentar criar usando rpc
 1272 â”‚             try {
 1273 â”‚               await supabase.rpc('execute_sql', {
 1274 â”‚                 sql_statement: `
 1275 â”‚                   CREATE TABLE IF NOT EXISTS public.ai_chat_history (
 1276 â”‚                     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
 1277 â”‚                     user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
 1278 â”‚                     session_id TEXT NOT NULL,
 1279 â”‚                     messages JSONB NOT NULL DEFAULT '[]'::jsonb,
 1280 â”‚                     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1281 â”‚                     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1282 â”‚                     UNIQUE (user_id, session_id)
 1283 â”‚                   );
 1284 â”‚ 
 1285 â”‚                   CREATE INDEX IF NOT EXISTS ai_chat_history_user_id_idx ON public.ai_chat_history(user_id);
 1286 â”‚                   CREATE INDEX IF NOT EXISTS ai_chat_history_session_id_idx ON public.ai_chat_history(session_id);
 1287 â”‚                 `
 1288 â”‚               });
 1289 â”‚             } catch (createTableError) {
 1290 â”‚               console.log('Erro ao criar tabela ai_chat_history:', createTableError);
 1291 â”‚             }
 1292 â”‚           }
 1293 â”‚ 
 1294 â”‚           // Upsert do histÃ³rico da conversa
 1295 â”‚           const { error } = await supabase
 1296 â”‚             .from('ai_chat_history')
 1297 â”‚             .upsert({
 1298 â”‚               user_id: userId,
 1299 â”‚               session_id: sessionId,
 1300 â”‚               messages: serializableHistory.slice(-100), // Armazenar atÃ© 100 mensagens
 1301 â”‚               updated_at: new Date().toISOString()
 1302 â”‚             }, {
 1303 â”‚               onConflict: 'user_id,session_id'
 1304 â”‚             });
 1305 â”‚ 
 1306 â”‚           if (error) {
 1307 â”‚             console.error("Erro ao sincronizar histÃ³rico com Supabase:", error);
 1308 â”‚           }
 1309 â”‚         } catch (upsertError) {
 1310 â”‚           console.error("Erro no upsert do histÃ³rico:", upsertError);
 1311 â”‚         }
 1312 â”‚       }
 1313 â”‚     } catch (syncError) {
 1314 â”‚       console.log("Supabase nÃ£o disponÃ­vel para sincronizaÃ§Ã£o:", syncError);
 1315 â”‚     }
 1316 â”‚   } catch (error) {
 1317 â”‚     console.error("Erro ao salvar o histÃ³rico da conversa:", error);
 1318 â”‚   }
 1319 â”‚ }
 1320 â”‚ 
 1321 â”‚ // SimulaÃ§Ã£o de resposta da IA
 1322 â”‚ const getResponseForMessage = (message: string): string => {
 1323 â”‚   // AnÃ¡lise bÃ¡sica da mensagem para gerar uma resposta contextual
 1324 â”‚   const formattedMessage = message.toLowerCase();
 1325 â”‚ 
 1326 â”‚   if (formattedMessage.includes('olÃ¡') || formattedMessage.includes('oi') || formattedMessage.includes('bom dia') || formattedMessage.includes('boa tarde') || formattedMessage.includes('boa noite')) {
 1327 â”‚     return `**OlÃ¡, ${userInfo?.username || 'amigo'}!** ğŸ˜Š\n\nComo posso ajudar vocÃª hoje?`;
 1328 â”‚   } else if (formattedMessage.includes('funÃ§Ã£o') || formattedMessage.includes('o que vocÃª faz') || formattedMessage.includes('para que serve')) {
 1329 â”‚     return `**Eu sou Epictus IA**, seu assistente para a plataforma Ponto.School! ğŸš€\n\nPosso ajudar com:\n\nâ€¢ **InformaÃ§Ãµes** sobre cursos e conteÃºdos\nâ€¢ **Dicas de estudos** personalizadas\nâ€¢ **NavegaÃ§Ã£o** na plataforma\nâ€¢ **Respostas** para dÃºvidas gerais\n\nComo posso ajudar vocÃª agora?`;
 1330 â”‚   } else if (formattedMessage.includes('portal') || formattedMessage.includes('material') || formattedMessage.includes('acessar conteÃºdo')) {
 1331 â”‚     return `VocÃª pode acessar o **Portal** com todos os materiais em https://pontoschool.com/portal\n\nLÃ¡ vocÃª encontrarÃ¡ todos os seus cursos, materiais e recursos de estudo organizados por disciplina.\n\n_Basta clicar no link acima para ir direto para o Portal!_ ğŸ“š`;
 1332 â”‚   } else {
 1333 â”‚     return "Desculpe, nÃ£o entendi sua pergunta. Pode reformulÃ¡-la?";
 1334 â”‚   }
 1335 â”‚ };
 1336 â”‚ 
 1337 â”‚ import { supabase } from "@/lib/supabase";
 1338 â”‚ import * as aiChatDB from "./aiChatDatabaseService";
 1339 â”‚ 
 1340 â”‚ interface ChatMessage {
 1341 â”‚   role: 'system' | 'user' | 'assistant';
 1342 â”‚   content: string;
 1343 â”‚ }
 1344 â”‚ 
 1345 â”‚ // Armazenamento temporÃ¡rio de histÃ³rico de chat no navegador
 1346 â”‚ const conversationHistory: Record<string, ChatMessage[]> = {};
      Â·       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Â·                â•°â”€â”€ `conversationHistory` redefined here
 1347 â”‚ 
 1348 â”‚ // Limpar histÃ³rico de conversa especÃ­fica
 1349 â”‚ export const clearConversationHistory = (sessionId: string) => {
      â•°â”€â”€â”€â”€

  Ã— the name `clearConversationHistory` is defined multiple times
      â•­â”€[/home/runner/workspace/src/services/aiChatService.ts:783:1]
  783 â”‚ }
  784 â”‚ 
  785 â”‚ // Limpar histÃ³rico da conversa
  786 â”‚ export function clearConversationHistory(sessionId: string): void {
      Â·                 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Â·                             â•°â”€â”€ previous definition of `clearConversationHistory` here
  787 â”‚   if (conversationHistory[sessionId]) {
  788 â”‚     // MantÃ©m apenas a mensagem do sistema
  789 â”‚     const systemMessage = conversationHistory[sessionId][0];
  790 â”‚     conversationHistory[sessionId] = [systemMessage];
  791 â”‚ 
  792 â”‚     // Limpar do localStorage tambÃ©m
  793 â”‚     try {
  794 â”‚       localStorage.removeItem(`conversationHistory_${sessionId}`);
  795 â”‚     } catch (error) {
  796 â”‚       console.error("Erro ao limpar histÃ³rico do localStorage:", error);
  797 â”‚     }
  798 â”‚   }
  799 â”‚ }
  800 â”‚ 
  801 â”‚ // Obter histÃ³rico da conversa
  802 â”‚ export async function getConversationHistory(sessionId: string): Promise<ChatMessage[]> {
  803 â”‚   try {
  804 â”‚     // Primeiro verifica se jÃ¡ estÃ¡ carregado na memÃ³ria e Ã© vÃ¡lido
  805 â”‚     if (conversationHistory[sessionId] && Array.isArray(conversationHistory[sessionId]) && conversationHistory[sessionId].length > 0) {
  806 â”‚       // Verifica se hÃ¡ ao menos uma mensagem do sistema
  807 â”‚       const hasSystemMessage = conversationHistory[sessionId].some(msg => msg.role === 'system');
  808 â”‚ 
  809 â”‚       if (hasSystemMessage) {
  810 â”‚         return conversationHistory[sessionId];
  811 â”‚       }
  812 â”‚     }
  813 â”‚ 
  814 â”‚     // Tenta buscar dados adicionais do usuÃ¡rio para melhor armazenamento
  815 â”‚     let userIdForStorage = '';
  816 â”‚     try {
  817 â”‚       const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
  818 â”‚       userIdForStorage = sessionData?.session?.user?.id || '';
  819 â”‚     } catch (e) {
  820 â”‚       console.log('Erro ao obter ID do usuÃ¡rio:', e);
  821 â”‚     }
  822 â”‚ 
  823 â”‚     // Tenta recuperar do localStorage usando vÃ¡rios formatos de chave
  824 â”‚     const possibleKeys = [
  825 â”‚       `conversationHistory_${sessionId}`,
  826 â”‚       userIdForStorage ? `conversationHistory_${userIdForStorage}_${sessionId}` : null,
  827 â”‚       `chat_history_${sessionId}`
  828 â”‚     ].filter(Boolean);
  829 â”‚ 
  830 â”‚     let retrievedHistory = null;
  831 â”‚ 
  832 â”‚     // Tentar cada uma das possÃ­veis chaves
  833 â”‚     for (const key of possibleKeys) {
  834 â”‚       try {
  835 â”‚         const savedHistory = localStorage.getItem(key);
  836 â”‚         if (savedHistory) {
  837 â”‚           try {
  838 â”‚             const parsedHistory = JSON.parse(savedHistory);
  839 â”‚             if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
  840 â”‚               retrievedHistory = parsedHistory;
  841 â”‚               console.log(`HistÃ³rico recuperado com sucesso usando a chave: ${key}`);
  842 â”‚               break;
  843 â”‚             }
  844 â”‚           } catch (parseError) {
  845 â”‚             console.error(`Erro ao analisar histÃ³rico usando a chave ${key}:`, parseError);
  846 â”‚           }
  847 â”‚         }
  848 â”‚       } catch (e) {
  849 â”‚         console.error(`Erro ao tentar acessar o localStorage com a chave ${key}:`, e);
  850 â”‚       }
  851 â”‚     }
  852 â”‚ 
  853 â”‚     // Se encontrou histÃ³rico no localStorage
  854 â”‚     if (retrievedHistory) {
  855 â”‚       // Converter timestamps de string para Date e garantir formato adequado
  856 â”‚       const processedHistory = retrievedHistory.map(msg => ({
  857 â”‚         role: msg.role || 'user',
  858 â”‚         content: msg.content || '',
  859 â”‚         timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  860 â”‚       }));
  861 â”‚ 
  862 â”‚       // Verificar se hÃ¡ mensagem do sistema
  863 â”‚       const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  864 â”‚ 
  865 â”‚       if (!hasSystemMessage) {
  866 â”‚         // Se nÃ£o tiver mensagem do sistema, inicializar com uma nova
  867 â”‚         const userContext = await getUserContext();
  868 â”‚         initializeConversationHistory(sessionId, userContext);
  869 â”‚ 
  870 â”‚         // Adicionar as mensagens existentes (exceto mensagens do sistema jÃ¡ existentes)
  871 â”‚         conversationHistory[sessionId] = [
  872 â”‚           ...conversationHistory[sessionId],
  873 â”‚           ...processedHistory.filter(msg => msg.role !== 'system')
  874 â”‚         ];
  875 â”‚       } else {
  876 â”‚         conversationHistory[sessionId] = processedHistory;
  877 â”‚       }
  878 â”‚ 
  879 â”‚       return conversationHistory[sessionId];
  880 â”‚     }
  881 â”‚ 
  882 â”‚     // Se nÃ£o encontrou no localStorage, tenta recuperar do Supabase
  883 â”‚     try {
  884 â”‚       const supabase = (await import('@/lib/supabase')).supabase;
  885 â”‚       const { data: sessionData } = await supabase.auth.getSession();
  886 â”‚       const userId = sessionData?.session?.user?.id;
  887 â”‚ 
  888 â”‚       if (userId) {
  889 â”‚         try {
  890 â”‚           // Verificar se a tabela existe antes de tentar consultar
  891 â”‚           try {
  892 â”‚             const { data: tableExists } = await supabase
  893 â”‚               .from('information_schema.tables')
  894 â”‚               .select('table_name')
  895 â”‚               .eq('table_schema', 'public')
  896 â”‚               .eq('table_name', 'ai_chat_history')
  897 â”‚               .single();
  898 â”‚ 
  899 â”‚             if (!tableExists) {
  900 â”‚               console.log('Tabela ai_chat_history nÃ£o existe no Supabase.');
  901 â”‚               throw new Error('Tabela nÃ£o existe');
  902 â”‚             }
  903 â”‚           } catch (tableCheckError) {
  904 â”‚             console.log('Erro ao verificar existÃªncia da tabela:', tableCheckError);
  905 â”‚             throw tableCheckError;
  906 â”‚           }
  907 â”‚ 
  908 â”‚           const { data, error } = await supabase
  909 â”‚             .from('ai_chat_history')
  910 â”‚             .select('messages')
  911 â”‚             .eq('user_id', userId)
  912 â”‚             .eq('session_id', sessionId)
  913 â”‚             .single();
  914 â”‚ 
  915 â”‚           if (error) {
  916 â”‚             console.error('Erro ao buscar histÃ³rico do Supabase:', error);
  917 â”‚             throw error;
  918 â”‚           }
  919 â”‚ 
  920 â”‚           if (data?.messages && Array.isArray(data.messages) && data.messages.length > 0) {
  921 â”‚             // Converter timestamps de string para Date
  922 â”‚             const processedHistory = data.messages.map(msg => ({
  923 â”‚               role: msg.role || 'user',
  924 â”‚               content: msg.content || '',
  925 â”‚               timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  926 â”‚             }));
  927 â”‚ 
  928 â”‚             // Verificar se hÃ¡ mensagem do sistema
  929 â”‚             const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  930 â”‚ 
  931 â”‚             if (!hasSystemMessage) {
  932 â”‚               // Se nÃ£o tiver mensagem do sistema, inicializar com uma nova
  933 â”‚               const userContext = await getUserContext();
  934 â”‚               initializeConversationHistory(sessionId, userContext);
  935 â”‚ 
  936 â”‚               // Adicionar as mensagens existentes
  937 â”‚               conversationHistory[sessionId] = [
  938 â”‚                 ...conversationHistory[sessionId],
  939 â”‚                 ...processedHistory.filter(msg => msg.role !== 'system')
  940 â”‚               ];
  941 â”‚             } else {
  942 â”‚               conversationHistory[sessionId] = processedHistory;
  943 â”‚             }
  944 â”‚ 
  945 â”‚             // Atualizar localStorage para sincronizaÃ§Ã£o
  946 â”‚             try {
  947 â”‚               localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(conversationHistory[sessionId]));
  948 â”‚ 
  949 â”‚               // Se temos o userId, tambÃ©m armazenar com chave mais especÃ­fica
  950 â”‚               if (userId) {
  951 â”‚                 localStorage.setItem(`conversationHistory_${userId}_${sessionId}`, 
  952 â”‚                   JSON.stringify(conversationHistory[sessionId]));
  953 â”‚               }
  954 â”‚             } catch (localStorageError) {
  955 â”‚               console.log("Erro ao atualizar localStorage:", localStorageError);
  956 â”‚             }
  957 â”‚ 
  958 â”‚             return conversationHistory[sessionId];
  959 â”‚           }
  960 â”‚         } catch (supabaseError) {
  961 â”‚           console.error("Erro ao recuperar histÃ³rico do Supabase:", supabaseError);
  962 â”‚         }
  963 â”‚       }
  964 â”‚     } catch (dbError) {
  965 â”‚       console.error("Erro ao tentar acessar o banco de dados:", dbError);
  966 â”‚     }
  967 â”‚ 
  968 â”‚     // Se chegou aqui, nÃ£o foi possÃ­vel recuperar o histÃ³rico
  969 â”‚     // Inicializar com novo histÃ³rico
  970 â”‚     console.log("Criando novo histÃ³rico de conversa para a sessÃ£o:", sessionId);
  971 â”‚     const userContext = await getUserContext();
  972 â”‚     initializeConversationHistory(sessionId, userContext);
  973 â”‚ 
  974 â”‚     // Salvar o histÃ³rico inicial
  975 â”‚     try {
  976 â”‚       localStorage.setItem(`conversationHistory_${sessionId}`, 
  977 â”‚         JSON.stringify(conversationHistory[sessionId]));
  978 â”‚ 
  979 â”‚       // Se temos userIdForStorage, tambÃ©m armazenar com chave mais especÃ­fica
  980 â”‚       if (userIdForStorage) {
  981 â”‚         localStorage.setItem(`conversationHistory_${userIdForStorage}_${sessionId}`, 
  982 â”‚           JSON.stringify(conversationHistory[sessionId]));
  983 â”‚       }
  984 â”‚     } catch (e) {
  985 â”‚       console.error("Erro ao salvar histÃ³rico inicial:", e);
  986 â”‚     }
  987 â”‚ 
  988 â”‚     return conversationHistory[sessionId];
  989 â”‚   } catch (generalError) {
  990 â”‚     console.error("Erro geral ao obter histÃ³rico de conversa:", generalError);
  991 â”‚ 
  992 â”‚     // Retornar um histÃ³rico vazio em Ãºltimo caso
  993 â”‚     return [{
  994 â”‚       role: 'system',
  995 â”‚       content: 'VocÃª Ã© o Epictus IA, o assistente inteligente da Ponto.School.',
  996 â”‚       timestamp: new Date()
  997 â”‚     }];
  998 â”‚   }
  999 â”‚ }
 1000 â”‚ 
 1001 â”‚ // FunÃ§Ã£o para corrigir links da plataforma
 1002 â”‚ function fixPlatformLinks(text: string): string {
 1003 â”‚   const platformLinks = {
 1004 â”‚     'Portal de Estudos': 'https://pontoschool.com/portal',
 1005 â”‚     'Portal': 'https://pontoschool.com/portal',
 1006 â”‚     'Agenda': 'https://pontoschool.com/agenda',
 1007 â”‚     'Turmas': 'https://pontoschool.com/turmas',
 1008 â”‚     'Biblioteca': 'https://pontoschool.com/biblioteca',
 1009 â”‚     'Perfil': 'https://pontoschool.com/profile',
 1010 â”‚     'Meu Perfil': 'https://pontoschool.com/profile',
 1011 â”‚     'ConfiguraÃ§Ãµes': 'https://pontoschool.com/configuracoes',
 1012 â”‚     'Minhas ConfiguraÃ§Ãµes': 'https://pontoschool.com/configuracoes',
 1013 â”‚     'Dashboard': 'https://pontoschool.com/dashboard',
 1014 â”‚     'Epictus IA': 'https://pontoschool.com/epictus-ia',
 1015 â”‚     'Mentor IA': 'https://pontoschool.com/mentor-ia',
 1016 â”‚     'Planos de Estudo': 'https://pontoschool.com/planos-estudo',
 1017 â”‚     'Plano de Estudos': 'https://pontoschool.com/planos-estudo',
 1018 â”‚     'Conquistas': 'https://pontoschool.com/conquistas',
 1019 â”‚     'Minhas Conquistas': 'https://pontoschool.com/conquistas',
 1020 â”‚     'Carteira': 'https://pontoschool.com/carteira',
 1021 â”‚     'Minha Carteira': 'https://pontoschool.com/carteira',
 1022 â”‚     'Mercado': 'https://pontoschool.com/mercado',
 1023 â”‚     'OrganizaÃ§Ã£o': 'https://pontoschool.com/organizacao',
 1024 â”‚     'Comunidades': 'https://pontoschool.com/comunidades',
 1025 â”‚     'Chat IA': 'https://pontoschool.com/chat-ia',
 1026 â”‚     'School IA': 'https://pontoschool.com/school-ia',
 1027 â”‚     'Novidades': 'https://pontoschool.com/novidades',
 1028 â”‚     'Lembretes': 'https://pontoschool.com/lembretes',
 1029 â”‚     'Pedidos de Ajuda': 'https://pontoschool.com/pedidos-ajuda',
 1030 â”‚     'Estudos': 'https://pontoschool.com/estudos'
 1031 â”‚   };
 1032 â”‚ 
 1033 â”‚   // Primeiro, procura por textos especÃ­ficos que pedem redirecionamento
 1034 â”‚   const redirectPatterns = [
 1035 â”‚     /(?:me\s+(?:redirecione|encaminhe|leve|direcione|mande|envie)\s+(?:para|ao|Ã |a|atÃ©))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1036 â”‚     /(?:quero\s+(?:ir|acessar|entrar|ver))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1037 â”‚     /(?:me\s+(?:mostre|mostra))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1038 â”‚     /(?:abrir?|abra|acesse|acessar|ver|veja)\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi
 1039 â”‚   ];
 1040 â”‚ 
 1041 â”‚   // Aplicar padrÃµes de redirecionamento de forma mais robusta
 1042 â”‚   for (const pattern of redirectPatterns) {
 1043 â”‚     text = text.replace(pattern, (match, sectionName) => {
 1044 â”‚       if (!sectionName) return match;
 1045 â”‚ 
 1046 â”‚       const normalizedName = sectionName.trim();
 1047 â”‚       // Verificar se o nome normalizado corresponde a alguma chave do objeto platformLinks
 1048 â”‚       for (const key in platformLinks) {
 1049 â”‚         if (normalizedName.toLowerCase() === key.toLowerCase() || 
 1050 â”‚             key.toLowerCase().includes(normalizedName.toLowerCase()) || 
 1051 â”‚             normalizedName.toLowerCase().includes(key.toLowerCase())) {
 1052 â”‚           // Criar link em formato seguro sem possÃ­veis bugs de formataÃ§Ã£o
 1053 â”‚           return `VocÃª pode acessar [${key}](${platformLinks[key]})`;
 1054 â”‚         }
 1055 â”‚       }
 1056 â”‚       return match; // Se nÃ£o encontrou correspondÃªncia, mantÃ©m o texto original
 1057 â”‚     });
 1058 â”‚   }
 1059 â”‚ 
 1060 â”‚   // Verificar se o texto jÃ¡ contÃ©m links markdown
 1061 â”‚   const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
 1062 â”‚   const existingLinks = [];
 1063 â”‚   let match;
 1064 â”‚ 
 1065 â”‚   while ((match = markdownLinkRegex.exec(text)) !== null) {
 1066 â”‚     existingLinks.push({
 1067 â”‚       text: match[1],
 1068 â”‚       url: match[2],
 1069 â”‚       fullMatch: match[0]
 1070 â”‚     });
 1071 â”‚   }
 1072 â”‚ 
 1073 â”‚   // Depois, procurar menÃ§Ãµes a seÃ§Ãµes e converter para links (sÃ³ se nÃ£o forem jÃ¡ parte de um link)
 1074 â”‚   let newText = text;
 1075 â”‚ 
 1076 â”‚   // Aplicar substituiÃ§Ãµes de forma ordenada (das mais longas para as mais curtas)
 1077 â”‚   const orderedKeys = Object.keys(platformLinks).sort((a, b) => b.length - a.length);
 1078 â”‚ 
 1079 â”‚   for (const key of orderedKeys) {
 1080 â”‚     // Criar regex segura que nÃ£o captura dentro de links existentes
 1081 â”‚     const safeRegex = new RegExp(`(?<![\\[\\w])\\b(${escapeRegExp(key)})\\b(?![\\]\\w])`, 'g');
 1082 â”‚ 
 1083 â”‚     // Verificar cada ocorrÃªncia para garantir que nÃ£o estÃ¡ dentro de um link existente
 1084 â”‚     let lastIndex = 0;
 1085 â”‚     let result = '';
 1086 â”‚     let regexMatch;
 1087 â”‚ 
 1088 â”‚     while ((regexMatch = safeRegex.exec(newText)) !== null) {
 1089 â”‚       const matchStart = regexMatch.index;
 1090 â”‚       const matchEnd = matchStart + regexMatch[0].length;
 1091 â”‚ 
 1092 â”‚       // Verificar se esta ocorrÃªncia estÃ¡ dentro de algum link existente
 1093 â”‚       let isInsideExistingLink = false;
 1094 â”‚       for (const link of existingLinks) {
 1095 â”‚         const linkIndex = newText.indexOf(link.fullMatch);
 1096 â”‚         if (linkIndex <= matchStart && linkIndex + link.fullMatch.length >= matchEnd) {
 1097 â”‚           isInsideExistingLink = true;
 1098 â”‚           break;
 1099 â”‚         }
 1100 â”‚       }
 1101 â”‚ 
 1102 â”‚       if (!isInsideExistingLink) {
 1103 â”‚         result += newText.substring(lastIndex, matchStart);
 1104 â”‚         result += `[${regexMatch[1]}](${platformLinks[key]})`;
 1105 â”‚         lastIndex = matchEnd;
 1106 â”‚       }
 1107 â”‚     }
 1108 â”‚ 
 1109 â”‚     if (lastIndex > 0) {
 1110 â”‚       result += newText.substring(lastIndex);
 1111 â”‚       newText = result;
 1112 â”‚ 
 1113 â”‚       // Atualizar a lista de links existentes
 1114 â”‚       existingLinks.length = 0;
 1115 â”‚       while ((match = markdownLinkRegex.exec(newText)) !== null) {
 1116 â”‚         existingLinks.push({
 1117 â”‚           text: match[1],
 1118 â”‚           url: match[2],
 1119 â”‚           fullMatch: match[0]
 1120 â”‚         });
 1121 â”‚       }
 1122 â”‚     }
 1123 â”‚   }
 1124 â”‚ 
 1125 â”‚   // Remover qualquer formataÃ§Ã£o incorreta que possa ter sido introduzida
 1126 â”‚   newText = newText
 1127 â”‚     .replace(/\]\(\[/g, ']([') // Corrigir links aninhados
 1128 â”‚     .replace(/\]\(https:\/\/pontoschool\.com\/[a-z-]+\)\(https:\/\/pontoschool\.com\/[a-z-]+\)/g, match => {
 1129 â”‚       // Extrair o primeiro link vÃ¡lido
 1130 â”‚       const urlMatch = match.match(/\]\((https:\/\/pontoschool\.com\/[a-z-]+)\)/);
 1131 â”‚       if (urlMatch && urlMatch[1]) {
 1132 â”‚         return `](${urlMatch[1]})`;
 1133 â”‚       }
 1134 â”‚       return match;
 1135 â”‚     });
 1136 â”‚ 
 1137 â”‚   return newText;
 1138 â”‚ }
 1139 â”‚ 
 1140 â”‚ // FunÃ§Ã£o auxiliar para escapar caracteres especiais em regex
 1141 â”‚ function escapeRegExp(string) {
 1142 â”‚   return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 1143 â”‚ }
 1144 â”‚ 
 1145 â”‚ 
 1146 â”‚ // FunÃ§Ã£o para salvar o histÃ³rico da conversa no localStorage e sincronizar com Supabase
 1147 â”‚ async function saveConversationHistory(sessionId: string, history: ChatMessage[]): Promise<void> {
 1148 â”‚   try {
 1149 â”‚     if (!sessionId || !history) {
 1150 â”‚       console.error("Erro ao salvar histÃ³rico: sessionId ou history invÃ¡lidos");
 1151 â”‚       return;
 1152 â”‚     }
 1153 â”‚ 
 1154 â”‚     // Salvar localmente
 1155 â”‚     conversationHistory[sessionId] = history;
 1156 â”‚ 
 1157 â”‚     // Preparar o histÃ³rico para armazenamento (garantir que todos os objetos sÃ£o serializÃ¡veis)
 1158 â”‚     const serializableHistory = history.map(msg => ({
 1159 â”‚       role: msg.role,
 1160 â”‚       content: msg.content,
 1161 â”‚       timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1162 â”‚                 (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1163 â”‚     }));
 1164 â”‚ 
 1165 â”‚     try {
 1166 â”‚       // Salvar para o usuÃ¡rio atual com uma estrutura mais persistente
 1167 â”‚       // Usar formato conversationHistory_USER_ID_sessionId quando possÃ­vel
 1168 â”‚       let storageKey = `conversationHistory_${sessionId}`;
 1169 â”‚ 
 1170 â”‚       // Tentar obter dados de identificaÃ§Ã£o do usuÃ¡rio para melhor rastreamento
 1171 â”‚       try {
 1172 â”‚         const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
 1173 â”‚         const userId = sessionData?.session?.user?.id;
 1174 â”‚         if (userId) {
 1175 â”‚           storageKey = `conversationHistory_${userId}_${sessionId}`;
 1176 â”‚         }
 1177 â”‚       } catch (e) {
 1178 â”‚         console.log('Erro ao obter ID do usuÃ¡rio, usando chave padrÃ£o:', e);
 1179 â”‚       }
 1180 â”‚ 
 1181 â”‚       // Salvar com uma chave mais especÃ­fica para melhor identificaÃ§Ã£o
 1182 â”‚       localStorage.setItem(storageKey, JSON.stringify(serializableHistory));
 1183 â”‚ 
 1184 â”‚       // Para compatibilidade, tambÃ©m salvar com a chave antiga
 1185 â”‚       localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(serializableHistory));
 1186 â”‚ 
 1187 â”‚       // Manter um Ã­ndice de todas as conversas do usuÃ¡rio
 1188 â”‚       try {
 1189 â”‚         const userConversationsKey = 'userConversationsIndex';
 1190 â”‚         let conversationsIndex = {};
 1191 â”‚ 
 1192 â”‚         const savedIndex = localStorage.getItem(userConversationsKey);
 1193 â”‚         if (savedIndex) {
 1194 â”‚           conversationsIndex = JSON.parse(savedIndex);
 1195 â”‚         }
 1196 â”‚ 
 1197 â”‚         conversationsIndex[sessionId] = {
 1198 â”‚           lastUpdated: new Date().toISOString(),
 1199 â”‚           messageCount: serializableHistory.length,
 1200 â”‚           title: serializableHistory.length > 1 ? 
 1201 â”‚             serializableHistory[1].content.substring(0, 30) + "..." : 
 1202 â”‚             "Nova conversa"
 1203 â”‚         };
 1204 â”‚ 
 1205 â”‚         // Limitar o Ã­ndice a 50 conversas mais recentes
 1206 â”‚         const sortedEntries = Object.entries(conversationsIndex)
 1207 â”‚           .sort((a, b) => new Date(b[1].lastUpdated).getTime() - new Date(a[1].lastUpdated).getTime())
 1208 â”‚           .slice(0, 50);
 1209 â”‚ 
 1210 â”‚         const trimmedIndex = {};
 1211 â”‚         sortedEntries.forEach(([key, value]) => {
 1212 â”‚           trimmedIndex[key] = value;
 1213 â”‚         });
 1214 â”‚ 
 1215 â”‚         localStorage.setItem(userConversationsKey, JSON.stringify(trimmedIndex));
 1216 â”‚       } catch (indexError) {
 1217 â”‚         console.error("Erro ao atualizar Ã­ndice de conversas:", indexError);
 1218 â”‚       }
 1219 â”‚ 
 1220 â”‚       // Salvar todas as sessÃµes em um Ãºnico item no localStorage com limite de tamanho
 1221 â”‚       try {
 1222 â”‚         const allSessions = {};
 1223 â”‚         // SÃ³ armazenar as Ãºltimas 20 sessÃµes
 1224 â”‚         const sessionIds = Object.keys(conversationHistory).slice(-20);
 1225 â”‚ 
 1226 â”‚         for (const id of sessionIds) {
 1227 â”‚           const sessionHistory = conversationHistory[id];
 1228 â”‚           if (sessionHistory && sessionHistory.length > 0) {
 1229 â”‚             // Limitar cada sessÃ£o a 100 mensagens para melhor contexto
 1230 â”‚             allSessions[id] = sessionHistory.slice(-100).map(msg => ({
 1231 â”‚               role: msg.role,
 1232 â”‚               content: msg.content,
 1233 â”‚               timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1234 â”‚                         (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1235 â”‚             }));
 1236 â”‚           }
 1237 â”‚         }
 1238 â”‚ 
 1239 â”‚         localStorage.setItem('aiChatSessions', JSON.stringify(allSessions));
 1240 â”‚       } catch (batchSaveError) {
 1241 â”‚         console.error("Erro ao salvar todas as sessÃµes:", batchSaveError);
 1242 â”‚       }
 1243 â”‚     } catch (localStorageError) {
 1244 â”‚       console.error("Erro ao salvar no localStorage:", localStorageError);
 1245 â”‚       // Se falhar por exceder o limite, limpar o localStorage e tentar novamente sÃ³ com a sessÃ£o atual
 1246 â”‚       try {
 1247 â”‚         localStorage.removeItem('aiChatSessions');
 1248 â”‚         localStorage.setItem(`conversationHistory_${sessionId}`, 
 1249 â”‚           JSON.stringify(serializableHistory.slice(-50))); // Salvar sÃ³ as Ãºltimas 50 mensagens
 1250 â”‚       } catch (retryError) {
 1251 â”‚         console.error("Falha na segunda tentativa de salvar no localStorage:", retryError);
 1252 â”‚       }
 1253 â”‚     }
 1254 â”‚ 
 1255 â”‚     // Sincronizar com Supabase se disponÃ­vel
 1256 â”‚     try {
 1257 â”‚       const supabase = (await import('@/lib/supabase')).supabase;
 1258 â”‚       const { data: sessionData } = await supabase.auth.getSession();
 1259 â”‚       const userId = sessionData?.session?.user?.id;
 1260 â”‚ 
 1261 â”‚       if (userId) {
 1262 â”‚         try {
 1263 â”‚           // Criar tabela ai_chat_history se nÃ£o existir (verificar primeiro)
 1264 â”‚           const { data: tablesData } = await supabase
 1265 â”‚             .from('information_schema.tables')
 1266 â”‚             .select('table_name')
 1267 â”‚             .eq('table_schema', 'public')
 1268 â”‚             .eq('table_name', 'ai_chat_history');
 1269 â”‚ 
 1270 â”‚           if (!tablesData || tablesData.length === 0) {
 1271 â”‚             // Tabela nÃ£o existe, tentar criar usando rpc
 1272 â”‚             try {
 1273 â”‚               await supabase.rpc('execute_sql', {
 1274 â”‚                 sql_statement: `
 1275 â”‚                   CREATE TABLE IF NOT EXISTS public.ai_chat_history (
 1276 â”‚                     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
 1277 â”‚                     user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
 1278 â”‚                     session_id TEXT NOT NULL,
 1279 â”‚                     messages JSONB NOT NULL DEFAULT '[]'::jsonb,
 1280 â”‚                     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1281 â”‚                     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1282 â”‚                     UNIQUE (user_id, session_id)
 1283 â”‚                   );
 1284 â”‚ 
 1285 â”‚                   CREATE INDEX IF NOT EXISTS ai_chat_history_user_id_idx ON public.ai_chat_history(user_id);
 1286 â”‚                   CREATE INDEX IF NOT EXISTS ai_chat_history_session_id_idx ON public.ai_chat_history(session_id);
 1287 â”‚                 `
 1288 â”‚               });
 1289 â”‚             } catch (createTableError) {
 1290 â”‚               console.log('Erro ao criar tabela ai_chat_history:', createTableError);
 1291 â”‚             }
 1292 â”‚           }
 1293 â”‚ 
 1294 â”‚           // Upsert do histÃ³rico da conversa
 1295 â”‚           const { error } = await supabase
 1296 â”‚             .from('ai_chat_history')
 1297 â”‚             .upsert({
 1298 â”‚               user_id: userId,
 1299 â”‚               session_id: sessionId,
 1300 â”‚               messages: serializableHistory.slice(-100), // Armazenar atÃ© 100 mensagens
 1301 â”‚               updated_at: new Date().toISOString()
 1302 â”‚             }, {
 1303 â”‚               onConflict: 'user_id,session_id'
 1304 â”‚             });
 1305 â”‚ 
 1306 â”‚           if (error) {
 1307 â”‚             console.error("Erro ao sincronizar histÃ³rico com Supabase:", error);
 1308 â”‚           }
 1309 â”‚         } catch (upsertError) {
 1310 â”‚           console.error("Erro no upsert do histÃ³rico:", upsertError);
 1311 â”‚         }
 1312 â”‚       }
 1313 â”‚     } catch (syncError) {
 1314 â”‚       console.log("Supabase nÃ£o disponÃ­vel para sincronizaÃ§Ã£o:", syncError);
 1315 â”‚     }
 1316 â”‚   } catch (error) {
 1317 â”‚     console.error("Erro ao salvar o histÃ³rico da conversa:", error);
 1318 â”‚   }
 1319 â”‚ }
 1320 â”‚ 
 1321 â”‚ // SimulaÃ§Ã£o de resposta da IA
 1322 â”‚ const getResponseForMessage = (message: string): string => {
 1323 â”‚   // AnÃ¡lise bÃ¡sica da mensagem para gerar uma resposta contextual
 1324 â”‚   const formattedMessage = message.toLowerCase();
 1325 â”‚ 
 1326 â”‚   if (formattedMessage.includes('olÃ¡') || formattedMessage.includes('oi') || formattedMessage.includes('bom dia') || formattedMessage.includes('boa tarde') || formattedMessage.includes('boa noite')) {
 1327 â”‚     return `**OlÃ¡, ${userInfo?.username || 'amigo'}!** ğŸ˜Š\n\nComo posso ajudar vocÃª hoje?`;
 1328 â”‚   } else if (formattedMessage.includes('funÃ§Ã£o') || formattedMessage.includes('o que vocÃª faz') || formattedMessage.includes('para que serve')) {
 1329 â”‚     return `**Eu sou Epictus IA**, seu assistente para a plataforma Ponto.School! ğŸš€\n\nPosso ajudar com:\n\nâ€¢ **InformaÃ§Ãµes** sobre cursos e conteÃºdos\nâ€¢ **Dicas de estudos** personalizadas\nâ€¢ **NavegaÃ§Ã£o** na plataforma\nâ€¢ **Respostas** para dÃºvidas gerais\n\nComo posso ajudar vocÃª agora?`;
 1330 â”‚   } else if (formattedMessage.includes('portal') || formattedMessage.includes('material') || formattedMessage.includes('acessar conteÃºdo')) {
 1331 â”‚     return `VocÃª pode acessar o **Portal** com todos os materiais em https://pontoschool.com/portal\n\nLÃ¡ vocÃª encontrarÃ¡ todos os seus cursos, materiais e recursos de estudo organizados por disciplina.\n\n_Basta clicar no link acima para ir direto para o Portal!_ ğŸ“š`;
 1332 â”‚   } else {
 1333 â”‚     return "Desculpe, nÃ£o entendi sua pergunta. Pode reformulÃ¡-la?";
 1334 â”‚   }
 1335 â”‚ };
 1336 â”‚ 
 1337 â”‚ import { supabase } from "@/lib/supabase";
 1338 â”‚ import * as aiChatDB from "./aiChatDatabaseService";
 1339 â”‚ 
 1340 â”‚ interface ChatMessage {
 1341 â”‚   role: 'system' | 'user' | 'assistant';
 1342 â”‚   content: string;
 1343 â”‚ }
 1344 â”‚ 
 1345 â”‚ // Armazenamento temporÃ¡rio de histÃ³rico de chat no navegador
 1346 â”‚ const conversationHistory: Record<string, ChatMessage[]> = {};
 1347 â”‚ 
 1348 â”‚ // Limpar histÃ³rico de conversa especÃ­fica
 1349 â”‚ export const clearConversationHistory = (sessionId: string) => {
      Â·              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Â·                          â•°â”€â”€ `clearConversationHistory` redefined here
 1350 â”‚   if (conversationHistory[sessionId]) {
 1351 â”‚     delete conversationHistory[sessionId];
 1352 â”‚     // TambÃ©m limpar do localStorage se existir
      â•°â”€â”€â”€â”€

  Ã— the name `generateAIResponse` is defined multiple times
      â•­â”€[/home/runner/workspace/src/services/aiChatService.ts:766:1]
  766 â”‚ }
  767 â”‚ 
  768 â”‚ // FunÃ§Ã£o principal para gerar resposta, tentando primeiro xAI e depois Gemini como fallback
  769 â”‚ export async function generateAIResponse(
      Â·                       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€
      Â·                                â•°â”€â”€ previous definition of `generateAIResponse` here
  770 â”‚   message: string, 
  771 â”‚   sessionId: string, 
  772 â”‚   options?: { 
  773 â”‚     intelligenceLevel?: 'basic' | 'normal' | 'advanced',
  774 â”‚     languageStyle?: 'casual' | 'formal' | 'technical'
  775 â”‚   }
  776 â”‚ ): Promise<string> {
  777 â”‚   try {
  778 â”‚     return await generateXAIResponse(message, sessionId, options);
  779 â”‚   } catch (error) {
  780 â”‚     console.error('Erro com xAI, tentando Gemini:', error);
  781 â”‚     return generateGeminiResponse(message, sessionId, options);
  782 â”‚   }
  783 â”‚ }
  784 â”‚ 
  785 â”‚ // Limpar histÃ³rico da conversa
  786 â”‚ export function clearConversationHistory(sessionId: string): void {
  787 â”‚   if (conversationHistory[sessionId]) {
  788 â”‚     // MantÃ©m apenas a mensagem do sistema
  789 â”‚     const systemMessage = conversationHistory[sessionId][0];
  790 â”‚     conversationHistory[sessionId] = [systemMessage];
  791 â”‚ 
  792 â”‚     // Limpar do localStorage tambÃ©m
  793 â”‚     try {
  794 â”‚       localStorage.removeItem(`conversationHistory_${sessionId}`);
  795 â”‚     } catch (error) {
  796 â”‚       console.error("Erro ao limpar histÃ³rico do localStorage:", error);
  797 â”‚     }
  798 â”‚   }
  799 â”‚ }
  800 â”‚ 
  801 â”‚ // Obter histÃ³rico da conversa
  802 â”‚ export async function getConversationHistory(sessionId: string): Promise<ChatMessage[]> {
  803 â”‚   try {
  804 â”‚     // Primeiro verifica se jÃ¡ estÃ¡ carregado na memÃ³ria e Ã© vÃ¡lido
  805 â”‚     if (conversationHistory[sessionId] && Array.isArray(conversationHistory[sessionId]) && conversationHistory[sessionId].length > 0) {
  806 â”‚       // Verifica se hÃ¡ ao menos uma mensagem do sistema
  807 â”‚       const hasSystemMessage = conversationHistory[sessionId].some(msg => msg.role === 'system');
  808 â”‚ 
  809 â”‚       if (hasSystemMessage) {
  810 â”‚         return conversationHistory[sessionId];
  811 â”‚       }
  812 â”‚     }
  813 â”‚ 
  814 â”‚     // Tenta buscar dados adicionais do usuÃ¡rio para melhor armazenamento
  815 â”‚     let userIdForStorage = '';
  816 â”‚     try {
  817 â”‚       const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
  818 â”‚       userIdForStorage = sessionData?.session?.user?.id || '';
  819 â”‚     } catch (e) {
  820 â”‚       console.log('Erro ao obter ID do usuÃ¡rio:', e);
  821 â”‚     }
  822 â”‚ 
  823 â”‚     // Tenta recuperar do localStorage usando vÃ¡rios formatos de chave
  824 â”‚     const possibleKeys = [
  825 â”‚       `conversationHistory_${sessionId}`,
  826 â”‚       userIdForStorage ? `conversationHistory_${userIdForStorage}_${sessionId}` : null,
  827 â”‚       `chat_history_${sessionId}`
  828 â”‚     ].filter(Boolean);
  829 â”‚ 
  830 â”‚     let retrievedHistory = null;
  831 â”‚ 
  832 â”‚     // Tentar cada uma das possÃ­veis chaves
  833 â”‚     for (const key of possibleKeys) {
  834 â”‚       try {
  835 â”‚         const savedHistory = localStorage.getItem(key);
  836 â”‚         if (savedHistory) {
  837 â”‚           try {
  838 â”‚             const parsedHistory = JSON.parse(savedHistory);
  839 â”‚             if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
  840 â”‚               retrievedHistory = parsedHistory;
  841 â”‚               console.log(`HistÃ³rico recuperado com sucesso usando a chave: ${key}`);
  842 â”‚               break;
  843 â”‚             }
  844 â”‚           } catch (parseError) {
  845 â”‚             console.error(`Erro ao analisar histÃ³rico usando a chave ${key}:`, parseError);
  846 â”‚           }
  847 â”‚         }
  848 â”‚       } catch (e) {
  849 â”‚         console.error(`Erro ao tentar acessar o localStorage com a chave ${key}:`, e);
  850 â”‚       }
  851 â”‚     }
  852 â”‚ 
  853 â”‚     // Se encontrou histÃ³rico no localStorage
  854 â”‚     if (retrievedHistory) {
  855 â”‚       // Converter timestamps de string para Date e garantir formato adequado
  856 â”‚       const processedHistory = retrievedHistory.map(msg => ({
  857 â”‚         role: msg.role || 'user',
  858 â”‚         content: msg.content || '',
  859 â”‚         timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  860 â”‚       }));
  861 â”‚ 
  862 â”‚       // Verificar se hÃ¡ mensagem do sistema
  863 â”‚       const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  864 â”‚ 
  865 â”‚       if (!hasSystemMessage) {
  866 â”‚         // Se nÃ£o tiver mensagem do sistema, inicializar com uma nova
  867 â”‚         const userContext = await getUserContext();
  868 â”‚         initializeConversationHistory(sessionId, userContext);
  869 â”‚ 
  870 â”‚         // Adicionar as mensagens existentes (exceto mensagens do sistema jÃ¡ existentes)
  871 â”‚         conversationHistory[sessionId] = [
  872 â”‚           ...conversationHistory[sessionId],
  873 â”‚           ...processedHistory.filter(msg => msg.role !== 'system')
  874 â”‚         ];
  875 â”‚       } else {
  876 â”‚         conversationHistory[sessionId] = processedHistory;
  877 â”‚       }
  878 â”‚ 
  879 â”‚       return conversationHistory[sessionId];
  880 â”‚     }
  881 â”‚ 
  882 â”‚     // Se nÃ£o encontrou no localStorage, tenta recuperar do Supabase
  883 â”‚     try {
  884 â”‚       const supabase = (await import('@/lib/supabase')).supabase;
  885 â”‚       const { data: sessionData } = await supabase.auth.getSession();
  886 â”‚       const userId = sessionData?.session?.user?.id;
  887 â”‚ 
  888 â”‚       if (userId) {
  889 â”‚         try {
  890 â”‚           // Verificar se a tabela existe antes de tentar consultar
  891 â”‚           try {
  892 â”‚             const { data: tableExists } = await supabase
  893 â”‚               .from('information_schema.tables')
  894 â”‚               .select('table_name')
  895 â”‚               .eq('table_schema', 'public')
  896 â”‚               .eq('table_name', 'ai_chat_history')
  897 â”‚               .single();
  898 â”‚ 
  899 â”‚             if (!tableExists) {
  900 â”‚               console.log('Tabela ai_chat_history nÃ£o existe no Supabase.');
  901 â”‚               throw new Error('Tabela nÃ£o existe');
  902 â”‚             }
  903 â”‚           } catch (tableCheckError) {
  904 â”‚             console.log('Erro ao verificar existÃªncia da tabela:', tableCheckError);
  905 â”‚             throw tableCheckError;
  906 â”‚           }
  907 â”‚ 
  908 â”‚           const { data, error } = await supabase
  909 â”‚             .from('ai_chat_history')
  910 â”‚             .select('messages')
  911 â”‚             .eq('user_id', userId)
  912 â”‚             .eq('session_id', sessionId)
  913 â”‚             .single();
  914 â”‚ 
  915 â”‚           if (error) {
  916 â”‚             console.error('Erro ao buscar histÃ³rico do Supabase:', error);
  917 â”‚             throw error;
  918 â”‚           }
  919 â”‚ 
  920 â”‚           if (data?.messages && Array.isArray(data.messages) && data.messages.length > 0) {
  921 â”‚             // Converter timestamps de string para Date
  922 â”‚             const processedHistory = data.messages.map(msg => ({
  923 â”‚               role: msg.role || 'user',
  924 â”‚               content: msg.content || '',
  925 â”‚               timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  926 â”‚             }));
  927 â”‚ 
  928 â”‚             // Verificar se hÃ¡ mensagem do sistema
  929 â”‚             const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  930 â”‚ 
  931 â”‚             if (!hasSystemMessage) {
  932 â”‚               // Se nÃ£o tiver mensagem do sistema, inicializar com uma nova
  933 â”‚               const userContext = await getUserContext();
  934 â”‚               initializeConversationHistory(sessionId, userContext);
  935 â”‚ 
  936 â”‚               // Adicionar as mensagens existentes
  937 â”‚               conversationHistory[sessionId] = [
  938 â”‚                 ...conversationHistory[sessionId],
  939 â”‚                 ...processedHistory.filter(msg => msg.role !== 'system')
  940 â”‚               ];
  941 â”‚             } else {
  942 â”‚               conversationHistory[sessionId] = processedHistory;
  943 â”‚             }
  944 â”‚ 
  945 â”‚             // Atualizar localStorage para sincronizaÃ§Ã£o
  946 â”‚             try {
  947 â”‚               localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(conversationHistory[sessionId]));
  948 â”‚ 
  949 â”‚               // Se temos o userId, tambÃ©m armazenar com chave mais especÃ­fica
  950 â”‚               if (userId) {
  951 â”‚                 localStorage.setItem(`conversationHistory_${userId}_${sessionId}`, 
  952 â”‚                   JSON.stringify(conversationHistory[sessionId]));
  953 â”‚               }
  954 â”‚             } catch (localStorageError) {
  955 â”‚               console.log("Erro ao atualizar localStorage:", localStorageError);
  956 â”‚             }
  957 â”‚ 
  958 â”‚             return conversationHistory[sessionId];
  959 â”‚           }
  960 â”‚         } catch (supabaseError) {
  961 â”‚           console.error("Erro ao recuperar histÃ³rico do Supabase:", supabaseError);
  962 â”‚         }
  963 â”‚       }
  964 â”‚     } catch (dbError) {
  965 â”‚       console.error("Erro ao tentar acessar o banco de dados:", dbError);
  966 â”‚     }
  967 â”‚ 
  968 â”‚     // Se chegou aqui, nÃ£o foi possÃ­vel recuperar o histÃ³rico
  969 â”‚     // Inicializar com novo histÃ³rico
  970 â”‚     console.log("Criando novo histÃ³rico de conversa para a sessÃ£o:", sessionId);
  971 â”‚     const userContext = await getUserContext();
  972 â”‚     initializeConversationHistory(sessionId, userContext);
  973 â”‚ 
  974 â”‚     // Salvar o histÃ³rico inicial
  975 â”‚     try {
  976 â”‚       localStorage.setItem(`conversationHistory_${sessionId}`, 
  977 â”‚         JSON.stringify(conversationHistory[sessionId]));
  978 â”‚ 
  979 â”‚       // Se temos userIdForStorage, tambÃ©m armazenar com chave mais especÃ­fica
  980 â”‚       if (userIdForStorage) {
  981 â”‚         localStorage.setItem(`conversationHistory_${userIdForStorage}_${sessionId}`, 
  982 â”‚           JSON.stringify(conversationHistory[sessionId]));
  983 â”‚       }
  984 â”‚     } catch (e) {
  985 â”‚       console.error("Erro ao salvar histÃ³rico inicial:", e);
  986 â”‚     }
  987 â”‚ 
  988 â”‚     return conversationHistory[sessionId];
  989 â”‚   } catch (generalError) {
  990 â”‚     console.error("Erro geral ao obter histÃ³rico de conversa:", generalError);
  991 â”‚ 
  992 â”‚     // Retornar um histÃ³rico vazio em Ãºltimo caso
  993 â”‚     return [{
  994 â”‚       role: 'system',
  995 â”‚       content: 'VocÃª Ã© o Epictus IA, o assistente inteligente da Ponto.School.',
  996 â”‚       timestamp: new Date()
  997 â”‚     }];
  998 â”‚   }
  999 â”‚ }
 1000 â”‚ 
 1001 â”‚ // FunÃ§Ã£o para corrigir links da plataforma
 1002 â”‚ function fixPlatformLinks(text: string): string {
 1003 â”‚   const platformLinks = {
 1004 â”‚     'Portal de Estudos': 'https://pontoschool.com/portal',
 1005 â”‚     'Portal': 'https://pontoschool.com/portal',
 1006 â”‚     'Agenda': 'https://pontoschool.com/agenda',
 1007 â”‚     'Turmas': 'https://pontoschool.com/turmas',
 1008 â”‚     'Biblioteca': 'https://pontoschool.com/biblioteca',
 1009 â”‚     'Perfil': 'https://pontoschool.com/profile',
 1010 â”‚     'Meu Perfil': 'https://pontoschool.com/profile',
 1011 â”‚     'ConfiguraÃ§Ãµes': 'https://pontoschool.com/configuracoes',
 1012 â”‚     'Minhas ConfiguraÃ§Ãµes': 'https://pontoschool.com/configuracoes',
 1013 â”‚     'Dashboard': 'https://pontoschool.com/dashboard',
 1014 â”‚     'Epictus IA': 'https://pontoschool.com/epictus-ia',
 1015 â”‚     'Mentor IA': 'https://pontoschool.com/mentor-ia',
 1016 â”‚     'Planos de Estudo': 'https://pontoschool.com/planos-estudo',
 1017 â”‚     'Plano de Estudos': 'https://pontoschool.com/planos-estudo',
 1018 â”‚     'Conquistas': 'https://pontoschool.com/conquistas',
 1019 â”‚     'Minhas Conquistas': 'https://pontoschool.com/conquistas',
 1020 â”‚     'Carteira': 'https://pontoschool.com/carteira',
 1021 â”‚     'Minha Carteira': 'https://pontoschool.com/carteira',
 1022 â”‚     'Mercado': 'https://pontoschool.com/mercado',
 1023 â”‚     'OrganizaÃ§Ã£o': 'https://pontoschool.com/organizacao',
 1024 â”‚     'Comunidades': 'https://pontoschool.com/comunidades',
 1025 â”‚     'Chat IA': 'https://pontoschool.com/chat-ia',
 1026 â”‚     'School IA': 'https://pontoschool.com/school-ia',
 1027 â”‚     'Novidades': 'https://pontoschool.com/novidades',
 1028 â”‚     'Lembretes': 'https://pontoschool.com/lembretes',
 1029 â”‚     'Pedidos de Ajuda': 'https://pontoschool.com/pedidos-ajuda',
 1030 â”‚     'Estudos': 'https://pontoschool.com/estudos'
 1031 â”‚   };
 1032 â”‚ 
 1033 â”‚   // Primeiro, procura por textos especÃ­ficos que pedem redirecionamento
 1034 â”‚   const redirectPatterns = [
 1035 â”‚     /(?:me\s+(?:redirecione|encaminhe|leve|direcione|mande|envie)\s+(?:para|ao|Ã |a|atÃ©))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1036 â”‚     /(?:quero\s+(?:ir|acessar|entrar|ver))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1037 â”‚     /(?:me\s+(?:mostre|mostra))\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi,
 1038 â”‚     /(?:abrir?|abra|acesse|acessar|ver|veja)\s+(?:a\s+)?(?:pÃ¡gina\s+(?:de|do|da)\s+)?([a-zÃ -Ãº\s]+)/gi
 1039 â”‚   ];
 1040 â”‚ 
 1041 â”‚   // Aplicar padrÃµes de redirecionamento de forma mais robusta
 1042 â”‚   for (const pattern of redirectPatterns) {
 1043 â”‚     text = text.replace(pattern, (match, sectionName) => {
 1044 â”‚       if (!sectionName) return match;
 1045 â”‚ 
 1046 â”‚       const normalizedName = sectionName.trim();
 1047 â”‚       // Verificar se o nome normalizado corresponde a alguma chave do objeto platformLinks
 1048 â”‚       for (const key in platformLinks) {
 1049 â”‚         if (normalizedName.toLowerCase() === key.toLowerCase() || 
 1050 â”‚             key.toLowerCase().includes(normalizedName.toLowerCase()) || 
 1051 â”‚             normalizedName.toLowerCase().includes(key.toLowerCase())) {
 1052 â”‚           // Criar link em formato seguro sem possÃ­veis bugs de formataÃ§Ã£o
 1053 â”‚           return `VocÃª pode acessar [${key}](${platformLinks[key]})`;
 1054 â”‚         }
 1055 â”‚       }
 1056 â”‚       return match; // Se nÃ£o encontrou correspondÃªncia, mantÃ©m o texto original
 1057 â”‚     });
 1058 â”‚   }
 1059 â”‚ 
 1060 â”‚   // Verificar se o texto jÃ¡ contÃ©m links markdown
 1061 â”‚   const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
 1062 â”‚   const existingLinks = [];
 1063 â”‚   let match;
 1064 â”‚ 
 1065 â”‚   while ((match = markdownLinkRegex.exec(text)) !== null) {
 1066 â”‚     existingLinks.push({
 1067 â”‚       text: match[1],
 1068 â”‚       url: match[2],
 1069 â”‚       fullMatch: match[0]
 1070 â”‚     });
 1071 â”‚   }
 1072 â”‚ 
 1073 â”‚   // Depois, procurar menÃ§Ãµes a seÃ§Ãµes e converter para links (sÃ³ se nÃ£o forem jÃ¡ parte de um link)
 1074 â”‚   let newText = text;
 1075 â”‚ 
 1076 â”‚   // Aplicar substituiÃ§Ãµes de forma ordenada (das mais longas para as mais curtas)
 1077 â”‚   const orderedKeys = Object.keys(platformLinks).sort((a, b) => b.length - a.length);
 1078 â”‚ 
 1079 â”‚   for (const key of orderedKeys) {
 1080 â”‚     // Criar regex segura que nÃ£o captura dentro de links existentes
 1081 â”‚     const safeRegex = new RegExp(`(?<![\\[\\w])\\b(${escapeRegExp(key)})\\b(?![\\]\\w])`, 'g');
 1082 â”‚ 
 1083 â”‚     // Verificar cada ocorrÃªncia para garantir que nÃ£o estÃ¡ dentro de um link existente
 1084 â”‚     let lastIndex = 0;
 1085 â”‚     let result = '';
 1086 â”‚     let regexMatch;
 1087 â”‚ 
 1088 â”‚     while ((regexMatch = safeRegex.exec(newText)) !== null) {
 1089 â”‚       const matchStart = regexMatch.index;
 1090 â”‚       const matchEnd = matchStart + regexMatch[0].length;
 1091 â”‚ 
 1092 â”‚       // Verificar se esta ocorrÃªncia estÃ¡ dentro de algum link existente
 1093 â”‚       let isInsideExistingLink = false;
 1094 â”‚       for (const link of existingLinks) {
 1095 â”‚         const linkIndex = newText.indexOf(link.fullMatch);
 1096 â”‚         if (linkIndex <= matchStart && linkIndex + link.fullMatch.length >= matchEnd) {
 1097 â”‚           isInsideExistingLink = true;
 1098 â”‚           break;
 1099 â”‚         }
 1100 â”‚       }
 1101 â”‚ 
 1102 â”‚       if (!isInsideExistingLink) {
 1103 â”‚         result += newText.substring(lastIndex, matchStart);
 1104 â”‚         result += `[${regexMatch[1]}](${platformLinks[key]})`;
 1105 â”‚         lastIndex = matchEnd;
 1106 â”‚       }
 1107 â”‚     }
 1108 â”‚ 
 1109 â”‚     if (lastIndex > 0) {
 1110 â”‚       result += newText.substring(lastIndex);
 1111 â”‚       newText = result;
 1112 â”‚ 
 1113 â”‚       // Atualizar a lista de links existentes
 1114 â”‚       existingLinks.length = 0;
 1115 â”‚       while ((match = markdownLinkRegex.exec(newText)) !== null) {
 1116 â”‚         existingLinks.push({
 1117 â”‚           text: match[1],
 1118 â”‚           url: match[2],
 1119 â”‚           fullMatch: match[0]
 1120 â”‚         });
 1121 â”‚       }
 1122 â”‚     }
 1123 â”‚   }
 1124 â”‚ 
 1125 â”‚   // Remover qualquer formataÃ§Ã£o incorreta que possa ter sido introduzida
 1126 â”‚   newText = newText
 1127 â”‚     .replace(/\]\(\[/g, ']([') // Corrigir links aninhados
 1128 â”‚     .replace(/\]\(https:\/\/pontoschool\.com\/[a-z-]+\)\(https:\/\/pontoschool\.com\/[a-z-]+\)/g, match => {
 1129 â”‚       // Extrair o primeiro link vÃ¡lido
 1130 â”‚       const urlMatch = match.match(/\]\((https:\/\/pontoschool\.com\/[a-z-]+)\)/);
 1131 â”‚       if (urlMatch && urlMatch[1]) {
 1132 â”‚         return `](${urlMatch[1]})`;
 1133 â”‚       }
 1134 â”‚       return match;
 1135 â”‚     });
 1136 â”‚ 
 1137 â”‚   return newText;
 1138 â”‚ }
 1139 â”‚ 
 1140 â”‚ // FunÃ§Ã£o auxiliar para escapar caracteres especiais em regex
 1141 â”‚ function escapeRegExp(string) {
 1142 â”‚   return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 1143 â”‚ }
 1144 â”‚ 
 1145 â”‚ 
 1146 â”‚ // FunÃ§Ã£o para salvar o histÃ³rico da conversa no localStorage e sincronizar com Supabase
 1147 â”‚ async function saveConversationHistory(sessionId: string, history: ChatMessage[]): Promise<void> {
 1148 â”‚   try {
 1149 â”‚     if (!sessionId || !history) {
 1150 â”‚       console.error("Erro ao salvar histÃ³rico: sessionId ou history invÃ¡lidos");
 1151 â”‚       return;
 1152 â”‚     }
 1153 â”‚ 
 1154 â”‚     // Salvar localmente
 1155 â”‚     conversationHistory[sessionId] = history;
 1156 â”‚ 
 1157 â”‚     // Preparar o histÃ³rico para armazenamento (garantir que todos os objetos sÃ£o serializÃ¡veis)
 1158 â”‚     const serializableHistory = history.map(msg => ({
 1159 â”‚       role: msg.role,
 1160 â”‚       content: msg.content,
 1161 â”‚       timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1162 â”‚                 (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1163 â”‚     }));
 1164 â”‚ 
 1165 â”‚     try {
 1166 â”‚       // Salvar para o usuÃ¡rio atual com uma estrutura mais persistente
 1167 â”‚       // Usar formato conversationHistory_USER_ID_sessionId quando possÃ­vel
 1168 â”‚       let storageKey = `conversationHistory_${sessionId}`;
 1169 â”‚ 
 1170 â”‚       // Tentar obter dados de identificaÃ§Ã£o do usuÃ¡rio para melhor rastreamento
 1171 â”‚       try {
 1172 â”‚         const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
 1173 â”‚         const userId = sessionData?.session?.user?.id;
 1174 â”‚         if (userId) {
 1175 â”‚           storageKey = `conversationHistory_${userId}_${sessionId}`;
 1176 â”‚         }
 1177 â”‚       } catch (e) {
 1178 â”‚         console.log('Erro ao obter ID do usuÃ¡rio, usando chave padrÃ£o:', e);
 1179 â”‚       }
 1180 â”‚ 
 1181 â”‚       // Salvar com uma chave mais especÃ­fica para melhor identificaÃ§Ã£o
 1182 â”‚       localStorage.setItem(storageKey, JSON.stringify(serializableHistory));
 1183 â”‚ 
 1184 â”‚       // Para compatibilidade, tambÃ©m salvar com a chave antiga
 1185 â”‚       localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(serializableHistory));
 1186 â”‚ 
 1187 â”‚       // Manter um Ã­ndice de todas as conversas do usuÃ¡rio
 1188 â”‚       try {
 1189 â”‚         const userConversationsKey = 'userConversationsIndex';
 1190 â”‚         let conversationsIndex = {};
 1191 â”‚ 
 1192 â”‚         const savedIndex = localStorage.getItem(userConversationsKey);
 1193 â”‚         if (savedIndex) {
 1194 â”‚           conversationsIndex = JSON.parse(savedIndex);
 1195 â”‚         }
 1196 â”‚ 
 1197 â”‚         conversationsIndex[sessionId] = {
 1198 â”‚           lastUpdated: new Date().toISOString(),
 1199 â”‚           messageCount: serializableHistory.length,
 1200 â”‚           title: serializableHistory.length > 1 ? 
 1201 â”‚             serializableHistory[1].content.substring(0, 30) + "..." : 
 1202 â”‚             "Nova conversa"
 1203 â”‚         };
 1204 â”‚ 
 1205 â”‚         // Limitar o Ã­ndice a 50 conversas mais recentes
 1206 â”‚         const sortedEntries = Object.entries(conversationsIndex)
 1207 â”‚           .sort((a, b) => new Date(b[1].lastUpdated).getTime() - new Date(a[1].lastUpdated).getTime())
 1208 â”‚           .slice(0, 50);
 1209 â”‚ 
 1210 â”‚         const trimmedIndex = {};
 1211 â”‚         sortedEntries.forEach(([key, value]) => {
 1212 â”‚           trimmedIndex[key] = value;
 1213 â”‚         });
 1214 â”‚ 
 1215 â”‚         localStorage.setItem(userConversationsKey, JSON.stringify(trimmedIndex));
 1216 â”‚       } catch (indexError) {
 1217 â”‚         console.error("Erro ao atualizar Ã­ndice de conversas:", indexError);
 1218 â”‚       }
 1219 â”‚ 
 1220 â”‚       // Salvar todas as sessÃµes em um Ãºnico item no localStorage com limite de tamanho
 1221 â”‚       try {
 1222 â”‚         const allSessions = {};
 1223 â”‚         // SÃ³ armazenar as Ãºltimas 20 sessÃµes
 1224 â”‚         const sessionIds = Object.keys(conversationHistory).slice(-20);
 1225 â”‚ 
 1226 â”‚         for (const id of sessionIds) {
 1227 â”‚           const sessionHistory = conversationHistory[id];
 1228 â”‚           if (sessionHistory && sessionHistory.length > 0) {
 1229 â”‚             // Limitar cada sessÃ£o a 100 mensagens para melhor contexto
 1230 â”‚             allSessions[id] = sessionHistory.slice(-100).map(msg => ({
 1231 â”‚               role: msg.role,
 1232 â”‚               content: msg.content,
 1233 â”‚               timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1234 â”‚                         (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1235 â”‚             }));
 1236 â”‚           }
 1237 â”‚         }
 1238 â”‚ 
 1239 â”‚         localStorage.setItem('aiChatSessions', JSON.stringify(allSessions));
 1240 â”‚       } catch (batchSaveError) {
 1241 â”‚         console.error("Erro ao salvar todas as sessÃµes:", batchSaveError);
 1242 â”‚       }
 1243 â”‚     } catch (localStorageError) {
 1244 â”‚       console.error("Erro ao salvar no localStorage:", localStorageError);
 1245 â”‚       // Se falhar por exceder o limite, limpar o localStorage e tentar novamente sÃ³ com a sessÃ£o atual
 1246 â”‚       try {
 1247 â”‚         localStorage.removeItem('aiChatSessions');
 1248 â”‚         localStorage.setItem(`conversationHistory_${sessionId}`, 
 1249 â”‚           JSON.stringify(serializableHistory.slice(-50))); // Salvar sÃ³ as Ãºltimas 50 mensagens
 1250 â”‚       } catch (retryError) {
 1251 â”‚         console.error("Falha na segunda tentativa de salvar no localStorage:", retryError);
 1252 â”‚       }
 1253 â”‚     }
 1254 â”‚ 
 1255 â”‚     // Sincronizar com Supabase se disponÃ­vel
 1256 â”‚     try {
 1257 â”‚       const supabase = (await import('@/lib/supabase')).supabase;
 1258 â”‚       const { data: sessionData } = await supabase.auth.getSession();
 1259 â”‚       const userId = sessionData?.session?.user?.id;
 1260 â”‚ 
 1261 â”‚       if (userId) {
 1262 â”‚         try {
 1263 â”‚           // Criar tabela ai_chat_history se nÃ£o existir (verificar primeiro)
 1264 â”‚           const { data: tablesData } = await supabase
 1265 â”‚             .from('information_schema.tables')
 1266 â”‚             .select('table_name')
 1267 â”‚             .eq('table_schema', 'public')
 1268 â”‚             .eq('table_name', 'ai_chat_history');
 1269 â”‚ 
 1270 â”‚           if (!tablesData || tablesData.length === 0) {
 1271 â”‚             // Tabela nÃ£o existe, tentar criar usando rpc
 1272 â”‚             try {
 1273 â”‚               await supabase.rpc('execute_sql', {
 1274 â”‚                 sql_statement: `
 1275 â”‚                   CREATE TABLE IF NOT EXISTS public.ai_chat_history (
 1276 â”‚                     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
 1277 â”‚                     user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
 1278 â”‚                     session_id TEXT NOT NULL,
 1279 â”‚                     messages JSONB NOT NULL DEFAULT '[]'::jsonb,
 1280 â”‚                     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1281 â”‚                     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1282 â”‚                     UNIQUE (user_id, session_id)
 1283 â”‚                   );
 1284 â”‚ 
 1285 â”‚                   CREATE INDEX IF NOT EXISTS ai_chat_history_user_id_idx ON public.ai_chat_history(user_id);
 1286 â”‚                   CREATE INDEX IF NOT EXISTS ai_chat_history_session_id_idx ON public.ai_chat_history(session_id);
 1287 â”‚                 `
 1288 â”‚               });
 1289 â”‚             } catch (createTableError) {
 1290 â”‚               console.log('Erro ao criar tabela ai_chat_history:', createTableError);
 1291 â”‚             }
 1292 â”‚           }
 1293 â”‚ 
 1294 â”‚           // Upsert do histÃ³rico da conversa
 1295 â”‚           const { error } = await supabase
 1296 â”‚             .from('ai_chat_history')
 1297 â”‚             .upsert({
 1298 â”‚               user_id: userId,
 1299 â”‚               session_id: sessionId,
 1300 â”‚               messages: serializableHistory.slice(-100), // Armazenar atÃ© 100 mensagens
 1301 â”‚               updated_at: new Date().toISOString()
 1302 â”‚             }, {
 1303 â”‚               onConflict: 'user_id,session_id'
 1304 â”‚             });
 1305 â”‚ 
 1306 â”‚           if (error) {
 1307 â”‚             console.error("Erro ao sincronizar histÃ³rico com Supabase:", error);
 1308 â”‚           }
 1309 â”‚         } catch (upsertError) {
 1310 â”‚           console.error("Erro no upsert do histÃ³rico:", upsertError);
 1311 â”‚         }
 1312 â”‚       }
 1313 â”‚     } catch (syncError) {
 1314 â”‚       console.log("Supabase nÃ£o disponÃ­vel para sincronizaÃ§Ã£o:", syncError);
 1315 â”‚     }
 1316 â”‚   } catch (error) {
 1317 â”‚     console.error("Erro ao salvar o histÃ³rico da conversa:", error);
 1318 â”‚   }
 1319 â”‚ }
 1320 â”‚ 
 1321 â”‚ // SimulaÃ§Ã£o de resposta da IA
 1322 â”‚ const getResponseForMessage = (message: string): string => {
 1323 â”‚   // AnÃ¡lise bÃ¡sica da mensagem para gerar uma resposta contextual
 1324 â”‚   const formattedMessage = message.toLowerCase();
 1325 â”‚ 
 1326 â”‚   if (formattedMessage.includes('olÃ¡') || formattedMessage.includes('oi') || formattedMessage.includes('bom dia') || formattedMessage.includes('boa tarde') || formattedMessage.includes('boa noite')) {
 1327 â”‚     return `**OlÃ¡, ${userInfo?.username || 'amigo'}!** ğŸ˜Š\n\nComo posso ajudar vocÃª hoje?`;
 1328 â”‚   } else if (formattedMessage.includes('funÃ§Ã£o') || formattedMessage.includes('o que vocÃª faz') || formattedMessage.includes('para que serve')) {
 1329 â”‚     return `**Eu sou Epictus IA**, seu assistente para a plataforma Ponto.School! ğŸš€\n\nPosso ajudar com:\n\nâ€¢ **InformaÃ§Ãµes** sobre cursos e conteÃºdos\nâ€¢ **Dicas de estudos** personalizadas\nâ€¢ **NavegaÃ§Ã£o** na plataforma\nâ€¢ **Respostas** para dÃºvidas gerais\n\nComo posso ajudar vocÃª agora?`;
 1330 â”‚   } else if (formattedMessage.includes('portal') || formattedMessage.includes('material') || formattedMessage.includes('acessar conteÃºdo')) {
 1331 â”‚     return `VocÃª pode acessar o **Portal** com todos os materiais em https://pontoschool.com/portal\n\nLÃ¡ vocÃª encontrarÃ¡ todos os seus cursos, materiais e recursos de estudo organizados por disciplina.\n\n_Basta clicar no link acima para ir direto para o Portal!_ ğŸ“š`;
 1332 â”‚   } else {
 1333 â”‚     return "Desculpe, nÃ£o entendi sua pergunta. Pode reformulÃ¡-la?";
 1334 â”‚   }
 1335 â”‚ };
 1336 â”‚ 
 1337 â”‚ import { supabase } from "@/lib/supabase";
 1338 â”‚ import * as aiChatDB from "./aiChatDatabaseService";
 1339 â”‚ 
 1340 â”‚ interface ChatMessage {
 1341 â”‚   role: 'system' | 'user' | 'assistant';
 1342 â”‚   content: string;
 1343 â”‚ }
 1344 â”‚ 
 1345 â”‚ // Armazenamento temporÃ¡rio de histÃ³rico de chat no navegador
 1346 â”‚ const conversationHistory: Record<string, ChatMessage[]> = {};
 1347 â”‚ 
 1348 â”‚ // Limpar histÃ³rico de conversa especÃ­fica
 1349 â”‚ export const clearConversationHistory = (sessionId: string) => {
 1350 â”‚   if (conversationHistory[sessionId]) {
 1351 â”‚     delete conversationHistory[sessionId];
 1352 â”‚     // TambÃ©m limpar do localStorage se existir
 1353 â”‚     try {
 1354 â”‚       localStorage.removeItem(`conversationHistory_${sessionId}`);
 1355 â”‚     } catch (error) {
 1356 â”‚       console.error('Erro ao limpar histÃ³rico do localStorage:', error);
 1357 â”‚     }
 1358 â”‚   }
 1359 â”‚ };
 1360 â”‚ 
 1361 â”‚ // FunÃ§Ã£o para gerar um prompt de sistema informativo para a IA
 1362 â”‚ const generateSystemPrompt = async (
 1363 â”‚   userName: string, 
 1364 â”‚   userId: string | null, 
 1365 â”‚   options: {
 1366 â”‚     intelligenceLevel: 'basic' | 'normal' | 'advanced',
 1367 â”‚     languageStyle: 'casual' | 'formal' | 'technical',
 1368 â”‚     includeLinks: boolean
 1369 â”‚   }
 1370 â”‚ ) => {
 1371 â”‚   let systemPrompt = `VocÃª Ã© o Epictus IA de Suporte, um assistente virtual amigÃ¡vel dentro da plataforma educacional Ponto.School. 
 1372 â”‚   Seu papel Ã© fornecer suporte para navegaÃ§Ã£o, responder dÃºvidas sobre funcionalidades e dar dicas para o melhor aproveitamento da plataforma.
 1373 â”‚   VocÃª deve ser gentil, educado e paciente. VocÃª tem acesso Ã s informaÃ§Ãµes da conta do usuÃ¡rio quando solicitado.
 1374 â”‚ 
 1375 â”‚   Diretrizes:
 1376 â”‚   1. Seja conciso, direto e Ãºtil - respostas entre 2-3 parÃ¡grafos sÃ£o ideais
 1377 â”‚   2. Seja amigÃ¡vel e use um tom conversacional
 1378 â”‚   3. Use formataÃ§Ã£o para organizar suas respostas: negrito para tÃ­tulos, listas numeradas ou com marcadores para passos
 1379 â”‚   4. Quando mencionar um recurso da plataforma, explique brevemente como acessÃ¡-lo
 1380 â”‚   5. Se o usuÃ¡rio parecer confuso, ofereÃ§a opÃ§Ãµes para ajudÃ¡-lo
 1381 â”‚   6. Se a pergunta for sobre um tÃ³pico educacional especÃ­fico, direcione-o para usar o Epictus IA na seÃ§Ã£o especÃ­fica para isso
 1382 â”‚   7. Se a pergunta for sobre um problema tÃ©cnico sem soluÃ§Ã£o simples, sugira abrir um ticket de suporte ou entrar em contato por e-mail: suporte@pontoschool.com
 1383 â”‚ 
 1384 â”‚   IMPORTANTE: VocÃª estÃ¡ conversando com ${userName} (utilize apenas o primeiro nome ao se referir ao usuÃ¡rio) e deve se referir a ele pelo primeiro nome em suas respostas.`;
 1385 â”‚ 
 1386 â”‚   // Adicionar informaÃ§Ãµes da plataforma para referÃªncia
 1387 â”‚   systemPrompt += `\n\nInformaÃ§Ãµes da plataforma para referÃªncia:`;
 1388 â”‚ 
 1389 â”‚   // Adicionar seÃ§Ãµes da plataforma
 1390 â”‚   const platformSections = aiChatDB.getPlatformNavigationInfo();
 1391 â”‚   systemPrompt += `\n\nSeÃ§Ãµes principais:`;
 1392 â”‚   platformSections.forEach(section => {
 1393 â”‚     systemPrompt += `\n- ${section.section}: ${section.description}`;
 1394 â”‚   });
 1395 â”‚ 
 1396 â”‚   // Adicionar categorias de FAQs para informar a IA sobre o conhecimento disponÃ­vel
 1397 â”‚   const faqs = aiChatDB.getFAQDatabase();
 1398 â”‚   const categories = [...new Set(faqs.map(faq => faq.category))];
 1399 â”‚ 
 1400 â”‚   systemPrompt += `\n\nCategorias de perguntas frequentes:`;
 1401 â”‚   categories.forEach(category => {
 1402 â”‚     systemPrompt += `\n- ${category}`;
 1403 â”‚   });
 1404 â”‚ 
 1405 â”‚   // Adicionar informaÃ§Ãµes do usuÃ¡rio se disponÃ­veis
 1406 â”‚   if (userId) {
 1407 â”‚     try {
 1408 â”‚       const userInfo = await aiChatDB.formatUserInfoForAI(userId);
 1409 â”‚       if (typeof userInfo === 'object') {
 1410 â”‚         systemPrompt += `\n\nInformaÃ§Ãµes do usuÃ¡rio:
 1411 â”‚ - Nome: ${userInfo.full_name}
 1412 â”‚ - Nome de exibiÃ§Ã£o: ${userInfo.display_name}
 1413 â”‚ - Email: ${userInfo.email}
 1414 â”‚ - ID: ${userInfo.id}
 1415 â”‚ - NÃ­vel: ${userInfo.level}
 1416 â”‚ - Plano: ${userInfo.plan_type}
 1417 â”‚ - InstituiÃ§Ã£o: ${userInfo.institution}
 1418 â”‚ - Criado em: ${userInfo.created_at}
 1419 â”‚ - Bio: ${userInfo.bio}
 1420 â”‚ - NÃºmero de turmas: ${userInfo.classes ? userInfo.classes.length : 0}`;
 1421 â”‚       }
 1422 â”‚     } catch (error) {
 1423 â”‚       console.error("Erro ao obter informaÃ§Ãµes do usuÃ¡rio:", error);
 1424 â”‚     }
 1425 â”‚   }
 1426 â”‚ 
 1427 â”‚   // Ajustar nÃ­vel de inteligÃªncia
 1428 â”‚   if (options.intelligenceLevel === 'basic') {
 1429 â”‚     systemPrompt += '\nResponda de forma simples e direta, com explicaÃ§Ãµes bÃ¡sicas.';
 1430 â”‚   } else if (options.intelligenceLevel === 'advanced') {
 1431 â”‚     systemPrompt += '\nResponda de forma detalhada e abrangente, com explicaÃ§Ãµes avanÃ§adas quando aplicÃ¡vel.';
 1432 â”‚   }
 1433 â”‚ 
 1434 â”‚   // Ajustar estilo de linguagem
 1435 â”‚   if (options.languageStyle === 'formal') {
 1436 â”‚     systemPrompt += '\nUtilize linguagem formal e profissional, evitando gÃ­rias e expressÃµes coloquiais.';
 1437 â”‚   } else if (options.languageStyle === 'technical') {
 1438 â”‚     systemPrompt += '\nUtilize linguagem tÃ©cnica e especÃ­fica quando apropriado, mas garantindo que as explicaÃ§Ãµes sejam claras.';
 1439 â”‚   }
 1440 â”‚ 
 1441 â”‚   // Ajustar uso de links
 1442 â”‚   if (!options.includeLinks) {
 1443 â”‚     systemPrompt += '\nEvite incluir links nas suas respostas. ForneÃ§a instruÃ§Ãµes detalhadas em vez de links.';
 1444 â”‚   }
 1445 â”‚ 
 1446 â”‚   return systemPrompt;
 1447 â”‚ };
 1448 â”‚ 
 1449 â”‚ // FunÃ§Ã£o para enriquecer a mensagem do usuÃ¡rio com contexto relevante
 1450 â”‚ const enrichUserMessage = async (message: string, userId: string | null) => {
 1451 â”‚   let enrichedMessage = message;
 1452 â”‚   let contextAdded = false;
 1453 â”‚ 
 1454 â”‚   // Verificar se a mensagem parece solicitar informaÃ§Ãµes pessoais
 1455 â”‚   const askingForPersonalInfo = /meu (perfil|conta|usuÃ¡rio|saldo|turmas|nivel)/i.test(message) || 
 1456 â”‚     /minha (s)? (informaÃ§[Ãµo]es|dados|conta)/i.test(message) ||
 1457 â”‚     /me (mostre|diga|informe) (sobre )?m(eu|inha)/i.test(message);
 1458 â”‚ 
 1459 â”‚   if (askingForPersonalInfo && userId) {
 1460 â”‚     try {
 1461 â”‚       const userInfo = await aiChatDB.formatUserInfoForAI(userId);
 1462 â”‚       if (typeof userInfo === 'object') {
 1463 â”‚         enrichedMessage += `\n\nContexto adicional (nÃ£o visÃ­vel para o usuÃ¡rio): 
 1464 â”‚ InformaÃ§Ãµes atualizadas da conta do usuÃ¡rio:
 1465 â”‚ - Nome completo: ${userInfo.full_name}
 1466 â”‚ - Nome de usuÃ¡rio: ${userInfo.display_name}
 1467 â”‚ - Email: ${userInfo.email}
 1468 â”‚ - ID: ${userInfo.id}
 1469 â”‚ - NÃ­vel: ${userInfo.level}
 1470 â”‚ - Plano: ${userInfo.plan_type}
 1471 â”‚ - Criado em: ${userInfo.created_at}
 1472 â”‚ - InstituiÃ§Ã£o: ${userInfo.institution}
 1473 â”‚ - Bio: ${userInfo.bio}`;
 1474 â”‚ 
 1475 â”‚         if (userInfo.classes && userInfo.classes.length > 0) {
 1476 â”‚           enrichedMessage += `\n- Turmas: ${userInfo.classes.map((c: any) => c.name).join(', ')}`;
 1477 â”‚         } else {
 1478 â”‚           enrichedMessage += `\n- Turmas: Nenhuma turma encontrada`;
 1479 â”‚         }
 1480 â”‚ 
 1481 â”‚         contextAdded = true;
 1482 â”‚       }
 1483 â”‚     } catch (error) {
 1484 â”‚       console.error("Erro ao enriquecer mensagem do usuÃ¡rio:", error);
 1485 â”‚     }
 1486 â”‚   }
 1487 â”‚ 
 1488 â”‚   // Verificar se a mensagem estÃ¡ pedindo ajuda sobre navegaÃ§Ã£o/localizaÃ§Ã£o
 1489 â”‚   const askingForNavigation = /(onde|como) (encontr[oa]|ach[oa]|acess[oa])/i.test(message) || 
 1490 â”‚     /onde (fica|estÃ¡)/i.test(message);
 1491 â”‚ 
 1492 â”‚   if (askingForNavigation) {
 1493 â”‚     // Buscar informaÃ§Ãµes relevantes no banco de dados de navegaÃ§Ã£o
 1494 â”‚     const navigationResults = aiChatDB.searchPlatformInfo(message);
 1495 â”‚     if (navigationResults.length > 0) {
 1496 â”‚       enrichedMessage += `\n\nContexto adicional (nÃ£o visÃ­vel para o usuÃ¡rio): 
 1497 â”‚ InformaÃ§Ãµes de navegaÃ§Ã£o relevantes:`;
 1498 â”‚       navigationResults.slice(0, 3).forEach(item => {
 1499 â”‚         enrichedMessage += `\n- ${item.section}: ${item.description} (Caminho: ${item.path})`;
 1500 â”‚       });
 1501 â”‚       contextAdded = true;
 1502 â”‚     }
 1503 â”‚   }
 1504 â”‚ 
 1505 â”‚   // Verificar se Ã© uma pergunta sobre funcionalidades ou ajuda
 1506 â”‚   const askingForHelp = /como (faÃ§o|funciona|crio|acesso|uso|utilizo)/i.test(message) || 
 1507 â”‚     /(o que Ã©|para que serve)/i.test(message) ||
 1508 â”‚     /(ajuda|dÃºvida|problema|dificuldade)/i.test(message);
 1509 â”‚ 
 1510 â”‚   if (askingForHelp) {
 1511 â”‚     // Buscar FAQs relevantes
 1512 â”‚     const faqResults = aiChatDB.searchFAQs(message);
 1513 â”‚     if (faqResults.length > 0) {
 1514 â”‚       enrichedMessage += `\n\nContexto adicional (nÃ£o visÃ­vel para o usuÃ¡rio): 
 1515 â”‚ FAQs relevantes:`;
 1516 â”‚       faqResults.slice(0, 3).forEach(item => {
 1517 â”‚         enrichedMessage += `\n- P: ${item.question}\n  R: ${item.answer}`;
 1518 â”‚       });
 1519 â”‚       contextAdded = true;
 1520 â”‚     }
 1521 â”‚   }
 1522 â”‚ 
 1523 â”‚   // Se nenhum contexto foi adicionado, mas parece uma pergunta especÃ­fica
 1524 â”‚   if (!contextAdded && 
 1525 â”‚     (message.includes("?") || 
 1526 â”‚      /^(o que|como|onde|quando|quem|qual|quais|por que|pra que)/i.test(message))) {
 1527 â”‚ 
 1528 â”‚     // Buscar todas as informaÃ§Ãµes potencialmente relevantes
 1529 â”‚     const keywords = message.split(/\s+/).filter(word => word.length > 3);
 1530 â”‚     const relevantFaqs: any[] = [];
 1531 â”‚ 
 1532 â”‚     for (const keyword of keywords) {
 1533 â”‚       const results = aiChatDB.searchFAQs(keyword);
 1534 â”‚       results.forEach(result => {
 1535 â”‚         if (!relevantFaqs.some(faq => faq.id === result.id)) {
 1536 â”‚           relevantFaqs.push(result);
 1537 â”‚         }
 1538 â”‚       });
 1539 â”‚       if (relevantFaqs.length >= 2) break;
 1540 â”‚     }
 1541 â”‚ 
 1542 â”‚     if (relevantFaqs.length > 0) {
 1543 â”‚       enrichedMessage += `\n\nContexto adicional (nÃ£o visÃ­vel para o usuÃ¡rio): 
 1544 â”‚ FAQs potencialmente relevantes:`;
 1545 â”‚       relevantFaqs.slice(0, 2).forEach(item => {
 1546 â”‚         enrichedMessage += `\n- P: ${item.question}\n  R: ${item.answer}`;
 1547 â”‚       });
 1548 â”‚     }
 1549 â”‚   }
 1550 â”‚ 
 1551 â”‚   return enrichedMessage;
 1552 â”‚ };
 1553 â”‚ 
 1554 â”‚ // FunÃ§Ã£o principal para gerar resposta da IA
 1555 â”‚ export const generateAIResponse = async (
      Â·              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€
      Â·                       â•°â”€â”€ `generateAIResponse` redefined here
 1556 â”‚   message: string,
 1557 â”‚   sessionId: string,
 1558 â”‚   userName: string = "UsuÃ¡rio",
      â•°â”€â”€â”€â”€
/home/runner/workspace/src/services/aiChatService.ts:16:1
160|        // Dados de contexto de uso
161|        currentPage: window.location.pathname,
162|        lastActivity: localStorage.getItem('lastActivity') || 'Nenhuma atividade recente',
   |                                                                            ^
163|  
164|        // Dados das turmas e sÃ©ries