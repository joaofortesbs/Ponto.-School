[plugin:vite:react-swc] × the name `conversationHistory` is defined multiple times
      ╭─[/home/runner/workspace/src/services/aiChatService.ts:16:1]
   16 │ }
   17 │ 
   18 │ // Histórico de conversas
   19 │ let conversationHistory: Record<string, ChatMessage[]> = {};
      ·     ─────────┬─────────
      ·              ╰── previous definition of `conversationHistory` here
   20 │ 
   21 │ // Inicializar o histórico do localStorage quando o módulo carrega
   22 │ try {
   23 │   const savedSessions = localStorage.getItem('aiChatSessions');
   24 │   if (savedSessions) {
   25 │     const parsedSessions = JSON.parse(savedSessions);
   26 │     // Verificar se é um objeto válido
   27 │     if (parsedSessions && typeof parsedSessions === 'object') {
   28 │       // Para cada sessão, converter as datas de string para Date
   29 │       Object.keys(parsedSessions).forEach(sessionId => {
   30 │         if (Array.isArray(parsedSessions[sessionId])) {
   31 │           conversationHistory[sessionId] = parsedSessions[sessionId].map(msg => ({
   32 │             ...msg,
   33 │             timestamp: msg.timestamp ? new Date(msg.timestamp) : new Date()
   34 │           }));
   35 │         }
   36 │       });
   37 │       console.log(`Carregadas ${Object.keys(conversationHistory).length} sessões de chat do localStorage`);
   38 │     }
   39 │   }
   40 │ } catch (error) {
   41 │   console.error('Erro ao carregar histórico de conversas do localStorage:', error);
   42 │ }
   43 │ 
   44 │ // Função para obter dados do usuário atual com acesso expandido e completo
   45 │ async function getUserContext() {
   46 │   try {
   47 │     // Obter dados do localStorage e sessionStorage
   48 │     const usernameSources = {
   49 │       localStorage: localStorage.getItem('username'),
   50 │       sessionStorage: sessionStorage.getItem('username'),
   51 │       profile: null,
   52 │       metadata: null,
   53 │       email: localStorage.getItem('userEmail') || sessionStorage.getItem('userEmail')
   54 │     };
   55 │ 
   56 │     // Importar serviços e utilitários necessários
   57 │     let profileService;
   58 │     let supabase;
   59 │     let completeUserProfile = null;
   60 │     let userClasses = [];
   61 │     let userSeries = [];
   62 │     let followersCount = 0;
   63 │ 
   64 │     try {
   65 │       // Importar o serviço de perfil e o cliente Supabase
   66 │       profileService = (await import('@/services/profileService')).profileService;
   67 │       supabase = (await import('@/lib/supabase')).supabase;
   68 │ 
   69 │       // Obter perfil completo do usuário com todos os detalhes
   70 │       completeUserProfile = await profileService.getCurrentUserProfile();
   71 │ 
   72 │       // Obter session para determinar o ID do usuário atual
   73 │       const { data: sessionData } = await supabase.auth.getSession();
   74 │       const currentUserId = sessionData?.session?.user?.id;
   75 │ 
   76 │       if (currentUserId && completeUserProfile) {
   77 │         // Obter turmas do usuário
   78 │         const { data: classesData } = await supabase
   79 │           .from('user_classes')
   80 │           .select('*, class:classes(*)')
   81 │           .eq('user_id', currentUserId);
   82 │ 
   83 │         if (classesData) {
   84 │           userClasses = classesData;
   85 │         }
   86 │ 
   87 │         // Obter séries do usuário
   88 │         const { data: seriesData } = await supabase
   89 │           .from('user_series')
   90 │           .select('*, serie:series(*)')
   91 │           .eq('user_id', currentUserId);
   92 │ 
   93 │         if (seriesData) {
   94 │           userSeries = seriesData;
   95 │         }
   96 │ 
   97 │         // Obter contagem de seguidores
   98 │         const { count } = await supabase
   99 │           .from('user_followers')
  100 │           .select('*', { count: 'exact' })
  101 │           .eq('followed_id', currentUserId);
  102 │ 
  103 │         if (count !== null) {
  104 │           followersCount = count;
  105 │         }
  106 │       }
  107 │     } catch (error) {
  108 │       console.error('Erro ao obter dados completos do perfil:', error);
  109 │     }
  110 │ 
  111 │     // Tentar obter dados expandidos do perfil via username-utils (fallback)
  112 │     let basicProfileData = {};
  113 │     let metadataUsername = null;
  114 │ 
  115 │     try {
  116 │       const usernameUtils = await import('@/lib/username-utils');
  117 │       if (usernameUtils && usernameUtils.getUserProfile) {
  118 │         basicProfileData = await usernameUtils.getUserProfile();
  119 │ 
  120 │         if (usernameUtils.getCurrentUsername) {
  121 │           metadataUsername = await usernameUtils.getCurrentUsername();
  122 │           usernameSources.metadata = metadataUsername;
  123 │         }
  124 │ 
  125 │         if (basicProfileData && basicProfileData.username) {
  126 │           usernameSources.profile = basicProfileData.username;
  127 │         }
  128 │       }
  129 │     } catch (error) {
  130 │       console.log('Erro ao obter perfil via username-utils:', error);
  131 │     }
  132 │ 
  133 │     // Determinar o melhor username para usar (prioridade: perfil completo > metadata > localStorage > sessionStorage)
  134 │     const bestUsername = 
  135 │       (completeUserProfile?.username || completeUserProfile?.display_name) || 
  136 │       metadataUsername || 
  137 │       usernameSources.localStorage || 
  138 │       usernameSources.sessionStorage || 
  139 │       usernameSources.profile || 
  140 │       'Usuário';
  141 │ 
  142 │     // Construir contexto completo do usuário
  143 │     const userContext = {
  144 │       // Dados básicos
  145 │       username: bestUsername,
  146 │       email: completeUserProfile?.email || usernameSources.email || 'email@exemplo.com',
  147 │ 
  148 │       // Dados completos do perfil
  149 │       profile: completeUserProfile || basicProfileData,
  150 │ 
  151 │       // Dados específicos para fácil acesso
  152 │       userId: completeUserProfile?.user_id || 'ID não disponível',
  153 │       fullName: completeUserProfile?.full_name || 'Nome não disponível',
  154 │       displayName: completeUserProfile?.display_name || bestUsername,
  155 │       createdAt: completeUserProfile?.created_at || 'Data não disponível',
  156 │       planType: completeUserProfile?.plan_type || 'lite',
  157 │       userLevel: completeUserProfile?.level || 1,
  158 │       followersCount: followersCount,
  159 │ 
  160 │       // Dados de contexto de uso
  161 │       currentPage: window.location.pathname,
  162 │       lastActivity: localStorage.getItem('lastActivity') || 'Nenhuma atividade recente',
  163 │ 
  164 │       // Dados das turmas e séries
  165 │       classes: userClasses,
  166 │       series: userSeries,
  167 │ 
  168 │       // Dados do dispositivo e ambiente
  169 │       userAgent: navigator.userAgent,
  170 │       platform: navigator.platform,
  171 │       screenSize: `${window.innerWidth}x${window.innerHeight}`,
  172 │       darkMode: window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches,
  173 │ 
  174 │       // Dados do localStorage
  175 │       localStorageData: Object.keys(localStorage).filter(key => 
  176 │         key.startsWith('user_') || 
  177 │         key.startsWith('ponto_') || 
  178 │         key.startsWith('study_')
  179 │       ).reduce((acc, key) => {
  180 │         acc[key] = localStorage.getItem(key);
  181 │         return acc;
  182 │       }, {})
  183 │     };
  184 │ 
  185 │     // Obter atividades recentes
  186 │     try {
  187 │       const recentActivities = JSON.parse(localStorage.getItem('user_recent_activities') || '[]');
  188 │       if (Array.isArray(recentActivities) && recentActivities.length > 0) {
  189 │         userContext.recentActivities = recentActivities;
  190 │       }
  191 │     } catch (e) {
  192 │       console.log('Erro ao obter atividades recentes:', e);
  193 │     }
  194 │ 
  195 │     return userContext;
  196 │   } catch (error) {
  197 │     console.error('Erro ao obter contexto do usuário:', error);
  198 │     return { username: 'Usuário' };
  199 │   }
  200 │ }
  201 │ 
  202 │ 
  203 │ // Função para gerar resposta usando a API xAI
  204 │ export async function generateXAIResponse(
  205 │   message: string, 
  206 │   sessionId: string,
  207 │   options?: { 
  208 │     intelligenceLevel?: 'basic' | 'normal' | 'advanced',
  209 │     languageStyle?: 'casual' | 'formal' | 'technical'
  210 │   }
  211 │ ): Promise<string> {
  212 │   try {
  213 │     // Verificar se a mensagem contém comando para acessar ou modificar o perfil
  214 │     const isProfileInfoRequest = /qual (é|e) (o )?meu (ID|id)|me (mostre|mostra|diga|informe) (o )?meu (ID|id)|informações da minha conta|dados da minha conta|meu perfil completo/i.test(message);
  215 │     const isProfileUpdateRequest = /atualiz(e|ar) (minha|a) (bio|biografia)|mudar (minha|a) (bio|biografia)|modificar (minha|a) bio|mudar (meu|o) nome de exibição|atualizar (meu|o) nome de exibição|mudar (meu|o) telefone/i.test(message);
  216 │     const isRedirectRequest = /(me\s+(redirecione|encaminhe|leve|direcione|mande|envie)\s+(para|ao|à|a|até)|quero\s+(ir|acessar|entrar|ver)|me\s+(mostre|mostra)|abrir?|abra|acesse|acessar|ver|veja)\s+(a\s+)?(página\s+(de|do|da)\s+)?([a-zà-ú\s]+)/i.test(message);
  217 │ 
  218 │     // Importar o serviço de modificação de perfil se necessário
  219 │     let ProfileModificationService;
  220 │     if (isProfileInfoRequest || isProfileUpdateRequest) {
  221 │       try {
  222 │         ProfileModificationService = (await import('./profileModificationService')).ProfileModificationService;
  223 │       } catch (e) {
  224 │         console.error('Erro ao importar ProfileModificationService:', e);
  225 │       }
  226 │     }
  227 │ 
  228 │     // Obter contexto do usuário - fazer isso logo no início
  229 │     const userContext = await getUserContext();
  230 │ 
  231 │     // Extrair o primeiro nome do usuário para uso personalizado nas respostas
  232 │     const firstName = userContext.fullName ? 
  233 │       userContext.fullName.split(' ')[0] : 
  234 │       (userContext.displayName || userContext.username || 'Usuário');
  235 │ 
  236 │     // Inicializar o histórico se não existir
  237 │     if (!conversationHistory[sessionId]) {
  238 │       initializeConversationHistory(sessionId, userContext);
  239 │     }
  240 │ 
  241 │     // Adiciona a mensagem do usuário ao histórico
  242 │     conversationHistory[sessionId].push({ 
  243 │       role: 'user', 
  244 │       content: message,
  245 │       timestamp: new Date() 
  246 │     });
  247 │ 
  248 │     // Processar solicitação de informações do perfil
  249 │     if (isProfileInfoRequest && ProfileModificationService) {
  250 │       try {
  251 │         const { profile, formattedInfo } = await ProfileModificationService.getDetailedUserProfile();
  252 │ 
  253 │         // Se conseguiu obter as informações, criar uma resposta personalizada
  254 │         if (profile) {
  255 │           // Criar resposta amigável com as informações
  256 │           const response = `Claro, ${firstName}! Aqui estão as informações da sua conta:
  257 │ 
  258 │ ${formattedInfo}
  259 │ 
  260 │ Você pode visualizar e editar seu perfil completo acessando [sua página de perfil](https://pontoschool.com/profile).
  261 │ 
  262 │ Posso te ajudar a atualizar algumas dessas informações diretamente por aqui, como sua biografia ou nome de exibição. É só me pedir!`;
  263 │ 
  264 │           // Adicionar a resposta ao histórico
  265 │           conversationHistory[sessionId].push({ 
  266 │             role: 'assistant', 
  267 │             content: response,
  268 │             timestamp: new Date()
  269 │           });
  270 │ 
  271 │           await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  272 │           return response;
  273 │         }
  274 │       } catch (e) {
  275 │         console.error('Erro ao processar solicitação de informações do perfil:', e);
  276 │       }
  277 │     }
  278 │ 
  279 │     // Processar solicitação de atualização de perfil
  280 │     if (isProfileUpdateRequest && ProfileModificationService) {
  281 │       // Reconhecer o tipo de atualização solicitada
  282 │       const isBioUpdate = /atualiz(e|ar) (minha|a) (bio|biografia)|mudar (minha|a) (bio|biografia)|modificar (minha|a) bio/i.test(message);
  283 │       const isDisplayNameUpdate = /mudar (meu|o) nome de exibição|atualizar (meu|o) nome de exibição/i.test(message);
  284 │       const isContactInfoUpdate = /mudar (meu|o) telefone|atualizar (meu|o) telefone|mudar (minha|a) localização|atualizar (minha|a) localização/i.test(message);
  285 │ 
  286 │       // Extrair o conteúdo a ser atualizado
  287 │       try {
  288 │         // Determinar qual atualização fazer e responder apropriadamente
  289 │         let response = '';
  290 │ 
  291 │         if (isBioUpdate) {
  292 │           // Extrair a nova biografia da mensagem
  293 │           const bioRegex = /(?:para|como|com) ["|'|"](.+?)["|'|"]/i;
  294 │           const bioMatch = message.match(bioRegex);
  295 │ 
  296 │           if (bioMatch && bioMatch[1]) {
  297 │             const newBio = bioMatch[1].trim();
  298 │             const result = await ProfileModificationService.updateUserBio(newBio);
  299 │ 
  300 │             if (result.success) {
  301 │               response = `Ótimo, ${firstName}! Sua biografia foi atualizada com sucesso para: "${newBio}". 
  302 │ 
  303 │ As alterações já estão disponíveis no seu perfil. Você pode conferir em [sua página de perfil](https://pontoschool.com/profile).`;
  304 │             } else {
  305 │               response = `Desculpe ${firstName}, não consegui atualizar sua biografia. ${result.message}`;
  306 │             }
  307 │           } else {
  308 │             response = `Parece que você quer atualizar sua biografia, ${firstName}, mas não entendi qual seria o novo texto. Pode me fornecer a nova biografia entre aspas? 
  309 │ 
  310 │ Por exemplo: "Atualizar minha biografia para 'Estudante de engenharia apaixonado por tecnologia'"`;
  311 │           }
  312 │         } else if (isDisplayNameUpdate) {
  313 │           // Extrair o novo nome de exibição
  314 │           const nameRegex = /(?:para|como|com) ["|'|"](.+?)["|'|"]/i;
  315 │           const nameMatch = message.match(nameRegex);
  316 │ 
  317 │           if (nameMatch && nameMatch[1]) {
  318 │             const newName = nameMatch[1].trim();
  319 │             const result = await ProfileModificationService.updateDisplayName(newName);
  320 │ 
  321 │             if (result.success) {
  322 │               response = `Perfeito, ${firstName}! Seu nome de exibição foi atualizado com sucesso para: "${newName}".
  323 │ 
  324 │ A alteração já está disponível em seu perfil. Você pode conferir em [sua página de perfil](https://pontoschool.com/profile).`;
  325 │             } else {
  326 │               response = `Desculpe ${firstName}, não consegui atualizar seu nome de exibição. ${result.message}`;
  327 │             }
  328 │           } else {
  329 │             response = `Parece que você quer atualizar seu nome de exibição, ${firstName}, mas não entendi qual seria o novo nome. Pode me fornecer o novo nome entre aspas?
  330 │ 
  331 │ Por exemplo: "Atualizar meu nome de exibição para 'João Silva'"`;
  332 │           }
  333 │         } else if (isContactInfoUpdate) {
  334 │           response = `${firstName}, para atualizar suas informações de contato, é melhor acessar diretamente a página de configurações:
  335 │ 
  336 │ [Acesse as configurações do seu perfil](https://pontoschool.com/configuracoes)
  337 │ 
  338 │ Lá você poderá atualizar seu telefone, localização e outras informações de contato de forma segura.`;
  339 │         }
  340 │ 
  341 │         // Adicionar a resposta ao histórico
  342 │         if (response) {
  343 │           conversationHistory[sessionId].push({ 
  344 │             role: 'assistant', 
  345 │             content: response,
  346 │             timestamp: new Date()
  347 │           });
  348 │           await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  349 │           return response;
  350 │         }
  351 │       } catch (e) {
  352 │         console.error('Erro ao processar solicitação de atualização de perfil:', e);
  353 │       }
  354 │     }
  355 │ 
  356 │     // Verificar se é um pedido de redirecionamento para área da plataforma
  357 │     if (isRedirectRequest) {
  358 │       const platformLinks = {
  359 │         'Portal de Estudos': 'https://pontoschool.com/portal',
  360 │         'Portal': 'https://pontoschool.com/portal',
  361 │         'Agenda': 'https://pontoschool.com/agenda',
  362 │         'Turmas': 'https://pontoschool.com/turmas',
  363 │         'Biblioteca': 'https://pontoschool.com/biblioteca',
  364 │         'Perfil': 'https://pontoschool.com/profile',
  365 │         'Meu Perfil': 'https://pontoschool.com/profile',
  366 │         'Configurações': 'https://pontoschool.com/configuracoes',
  367 │         'Minhas Configurações': 'https://pontoschool.com/configuracoes',
  368 │         'Dashboard': 'https://pontoschool.com/dashboard',
  369 │         'Epictus IA': 'https://pontoschool.com/epictus-ia',
  370 │         'Mentor IA': 'https://pontoschool.com/mentor-ia',
  371 │         'Planos de Estudo': 'https://pontoschool.com/planos-estudo',
  372 │         'Plano de Estudos': 'https://pontoschool.com/planos-estudo',
  373 │         'Conquistas': 'https://pontoschool.com/conquistas',
  374 │         'Minhas Conquistas': 'https://pontoschool.com/conquistas',
  375 │         'Carteira': 'https://pontoschool.com/carteira',
  376 │         'Minha Carteira': 'https://pontoschool.com/carteira',
  377 │         'Mercado': 'https://pontoschool.com/mercado',
  378 │         'Organização': 'https://pontoschool.com/organizacao',
  379 │         'Comunidades': 'https://pontoschool.com/comunidades',
  380 │         'Chat IA': 'https://pontoschool.com/chat-ia',
  381 │         'School IA': 'https://pontoschool.com/school-ia',
  382 │         'Novidades': 'https://pontoschool.com/novidades',
  383 │         'Lembretes': 'https://pontoschool.com/lembretes',
  384 │         'Pedidos de Ajuda': 'https://pontoschool.com/pedidos-ajuda',
  385 │         'Estudos': 'https://pontoschool.com/estudos'
  386 │       };
  387 │ 
  388 │       // Regex mais preciso para extrair a seção desejada
  389 │       const sectionRegex = /(me\s+(redirecione|encaminhe|leve|direcione|mande|envie)\s+(para|ao|à|a|até)|quero\s+(ir|acessar|entrar|ver)|me\s+(mostre|mostra)|abrir?|abra|acesse|acessar|ver|veja)\s+(a\s+)?(página\s+(de|do|da)\s+)?([a-zà-ú\s]+)/i;
  390 │       const match = message.match(sectionRegex);
  391 │ 
  392 │       if (match && match[9]) {
  393 │         const requestedSection = match[9].trim().toLowerCase();
  394 │ 
  395 │         // Encontra a melhor correspondência entre as seções disponíveis
  396 │         const sections = Object.keys(platformLinks);
  397 │         const bestMatch = sections.find(section => 
  398 │           section.toLowerCase() === requestedSection || 
  399 │           section.toLowerCase().includes(requestedSection) ||
  400 │           requestedSection.includes(section.toLowerCase())
  401 │         );
  402 │ 
  403 │         if (bestMatch) {
  404 │           const response = `Claro, ${firstName}! Aqui está o link direto para ${bestMatch}: [${bestMatch}](${platformLinks[bestMatch]})
  405 │ 
  406 │ Clique no link acima para ser redirecionado. Posso ajudar com mais alguma coisa?`;
  407 │ 
  408 │           conversationHistory[sessionId].push({ 
  409 │             role: 'assistant', 
  410 │             content: response,
  411 │             timestamp: new Date()
  412 │           });
  413 │           await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  414 │           return response;
  415 │         }
  416 │       }
  417 │     }
  418 │ 
  419 │     // Limita o histórico para evitar exceder os limites da API
  420 │     if (conversationHistory[sessionId].length > 20) {
  421 │       // Mantém a mensagem do sistema e as últimas 19 mensagens
  422 │       const systemMessage = conversationHistory[sessionId][0];
  423 │       conversationHistory[sessionId] = [
  424 │         systemMessage,
  425 │         ...conversationHistory[sessionId].slice(-19)
  426 │       ];
  427 │     }
  428 │ 
  429 │     try {
  430 │       // Configuração da solicitação para a API xAI
  431 │       const response = await axios.post(
  432 │         XAI_BASE_URL,
  433 │         {
  434 │           messages: conversationHistory[sessionId].map(msg => ({
  435 │             role: msg.role,
  436 │             content: msg.content
  437 │           })),
  438 │           model: 'grok-3-latest',
  439 │           stream: false,
  440 │           temperature: 0.7,
  441 │           max_tokens: 1000
  442 │         },
  443 │         {
  444 │           headers: {
  445 │             'Content-Type': 'application/json',
  446 │             'Authorization': `Bearer ${XAI_API_KEY}`
  447 │           },
  448 │           timeout: 15000 // 15 segundos de timeout
  449 │         }
  450 │       );
  451 │ 
  452 │       // Extrai a resposta
  453 │       let aiResponse = '';
  454 │ 
  455 │       if (response.data && 
  456 │           response.data.choices && 
  457 │           response.data.choices.length > 0 && 
  458 │           response.data.choices[0].message) {
  459 │         aiResponse = response.data.choices[0].message.content;
  460 │       } else {
  461 │         throw new Error('Formato de resposta inválido da API xAI');
  462 │       }
  463 │ 
  464 │       // Verificar e corrigir links de redirecionamento
  465 │       aiResponse = fixPlatformLinks(aiResponse);
  466 │ 
  467 │       // Adicionar a resposta da IA à interface com formatação melhorada e corrigida
  468 │       const formattedResponse = aiResponse
  469 │         // Formatação de texto básica
  470 │         .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold">$1</strong>')
  471 │         .replace(/\_(.*?)\_/g, '<em class="italic">$1</em>')
  472 │         .replace(/\~\~(.*?)\~\~/g, '<del class="line-through">$1</del>')
  473 │         .replace(/\`(.*?)\`/g, '<code class="bg-black/10 dark:bg-white/10 rounded px-1 py-0.5 font-mono text-xs">$1</code>')
  474 │ 
  475 │         // Formatação de parágrafos e listas
  476 │         .replace(/\n\n/g, '</p><p class="mt-3">')
  477 │         .replace(/\n/g, '<br />')
  478 │ 
  479 │         // Formatação de títulos
  480 │         .replace(/^# (.*?)$/gm, '<h3 class="text-lg font-bold my-2">$1</h3>')
  481 │         .replace(/^## (.*?)$/gm, '<h4 class="text-md font-bold my-2">$1</h4>')
  482 │ 
  483 │         // Formatação de listas
  484 │         .replace(/^\* (.*?)$/gm, '<li class="ml-4 list-disc">$1</li>')
  485 │         .replace(/^\d\. (.*?)$/gm, '<li class="ml-4 list-decimal">$1</li>')
  486 │ 
  487 │         // Formatação de links com ícone
  488 │         .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-blue-500 hover:text-blue-600 hover:underline font-medium inline-flex items-center" target="_blank" rel="noopener noreferrer">$1<svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg></a>')
  489 │         .replace(/(https?:\/\/[^\s]+)(?!\))/g, '<a href="$1" class="text-blue-500 hover:text-blue-600 hover:underline font-medium inline-flex items-center" target="_blank" rel="noopener noreferrer">$1<svg class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg></a>')
  490 │ 
  491 │         // Formatação especial para dicas e destaques
  492 │         .replace(/💡 (.*?)$/gm, '<div class="bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300 p-2 rounded-md my-2 flex items-start"><span class="mr-2">💡</span><span>$1</span></div>')
  493 │         .replace(/⚠️ (.*?)$/gm, '<div class="bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-300 p-2 rounded-md my-2 flex items-start"><span class="mr-2">⚠️</span><span>$1</span></div>')
  494 │ 
  495 │         // Garantir que o conteúdo esteja envolto em um parágrafo
  496 │         .replace(/^(.+?)$/gm, function(match) {
  497 │           if (!match.startsWith('<') && !match.endsWith('>')) {
  498 │             return '<p>' + match + '</p>';
  499 │           }
  500 │           return match;
  501 │         });
  502 │ 
  503 │       // Garantir que não existam múltiplos <br> consecutivos
  504 │       const cleanedResponse = formattedResponse
  505 │         .replace(/<br\s*\/?><br\s*\/?>/g, '<br />')
  506 │         .replace(/<p><\/p>/g, '')
  507 │         .replace(/<p><br \/><\/p>/g, '<p>&nbsp;</p>');
  508 │ 
  509 │ 
  510 │       // Adiciona a resposta da IA ao histórico
  511 │       conversationHistory[sessionId].push({ 
  512 │         role: 'assistant', 
  513 │         content: cleanedResponse,
  514 │         timestamp: new Date()
  515 │       });
  516 │ 
  517 │       // Salvar histórico atualizado no localStorage
  518 │       await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  519 │ 
  520 │       return cleanedResponse;
  521 │     } catch (apiError) {
  522 │       console.error('Erro na API xAI:', apiError);
  523 │ 
  524 │       // Resposta padrão em caso de erro
  525 │       const fallbackResponse = `Desculpe ${firstName}, o chat de suporte está enfrentando dificuldades técnicas no momento. 
  526 │ 
  527 │ Vou tentar responder sua pergunta sobre a plataforma mesmo assim. ${message.length < 50 ? "Você me perguntou sobre " + message : ""}
  528 │ 
  529 │ Posso ajudar você a navegar pela plataforma ou esclarecer alguma outra dúvida hoje?`;
  530 │ 
  531 │       // Adicionar a resposta alternativa ao histórico
  532 │       conversationHistory[sessionId].push({ 
  533 │         role: 'assistant', 
  534 │         content: fallbackResponse,
  535 │         timestamp: new Date()
  536 │       });
  537 │ 
  538 │       // Salvar histórico atualizado
  539 │       await saveConversationHistory(sessionId, conversationHistory[sessionId]);
  540 │ 
  541 │       // Tenta resposta fallback via Gemini
  542 │       try {
  543 │         return await generateGeminiResponse(message, sessionId, options);
  544 │       } catch (geminiError) {
  545 │         console.error('Erro também no Gemini:', geminiError);
  546 │         return fallbackResponse;
  547 │       }
  548 │     }
  549 │   } catch (error) {
  550 │     console.error('Erro ao gerar resposta com xAI:', error);
  551 │     // Fallback para Gemini em caso de erro
  552 │     try {
  553 │       return await generateGeminiResponse(message, sessionId, options);
  554 │     } catch (geminiError) {
  555 │       console.error('Erro também no Gemini:', geminiError);
  556 │       return `Desculpe, estou enfrentando dificuldades técnicas no momento. Por favor, tente novamente mais tarde.`;
  557 │     }
  558 │   }
  559 │ }
  560 │ 
  561 │ // Função auxiliar para inicializar o histórico de conversa com mensagem do sistema
  562 │ function initializeConversationHistory(sessionId: string, userContext?: any) {
  563 │   // Se não tiver contexto do usuário, use valores padrão
  564 │   const username = userContext?.username || 'Usuário';
  565 │   const firstName = userContext?.fullName ? userContext.fullName.split(' ')[0] : username;
  566 │   const email = userContext?.email || 'email@exemplo.com';
  567 │   const userId = userContext?.userId || 'ID não disponível';
  568 │   const currentPage = userContext?.currentPage || window.location.pathname;
  569 │   const planType = userContext?.planType || 'lite';
  570 │   const userLevel = userContext?.userLevel || 1;
  571 │ 
  572 │   conversationHistory[sessionId] = [
  573 │     { 
  574 │       role: 'system', 
  575 │       content: `Você é o Epictus IA do chat de suporte flutuante da Ponto.School, um assistente dedicado à navegação e suporte da plataforma, completamente diferente do Epictus IA do menu lateral.
  576 │ 
  577 │       OBJETIVO ESPECÍFICO:
  578 │       Você é um assistente de SUPORTE que funciona como um guia completo para a plataforma Ponto.School. Seu papel é:
  579 │       1. Ajudar com navegação e localização de funcionalidades
  580 │       2. Explicar como usar as diferentes ferramentas da plataforma
  581 │       3. Responder dúvidas sobre conteúdos educacionais
  582 │       4. Servir como um tutorial interativo para novos usuários
  583 │       5. Resolver problemas técnicos básicos
  584 │ 
  585 │       CONTEXTO DO USUÁRIO (COMPLETO):
  586 │       - Nome: ${userContext?.fullName || 'Não disponível'}
  587 │       - Username: ${username}
  588 │       - Primeiro nome: ${firstName}
  589 │       - Email: ${email}
  590 │       - ID do usuário: ${userId}
  591 │       - Plano atual: ${planType}
  592 │       - Nível: ${userLevel}
  593 │       - Localização atual na plataforma: ${currentPage}
  594 │ 
  595 │       DIRETRIZES DE COMUNICAÇÃO:
  596 │       1. MUITO IMPORTANTE: Sempre se refira ao usuário pelo primeiro nome: "${firstName}". Use frases como "E aí, ${firstName}!", "Opa ${firstName}!", etc.
  597 │       2. Use uma linguagem mais informal e descontraída, como se estivesse conversando com um amigo.
  598 │       3. Seja amigável, use emojis ocasionalmente e mantenha um tom leve e positivo.
  599 │       4. Use gírias leves e expressões coloquiais quando apropriado.
  600 │       5. Mantenha respostas diretas e objetivas, evitando textos muito longos.
  601 │       6. Organize suas respostas em parágrafos curtos para fácil leitura.
  602 │       7. Use negrito **assim** para destacar informações importantes.
  603 │ 
  604 │       DIFERENCIAÇÃO IMPORTANTE:
  605 │       Você NÃO É o mesmo assistente que o Epictus IA da seção do menu lateral. O Epictus IA do menu lateral é focado em estudos personalizados, planos de aprendizagem e conteúdo educacional avançado. Você é o assistente de SUPORTE que ajuda com a navegação da plataforma, responde dúvidas gerais e técnicas. Nunca se confunda com o outro assistente.
  606 │ 
  607 │       CONTEÚDO INSTITUCIONAL:
  608 │       Quando perguntado sobre os criadores, fundadores, donos, desenvolvedores, equipe administrativa ou qualquer pergunta relacionada à gestão da Ponto.School, responda:
  609 │       "A Ponto.School tem 4 administradores principais, além de equipes dedicadas de suporte, marketing, TI e outras áreas. São eles:
  610 │       - Fundador & CEO: João Fortes (@joaofortes) - usuário na plataforma Ponto.School
  611 │       - Co-Fundador & CMO: Felipe Brito (@felipe_rico) - usuário na plataforma Ponto.School
  612 │       - Co-Fundador & COO: Adriel Borges (@adriel_borges) - usuário na plataforma Ponto.School
  613 │       - Co-Fundador & Coordenador de Design: Samuel Afonso (@samuel_afonso) - usuário na plataforma Ponto.School"
  614 │ 
  615 │       RECURSOS DE PERFIL:
  616 │       Quando o usuário perguntar sobre o ID da conta ou informações do perfil, você tem acesso completo a:
  617 │       1. ID do usuário (user_id): ${userId}
  618 │       2. Data de criação da conta: ${userContext?.createdAt || 'Não disponível'}
  619 │       3. Nome completo: ${userContext?.fullName || 'Não disponível'}
  620 │       4. Plano atual: ${planType}
  621 │       5. Nível: ${userLevel}
  622 │       6. Seguidores: ${userContext?.followersCount || '0'}
  623 │ 
  624 │       Você pode ajudar o usuário a atualizar informações do perfil como:
  625 │       1. Biografia/bio
  626 │       2. Nome de exibição
  627 │       3. Para outras alterações, redirecione para a página de configurações
  628 │ 
  629 │       SUPORTE TÉCNICO E TUTORIAL:
  630 │       Quando o usuário tiver dúvidas sobre como usar a plataforma:
  631 │       1. Explique detalhadamente como acessar a funcionalidade desejada
  632 │       2. Ofereça dicas para melhorar a experiência de uso
  633 │       3. Sugira recursos relacionados que possam ser úteis
  634 │       4. Se for um problema técnico, sugira soluções básicas ou redirecione para suporte especializado
  635 │ 
  636 │       REGRAS DE REDIRECIONAMENTO:
  637 │       Quando o usuário pedir para ser redirecionado a uma seção da plataforma, você DEVE SEMPRE:
  638 │       1. Incluir o link completo usando a base https://pontoschool.com/
  639 │       2. Formatá-lo como um link clicável com texto descritivo
  640 │       3. Ser direto e proativo com o redirecionamento
  641 │       4. Explicar brevemente o que o usuário encontrará na seção
  642 │ 
  643 │       Exemplos de redirecionamento correto:
  644 │       - "Aqui está o [Portal de Estudos](https://pontoschool.com/portal). Clique para acessar todos os seus materiais organizados."
  645 │       - "Você pode acessar sua [Agenda](https://pontoschool.com/agenda) imediatamente para ver seus compromissos."
  646 │       - "Sua [página de Turmas](https://pontoschool.com/turmas) está pronta para acesso, lá você encontrará todos os seus grupos de estudo."
  647 │       - "Acesse a [Biblioteca](https://pontoschool.com/biblioteca) para encontrar materiais complementares e recursos de aprendizagem."
  648 │ 
  649 │       NUNCA responda apenas com "você pode encontrar isso no menu lateral" ou sugestões vagas.
  650 │       SEMPRE forneça o link direto e clicável para onde o usuário deseja ir.
  651 │ 
  652 │       URLS DA PLATAFORMA (memorize todas estas URLs para redirecionamento):
  653 │       - Portal de Estudos: https://pontoschool.com/portal
  654 │       - Agenda: https://pontoschool.com/agenda
  655 │       - Turmas: https://pontoschool.com/turmas
  656 │       - Biblioteca: https://pontoschool.com/biblioteca
  657 │       - Perfil: https://pontoschool.com/profile
  658 │       - Configurações: https://pontoschool.com/configuracoes
  659 │       - Dashboard: https://pontoschool.com/dashboard
  660 │       - Epictus IA: https://pontoschool.com/epictus-ia
  661 │       - Mentor IA: https://pontoschool.com/mentor-ia
  662 │       - Planos de Estudo: https://pontoschool.com/planos-estudo
  663 │       - Conquistas: https://pontoschool.com/conquistas
  664 │       - Carteira: https://pontoschool.com/carteira
  665 │       - Mercado: https://pontoschool.com/mercado
  666 │       - Organização: https://pontoschool.com/organizacao
  667 │       - Comunidades: https://pontoschool.com/comunidades
  668 │       - Chat IA: https://pontoschool.com/chat-ia
  669 │       - School IA: https://pontoschool.com/school-ia
  670 │       - Novidades: https://pontoschool.com/novidades
  671 │       - Lembretes: https://pontoschool.com/lembretes
  672 │ - Pedidos deAjuda: https://pontoschool.com/pedidos-ajuda
  673 │       - Estudos: https://pontoschool.com/estudos
  674 │ 
  675 │       QUANDO REMETER AO EPICTUS IA DO MENU LATERAL:
  676 │       Se o usuário fizer perguntas específicas sobre planos de estudo personalizados, análise de desempenho aprofundada, ou solicitar assistência em conteúdos educacionais avançados, diga:
  677 │       "Para essa funcionalidade específica, recomendo que você acesse o [Epictus IA do menu lateral](https://pontoschool.com/epictus-ia), que é nosso assistente especializado em estudos aprofundados e personalização de conteúdo educacional. Estou aqui para ajudar com navegação, dúvidas sobre a plataforma e suporte geral."
  678 │ 
  679 │       Personalize suas respostas para criar uma experiência única e amigável para ${firstName}.`,
  680 │       timestamp: new Date()
  681 │     }
  682 │   ];
  683 │ }
  684 │ 
  685 │ // Função para gerar resposta usando a API Gemini
  686 │ export async function generateGeminiResponse(
  687 │   message: string, 
  688 │   sessionId: string,
  689 │   options?: { 
  690 │     intelligenceLevel?: 'basic' | 'normal' | 'advanced',
  691 │     languageStyle?: 'casual' | 'formal' | 'technical'
  692 │   }
  693 │ ): Promise<string> {
  694 │   try {
  695 │     // Obter contexto do usuário
  696 │     const userContext = await getUserContext();
  697 │ 
  698 │     // Usar o nome de usuário completo para respostas
  699 │     const usernameFull = userContext.username;
  700 │ 
  701 │     // Configuração da solicitação para a API Gemini
  702 │     const response = await axios.post(
  703 │       `${GEMINI_BASE_URL}?key=${GEMINI_API_KEY}`,
  704 │       {
  705 │         contents: [{
  706 │           parts: [
  707 │             {
  708 │               text: `Você é o Epictus IA do chat de suporte flutuante da Ponto.School, um assistente dedicado à navegação e suporte da plataforma. Você é DIFERENTE do Epictus IA do menu lateral.
  709 │ 
  710 │               Contexto do usuário:
  711 │               - Username completo: ${usernameFull}
  712 │               - Email: ${userContext.email}
  713 │               - Localização atual na plataforma: ${userContext.currentPage}
  714 │               - Última atividade: ${userContext.lastActivity}
  715 │ 
  716 │               DIRETRIZES DE COMUNICAÇÃO:
  717 │               1. Sempre se refira ao usuário pelo nome de usuário completo: "${usernameFull}". Use frases como "E aí, ${usernameFull}!", "Opa ${usernameFull}!", etc.
  718 │               2. Use uma linguagem mais informal e descontraída, como se estivesse conversando com um amigo.
  719 │               3. Seja amigável, use emojis ocasionalmente e mantenha um tom leve e positivo.
  720 │               4. Use gírias leves e expressões coloquiais quando apropriado.
  721 │ 
  722 │               LEMBRE-SE: Seu objetivo é servir como suporte para a plataforma, ajudando com navegação, tutoriais e respondendo dúvidas sobre todas as funcionalidades. Você NÃO é o assistente de estudos personalizados (que fica no menu lateral).
  723 │ 
  724 │               CONTEÚDO INSTITUCIONAL:
  725 │               Quando perguntado sobre os criadores, fundadores, donos, desenvolvedores, equipe administrativa ou qualquer pergunta relacionada à gestão da Ponto.School, responda:
  726 │               "A Ponto.School tem 4 administradores principais, além de equipes dedicadas de suporte, marketing, TI e outras áreas. São eles:
  727 │               - Fundador & CEO: João Fortes (@joaofortes) - usuário na plataforma Ponto.School
  728 │               - Co-Fundador & CMO: Felipe Brito (@felipe_rico) - usuário na plataforma Ponto.School
  729 │               - Co-Fundador & COO: Adriel Borges (@adriel_borges) - usuário na plataforma Ponto.School
  730 │               - Co-Fundador & Coordenador de Design: Samuel Afonso (@samuel_afonso) - usuário na plataforma Ponto.School"
  731 │ 
  732 │               REDIRECIONAMENTO:
  733 │               Quando o usuário pedir para ser redirecionado a uma seção da plataforma, SEMPRE inclua o link completo usando a base https://pontoschool.com/. Por exemplo:
  734 │               - Para o Portal: "Aqui está o link para o Portal: https://pontoschool.com/portal"
  735 │               - Para Agenda: "Você pode acessar sua agenda aqui: https://pontoschool.com/agenda"
  736 │               - Para Turmas: "Acesse suas turmas por este link: https://pontoschool.com/turmas"
  737 │ 
  738 │               Responda à seguinte pergunta do usuário ${usernameFull}: ${message}`
  739 │             }
  740 │           ]
  741 │         }],
  742 │         generationConfig: {
  743 │           temperature: 0.7,
  744 │           topP: 0.95,
  745 │           topK: 40
  746 │         }
  747 │       },
  748 │       {
  749 │         headers: {
  750 │           'Content-Type': 'application/json'
  751 │         }
  752 │       }
  753 │     );
  754 │ 
  755 │     // Extrai a resposta
  756 │     let aiResponse = response.data.candidates[0].content.parts[0].text;
  757 │ 
  758 │     // Verificar e corrigir links de redirecionamento
  759 │     aiResponse = fixPlatformLinks(aiResponse);
  760 │ 
  761 │     return aiResponse;
  762 │   } catch (error) {
  763 │     console.error('Erro ao gerar resposta com Gemini:', error);
  764 │     return "Desculpe, estou enfrentando dificuldades técnicas no momento. Por favor, tente novamente mais tarde ou entre em contato com nosso suporte técnico.";
  765 │   }
  766 │ }
  767 │ 
  768 │ // Função principal para gerar resposta, tentando primeiro xAI e depois Gemini como fallback
  769 │ export async function generateAIResponse(
  770 │   message: string, 
  771 │   sessionId: string, 
  772 │   options?: { 
  773 │     intelligenceLevel?: 'basic' | 'normal' | 'advanced',
  774 │     languageStyle?: 'casual' | 'formal' | 'technical'
  775 │   }
  776 │ ): Promise<string> {
  777 │   try {
  778 │     return await generateXAIResponse(message, sessionId, options);
  779 │   } catch (error) {
  780 │     console.error('Erro com xAI, tentando Gemini:', error);
  781 │     return generateGeminiResponse(message, sessionId, options);
  782 │   }
  783 │ }
  784 │ 
  785 │ // Limpar histórico da conversa
  786 │ export function clearConversationHistory(sessionId: string): void {
  787 │   if (conversationHistory[sessionId]) {
  788 │     // Mantém apenas a mensagem do sistema
  789 │     const systemMessage = conversationHistory[sessionId][0];
  790 │     conversationHistory[sessionId] = [systemMessage];
  791 │ 
  792 │     // Limpar do localStorage também
  793 │     try {
  794 │       localStorage.removeItem(`conversationHistory_${sessionId}`);
  795 │     } catch (error) {
  796 │       console.error("Erro ao limpar histórico do localStorage:", error);
  797 │     }
  798 │   }
  799 │ }
  800 │ 
  801 │ // Obter histórico da conversa
  802 │ export async function getConversationHistory(sessionId: string): Promise<ChatMessage[]> {
  803 │   try {
  804 │     // Primeiro verifica se já está carregado na memória e é válido
  805 │     if (conversationHistory[sessionId] && Array.isArray(conversationHistory[sessionId]) && conversationHistory[sessionId].length > 0) {
  806 │       // Verifica se há ao menos uma mensagem do sistema
  807 │       const hasSystemMessage = conversationHistory[sessionId].some(msg => msg.role === 'system');
  808 │ 
  809 │       if (hasSystemMessage) {
  810 │         return conversationHistory[sessionId];
  811 │       }
  812 │     }
  813 │ 
  814 │     // Tenta buscar dados adicionais do usuário para melhor armazenamento
  815 │     let userIdForStorage = '';
  816 │     try {
  817 │       const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
  818 │       userIdForStorage = sessionData?.session?.user?.id || '';
  819 │     } catch (e) {
  820 │       console.log('Erro ao obter ID do usuário:', e);
  821 │     }
  822 │ 
  823 │     // Tenta recuperar do localStorage usando vários formatos de chave
  824 │     const possibleKeys = [
  825 │       `conversationHistory_${sessionId}`,
  826 │       userIdForStorage ? `conversationHistory_${userIdForStorage}_${sessionId}` : null,
  827 │       `chat_history_${sessionId}`
  828 │     ].filter(Boolean);
  829 │ 
  830 │     let retrievedHistory = null;
  831 │ 
  832 │     // Tentar cada uma das possíveis chaves
  833 │     for (const key of possibleKeys) {
  834 │       try {
  835 │         const savedHistory = localStorage.getItem(key);
  836 │         if (savedHistory) {
  837 │           try {
  838 │             const parsedHistory = JSON.parse(savedHistory);
  839 │             if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
  840 │               retrievedHistory = parsedHistory;
  841 │               console.log(`Histórico recuperado com sucesso usando a chave: ${key}`);
  842 │               break;
  843 │             }
  844 │           } catch (parseError) {
  845 │             console.error(`Erro ao analisar histórico usando a chave ${key}:`, parseError);
  846 │           }
  847 │         }
  848 │       } catch (e) {
  849 │         console.error(`Erro ao tentar acessar o localStorage com a chave ${key}:`, e);
  850 │       }
  851 │     }
  852 │ 
  853 │     // Se encontrou histórico no localStorage
  854 │     if (retrievedHistory) {
  855 │       // Converter timestamps de string para Date e garantir formato adequado
  856 │       const processedHistory = retrievedHistory.map(msg => ({
  857 │         role: msg.role || 'user',
  858 │         content: msg.content || '',
  859 │         timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  860 │       }));
  861 │ 
  862 │       // Verificar se há mensagem do sistema
  863 │       const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  864 │ 
  865 │       if (!hasSystemMessage) {
  866 │         // Se não tiver mensagem do sistema, inicializar com uma nova
  867 │         const userContext = await getUserContext();
  868 │         initializeConversationHistory(sessionId, userContext);
  869 │ 
  870 │         // Adicionar as mensagens existentes (exceto mensagens do sistema já existentes)
  871 │         conversationHistory[sessionId] = [
  872 │           ...conversationHistory[sessionId],
  873 │           ...processedHistory.filter(msg => msg.role !== 'system')
  874 │         ];
  875 │       } else {
  876 │         conversationHistory[sessionId] = processedHistory;
  877 │       }
  878 │ 
  879 │       return conversationHistory[sessionId];
  880 │     }
  881 │ 
  882 │     // Se não encontrou no localStorage, tenta recuperar do Supabase
  883 │     try {
  884 │       const supabase = (await import('@/lib/supabase')).supabase;
  885 │       const { data: sessionData } = await supabase.auth.getSession();
  886 │       const userId = sessionData?.session?.user?.id;
  887 │ 
  888 │       if (userId) {
  889 │         try {
  890 │           // Verificar se a tabela existe antes de tentar consultar
  891 │           try {
  892 │             const { data: tableExists } = await supabase
  893 │               .from('information_schema.tables')
  894 │               .select('table_name')
  895 │               .eq('table_schema', 'public')
  896 │               .eq('table_name', 'ai_chat_history')
  897 │               .single();
  898 │ 
  899 │             if (!tableExists) {
  900 │               console.log('Tabela ai_chat_history não existe no Supabase.');
  901 │               throw new Error('Tabela não existe');
  902 │             }
  903 │           } catch (tableCheckError) {
  904 │             console.log('Erro ao verificar existência da tabela:', tableCheckError);
  905 │             throw tableCheckError;
  906 │           }
  907 │ 
  908 │           const { data, error } = await supabase
  909 │             .from('ai_chat_history')
  910 │             .select('messages')
  911 │             .eq('user_id', userId)
  912 │             .eq('session_id', sessionId)
  913 │             .single();
  914 │ 
  915 │           if (error) {
  916 │             console.error('Erro ao buscar histórico do Supabase:', error);
  917 │             throw error;
  918 │           }
  919 │ 
  920 │           if (data?.messages && Array.isArray(data.messages) && data.messages.length > 0) {
  921 │             // Converter timestamps de string para Date
  922 │             const processedHistory = data.messages.map(msg => ({
  923 │               role: msg.role || 'user',
  924 │               content: msg.content || '',
  925 │               timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  926 │             }));
  927 │ 
  928 │             // Verificar se há mensagem do sistema
  929 │             const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  930 │ 
  931 │             if (!hasSystemMessage) {
  932 │               // Se não tiver mensagem do sistema, inicializar com uma nova
  933 │               const userContext = await getUserContext();
  934 │               initializeConversationHistory(sessionId, userContext);
  935 │ 
  936 │               // Adicionar as mensagens existentes
  937 │               conversationHistory[sessionId] = [
  938 │                 ...conversationHistory[sessionId],
  939 │                 ...processedHistory.filter(msg => msg.role !== 'system')
  940 │               ];
  941 │             } else {
  942 │               conversationHistory[sessionId] = processedHistory;
  943 │             }
  944 │ 
  945 │             // Atualizar localStorage para sincronização
  946 │             try {
  947 │               localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(conversationHistory[sessionId]));
  948 │ 
  949 │               // Se temos o userId, também armazenar com chave mais específica
  950 │               if (userId) {
  951 │                 localStorage.setItem(`conversationHistory_${userId}_${sessionId}`, 
  952 │                   JSON.stringify(conversationHistory[sessionId]));
  953 │               }
  954 │             } catch (localStorageError) {
  955 │               console.log("Erro ao atualizar localStorage:", localStorageError);
  956 │             }
  957 │ 
  958 │             return conversationHistory[sessionId];
  959 │           }
  960 │         } catch (supabaseError) {
  961 │           console.error("Erro ao recuperar histórico do Supabase:", supabaseError);
  962 │         }
  963 │       }
  964 │     } catch (dbError) {
  965 │       console.error("Erro ao tentar acessar o banco de dados:", dbError);
  966 │     }
  967 │ 
  968 │     // Se chegou aqui, não foi possível recuperar o histórico
  969 │     // Inicializar com novo histórico
  970 │     console.log("Criando novo histórico de conversa para a sessão:", sessionId);
  971 │     const userContext = await getUserContext();
  972 │     initializeConversationHistory(sessionId, userContext);
  973 │ 
  974 │     // Salvar o histórico inicial
  975 │     try {
  976 │       localStorage.setItem(`conversationHistory_${sessionId}`, 
  977 │         JSON.stringify(conversationHistory[sessionId]));
  978 │ 
  979 │       // Se temos userIdForStorage, também armazenar com chave mais específica
  980 │       if (userIdForStorage) {
  981 │         localStorage.setItem(`conversationHistory_${userIdForStorage}_${sessionId}`, 
  982 │           JSON.stringify(conversationHistory[sessionId]));
  983 │       }
  984 │     } catch (e) {
  985 │       console.error("Erro ao salvar histórico inicial:", e);
  986 │     }
  987 │ 
  988 │     return conversationHistory[sessionId];
  989 │   } catch (generalError) {
  990 │     console.error("Erro geral ao obter histórico de conversa:", generalError);
  991 │ 
  992 │     // Retornar um histórico vazio em último caso
  993 │     return [{
  994 │       role: 'system',
  995 │       content: 'Você é o Epictus IA, o assistente inteligente da Ponto.School.',
  996 │       timestamp: new Date()
  997 │     }];
  998 │   }
  999 │ }
 1000 │ 
 1001 │ // Função para corrigir links da plataforma
 1002 │ function fixPlatformLinks(text: string): string {
 1003 │   const platformLinks = {
 1004 │     'Portal de Estudos': 'https://pontoschool.com/portal',
 1005 │     'Portal': 'https://pontoschool.com/portal',
 1006 │     'Agenda': 'https://pontoschool.com/agenda',
 1007 │     'Turmas': 'https://pontoschool.com/turmas',
 1008 │     'Biblioteca': 'https://pontoschool.com/biblioteca',
 1009 │     'Perfil': 'https://pontoschool.com/profile',
 1010 │     'Meu Perfil': 'https://pontoschool.com/profile',
 1011 │     'Configurações': 'https://pontoschool.com/configuracoes',
 1012 │     'Minhas Configurações': 'https://pontoschool.com/configuracoes',
 1013 │     'Dashboard': 'https://pontoschool.com/dashboard',
 1014 │     'Epictus IA': 'https://pontoschool.com/epictus-ia',
 1015 │     'Mentor IA': 'https://pontoschool.com/mentor-ia',
 1016 │     'Planos de Estudo': 'https://pontoschool.com/planos-estudo',
 1017 │     'Plano de Estudos': 'https://pontoschool.com/planos-estudo',
 1018 │     'Conquistas': 'https://pontoschool.com/conquistas',
 1019 │     'Minhas Conquistas': 'https://pontoschool.com/conquistas',
 1020 │     'Carteira': 'https://pontoschool.com/carteira',
 1021 │     'Minha Carteira': 'https://pontoschool.com/carteira',
 1022 │     'Mercado': 'https://pontoschool.com/mercado',
 1023 │     'Organização': 'https://pontoschool.com/organizacao',
 1024 │     'Comunidades': 'https://pontoschool.com/comunidades',
 1025 │     'Chat IA': 'https://pontoschool.com/chat-ia',
 1026 │     'School IA': 'https://pontoschool.com/school-ia',
 1027 │     'Novidades': 'https://pontoschool.com/novidades',
 1028 │     'Lembretes': 'https://pontoschool.com/lembretes',
 1029 │     'Pedidos de Ajuda': 'https://pontoschool.com/pedidos-ajuda',
 1030 │     'Estudos': 'https://pontoschool.com/estudos'
 1031 │   };
 1032 │ 
 1033 │   // Primeiro, procura por textos específicos que pedem redirecionamento
 1034 │   const redirectPatterns = [
 1035 │     /(?:me\s+(?:redirecione|encaminhe|leve|direcione|mande|envie)\s+(?:para|ao|à|a|até))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1036 │     /(?:quero\s+(?:ir|acessar|entrar|ver))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1037 │     /(?:me\s+(?:mostre|mostra))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1038 │     /(?:abrir?|abra|acesse|acessar|ver|veja)\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi
 1039 │   ];
 1040 │ 
 1041 │   // Aplicar padrões de redirecionamento de forma mais robusta
 1042 │   for (const pattern of redirectPatterns) {
 1043 │     text = text.replace(pattern, (match, sectionName) => {
 1044 │       if (!sectionName) return match;
 1045 │ 
 1046 │       const normalizedName = sectionName.trim();
 1047 │       // Verificar se o nome normalizado corresponde a alguma chave do objeto platformLinks
 1048 │       for (const key in platformLinks) {
 1049 │         if (normalizedName.toLowerCase() === key.toLowerCase() || 
 1050 │             key.toLowerCase().includes(normalizedName.toLowerCase()) || 
 1051 │             normalizedName.toLowerCase().includes(key.toLowerCase())) {
 1052 │           // Criar link em formato seguro sem possíveis bugs de formatação
 1053 │           return `Você pode acessar [${key}](${platformLinks[key]})`;
 1054 │         }
 1055 │       }
 1056 │       return match; // Se não encontrou correspondência, mantém o texto original
 1057 │     });
 1058 │   }
 1059 │ 
 1060 │   // Verificar se o texto já contém links markdown
 1061 │   const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
 1062 │   const existingLinks = [];
 1063 │   let match;
 1064 │ 
 1065 │   while ((match = markdownLinkRegex.exec(text)) !== null) {
 1066 │     existingLinks.push({
 1067 │       text: match[1],
 1068 │       url: match[2],
 1069 │       fullMatch: match[0]
 1070 │     });
 1071 │   }
 1072 │ 
 1073 │   // Depois, procurar menções a seções e converter para links (só se não forem já parte de um link)
 1074 │   let newText = text;
 1075 │ 
 1076 │   // Aplicar substituições de forma ordenada (das mais longas para as mais curtas)
 1077 │   const orderedKeys = Object.keys(platformLinks).sort((a, b) => b.length - a.length);
 1078 │ 
 1079 │   for (const key of orderedKeys) {
 1080 │     // Criar regex segura que não captura dentro de links existentes
 1081 │     const safeRegex = new RegExp(`(?<![\\[\\w])\\b(${escapeRegExp(key)})\\b(?![\\]\\w])`, 'g');
 1082 │ 
 1083 │     // Verificar cada ocorrência para garantir que não está dentro de um link existente
 1084 │     let lastIndex = 0;
 1085 │     let result = '';
 1086 │     let regexMatch;
 1087 │ 
 1088 │     while ((regexMatch = safeRegex.exec(newText)) !== null) {
 1089 │       const matchStart = regexMatch.index;
 1090 │       const matchEnd = matchStart + regexMatch[0].length;
 1091 │ 
 1092 │       // Verificar se esta ocorrência está dentro de algum link existente
 1093 │       let isInsideExistingLink = false;
 1094 │       for (const link of existingLinks) {
 1095 │         const linkIndex = newText.indexOf(link.fullMatch);
 1096 │         if (linkIndex <= matchStart && linkIndex + link.fullMatch.length >= matchEnd) {
 1097 │           isInsideExistingLink = true;
 1098 │           break;
 1099 │         }
 1100 │       }
 1101 │ 
 1102 │       if (!isInsideExistingLink) {
 1103 │         result += newText.substring(lastIndex, matchStart);
 1104 │         result += `[${regexMatch[1]}](${platformLinks[key]})`;
 1105 │         lastIndex = matchEnd;
 1106 │       }
 1107 │     }
 1108 │ 
 1109 │     if (lastIndex > 0) {
 1110 │       result += newText.substring(lastIndex);
 1111 │       newText = result;
 1112 │ 
 1113 │       // Atualizar a lista de links existentes
 1114 │       existingLinks.length = 0;
 1115 │       while ((match = markdownLinkRegex.exec(newText)) !== null) {
 1116 │         existingLinks.push({
 1117 │           text: match[1],
 1118 │           url: match[2],
 1119 │           fullMatch: match[0]
 1120 │         });
 1121 │       }
 1122 │     }
 1123 │   }
 1124 │ 
 1125 │   // Remover qualquer formatação incorreta que possa ter sido introduzida
 1126 │   newText = newText
 1127 │     .replace(/\]\(\[/g, ']([') // Corrigir links aninhados
 1128 │     .replace(/\]\(https:\/\/pontoschool\.com\/[a-z-]+\)\(https:\/\/pontoschool\.com\/[a-z-]+\)/g, match => {
 1129 │       // Extrair o primeiro link válido
 1130 │       const urlMatch = match.match(/\]\((https:\/\/pontoschool\.com\/[a-z-]+)\)/);
 1131 │       if (urlMatch && urlMatch[1]) {
 1132 │         return `](${urlMatch[1]})`;
 1133 │       }
 1134 │       return match;
 1135 │     });
 1136 │ 
 1137 │   return newText;
 1138 │ }
 1139 │ 
 1140 │ // Função auxiliar para escapar caracteres especiais em regex
 1141 │ function escapeRegExp(string) {
 1142 │   return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 1143 │ }
 1144 │ 
 1145 │ 
 1146 │ // Função para salvar o histórico da conversa no localStorage e sincronizar com Supabase
 1147 │ async function saveConversationHistory(sessionId: string, history: ChatMessage[]): Promise<void> {
 1148 │   try {
 1149 │     if (!sessionId || !history) {
 1150 │       console.error("Erro ao salvar histórico: sessionId ou history inválidos");
 1151 │       return;
 1152 │     }
 1153 │ 
 1154 │     // Salvar localmente
 1155 │     conversationHistory[sessionId] = history;
 1156 │ 
 1157 │     // Preparar o histórico para armazenamento (garantir que todos os objetos são serializáveis)
 1158 │     const serializableHistory = history.map(msg => ({
 1159 │       role: msg.role,
 1160 │       content: msg.content,
 1161 │       timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1162 │                 (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1163 │     }));
 1164 │ 
 1165 │     try {
 1166 │       // Salvar para o usuário atual com uma estrutura mais persistente
 1167 │       // Usar formato conversationHistory_USER_ID_sessionId quando possível
 1168 │       let storageKey = `conversationHistory_${sessionId}`;
 1169 │ 
 1170 │       // Tentar obter dados de identificação do usuário para melhor rastreamento
 1171 │       try {
 1172 │         const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
 1173 │         const userId = sessionData?.session?.user?.id;
 1174 │         if (userId) {
 1175 │           storageKey = `conversationHistory_${userId}_${sessionId}`;
 1176 │         }
 1177 │       } catch (e) {
 1178 │         console.log('Erro ao obter ID do usuário, usando chave padrão:', e);
 1179 │       }
 1180 │ 
 1181 │       // Salvar com uma chave mais específica para melhor identificação
 1182 │       localStorage.setItem(storageKey, JSON.stringify(serializableHistory));
 1183 │ 
 1184 │       // Para compatibilidade, também salvar com a chave antiga
 1185 │       localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(serializableHistory));
 1186 │ 
 1187 │       // Manter um índice de todas as conversas do usuário
 1188 │       try {
 1189 │         const userConversationsKey = 'userConversationsIndex';
 1190 │         let conversationsIndex = {};
 1191 │ 
 1192 │         const savedIndex = localStorage.getItem(userConversationsKey);
 1193 │         if (savedIndex) {
 1194 │           conversationsIndex = JSON.parse(savedIndex);
 1195 │         }
 1196 │ 
 1197 │         conversationsIndex[sessionId] = {
 1198 │           lastUpdated: new Date().toISOString(),
 1199 │           messageCount: serializableHistory.length,
 1200 │           title: serializableHistory.length > 1 ? 
 1201 │             serializableHistory[1].content.substring(0, 30) + "..." : 
 1202 │             "Nova conversa"
 1203 │         };
 1204 │ 
 1205 │         // Limitar o índice a 50 conversas mais recentes
 1206 │         const sortedEntries = Object.entries(conversationsIndex)
 1207 │           .sort((a, b) => new Date(b[1].lastUpdated).getTime() - new Date(a[1].lastUpdated).getTime())
 1208 │           .slice(0, 50);
 1209 │ 
 1210 │         const trimmedIndex = {};
 1211 │         sortedEntries.forEach(([key, value]) => {
 1212 │           trimmedIndex[key] = value;
 1213 │         });
 1214 │ 
 1215 │         localStorage.setItem(userConversationsKey, JSON.stringify(trimmedIndex));
 1216 │       } catch (indexError) {
 1217 │         console.error("Erro ao atualizar índice de conversas:", indexError);
 1218 │       }
 1219 │ 
 1220 │       // Salvar todas as sessões em um único item no localStorage com limite de tamanho
 1221 │       try {
 1222 │         const allSessions = {};
 1223 │         // Só armazenar as últimas 20 sessões
 1224 │         const sessionIds = Object.keys(conversationHistory).slice(-20);
 1225 │ 
 1226 │         for (const id of sessionIds) {
 1227 │           const sessionHistory = conversationHistory[id];
 1228 │           if (sessionHistory && sessionHistory.length > 0) {
 1229 │             // Limitar cada sessão a 100 mensagens para melhor contexto
 1230 │             allSessions[id] = sessionHistory.slice(-100).map(msg => ({
 1231 │               role: msg.role,
 1232 │               content: msg.content,
 1233 │               timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1234 │                         (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1235 │             }));
 1236 │           }
 1237 │         }
 1238 │ 
 1239 │         localStorage.setItem('aiChatSessions', JSON.stringify(allSessions));
 1240 │       } catch (batchSaveError) {
 1241 │         console.error("Erro ao salvar todas as sessões:", batchSaveError);
 1242 │       }
 1243 │     } catch (localStorageError) {
 1244 │       console.error("Erro ao salvar no localStorage:", localStorageError);
 1245 │       // Se falhar por exceder o limite, limpar o localStorage e tentar novamente só com a sessão atual
 1246 │       try {
 1247 │         localStorage.removeItem('aiChatSessions');
 1248 │         localStorage.setItem(`conversationHistory_${sessionId}`, 
 1249 │           JSON.stringify(serializableHistory.slice(-50))); // Salvar só as últimas 50 mensagens
 1250 │       } catch (retryError) {
 1251 │         console.error("Falha na segunda tentativa de salvar no localStorage:", retryError);
 1252 │       }
 1253 │     }
 1254 │ 
 1255 │     // Sincronizar com Supabase se disponível
 1256 │     try {
 1257 │       const supabase = (await import('@/lib/supabase')).supabase;
 1258 │       const { data: sessionData } = await supabase.auth.getSession();
 1259 │       const userId = sessionData?.session?.user?.id;
 1260 │ 
 1261 │       if (userId) {
 1262 │         try {
 1263 │           // Criar tabela ai_chat_history se não existir (verificar primeiro)
 1264 │           const { data: tablesData } = await supabase
 1265 │             .from('information_schema.tables')
 1266 │             .select('table_name')
 1267 │             .eq('table_schema', 'public')
 1268 │             .eq('table_name', 'ai_chat_history');
 1269 │ 
 1270 │           if (!tablesData || tablesData.length === 0) {
 1271 │             // Tabela não existe, tentar criar usando rpc
 1272 │             try {
 1273 │               await supabase.rpc('execute_sql', {
 1274 │                 sql_statement: `
 1275 │                   CREATE TABLE IF NOT EXISTS public.ai_chat_history (
 1276 │                     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
 1277 │                     user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
 1278 │                     session_id TEXT NOT NULL,
 1279 │                     messages JSONB NOT NULL DEFAULT '[]'::jsonb,
 1280 │                     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1281 │                     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1282 │                     UNIQUE (user_id, session_id)
 1283 │                   );
 1284 │ 
 1285 │                   CREATE INDEX IF NOT EXISTS ai_chat_history_user_id_idx ON public.ai_chat_history(user_id);
 1286 │                   CREATE INDEX IF NOT EXISTS ai_chat_history_session_id_idx ON public.ai_chat_history(session_id);
 1287 │                 `
 1288 │               });
 1289 │             } catch (createTableError) {
 1290 │               console.log('Erro ao criar tabela ai_chat_history:', createTableError);
 1291 │             }
 1292 │           }
 1293 │ 
 1294 │           // Upsert do histórico da conversa
 1295 │           const { error } = await supabase
 1296 │             .from('ai_chat_history')
 1297 │             .upsert({
 1298 │               user_id: userId,
 1299 │               session_id: sessionId,
 1300 │               messages: serializableHistory.slice(-100), // Armazenar até 100 mensagens
 1301 │               updated_at: new Date().toISOString()
 1302 │             }, {
 1303 │               onConflict: 'user_id,session_id'
 1304 │             });
 1305 │ 
 1306 │           if (error) {
 1307 │             console.error("Erro ao sincronizar histórico com Supabase:", error);
 1308 │           }
 1309 │         } catch (upsertError) {
 1310 │           console.error("Erro no upsert do histórico:", upsertError);
 1311 │         }
 1312 │       }
 1313 │     } catch (syncError) {
 1314 │       console.log("Supabase não disponível para sincronização:", syncError);
 1315 │     }
 1316 │   } catch (error) {
 1317 │     console.error("Erro ao salvar o histórico da conversa:", error);
 1318 │   }
 1319 │ }
 1320 │ 
 1321 │ // Simulação de resposta da IA
 1322 │ const getResponseForMessage = (message: string): string => {
 1323 │   // Análise básica da mensagem para gerar uma resposta contextual
 1324 │   const formattedMessage = message.toLowerCase();
 1325 │ 
 1326 │   if (formattedMessage.includes('olá') || formattedMessage.includes('oi') || formattedMessage.includes('bom dia') || formattedMessage.includes('boa tarde') || formattedMessage.includes('boa noite')) {
 1327 │     return `**Olá, ${userInfo?.username || 'amigo'}!** 😊\n\nComo posso ajudar você hoje?`;
 1328 │   } else if (formattedMessage.includes('função') || formattedMessage.includes('o que você faz') || formattedMessage.includes('para que serve')) {
 1329 │     return `**Eu sou Epictus IA**, seu assistente para a plataforma Ponto.School! 🚀\n\nPosso ajudar com:\n\n• **Informações** sobre cursos e conteúdos\n• **Dicas de estudos** personalizadas\n• **Navegação** na plataforma\n• **Respostas** para dúvidas gerais\n\nComo posso ajudar você agora?`;
 1330 │   } else if (formattedMessage.includes('portal') || formattedMessage.includes('material') || formattedMessage.includes('acessar conteúdo')) {
 1331 │     return `Você pode acessar o **Portal** com todos os materiais em https://pontoschool.com/portal\n\nLá você encontrará todos os seus cursos, materiais e recursos de estudo organizados por disciplina.\n\n_Basta clicar no link acima para ir direto para o Portal!_ 📚`;
 1332 │   } else {
 1333 │     return "Desculpe, não entendi sua pergunta. Pode reformulá-la?";
 1334 │   }
 1335 │ };
 1336 │ 
 1337 │ import { supabase } from "@/lib/supabase";
 1338 │ import * as aiChatDB from "./aiChatDatabaseService";
 1339 │ 
 1340 │ interface ChatMessage {
 1341 │   role: 'system' | 'user' | 'assistant';
 1342 │   content: string;
 1343 │ }
 1344 │ 
 1345 │ // Armazenamento temporário de histórico de chat no navegador
 1346 │ const conversationHistory: Record<string, ChatMessage[]> = {};
      ·       ─────────┬─────────
      ·                ╰── `conversationHistory` redefined here
 1347 │ 
 1348 │ // Limpar histórico de conversa específica
 1349 │ export const clearConversationHistory = (sessionId: string) => {
      ╰────

  × the name `clearConversationHistory` is defined multiple times
      ╭─[/home/runner/workspace/src/services/aiChatService.ts:783:1]
  783 │ }
  784 │ 
  785 │ // Limpar histórico da conversa
  786 │ export function clearConversationHistory(sessionId: string): void {
      ·                 ────────────┬───────────
      ·                             ╰── previous definition of `clearConversationHistory` here
  787 │   if (conversationHistory[sessionId]) {
  788 │     // Mantém apenas a mensagem do sistema
  789 │     const systemMessage = conversationHistory[sessionId][0];
  790 │     conversationHistory[sessionId] = [systemMessage];
  791 │ 
  792 │     // Limpar do localStorage também
  793 │     try {
  794 │       localStorage.removeItem(`conversationHistory_${sessionId}`);
  795 │     } catch (error) {
  796 │       console.error("Erro ao limpar histórico do localStorage:", error);
  797 │     }
  798 │   }
  799 │ }
  800 │ 
  801 │ // Obter histórico da conversa
  802 │ export async function getConversationHistory(sessionId: string): Promise<ChatMessage[]> {
  803 │   try {
  804 │     // Primeiro verifica se já está carregado na memória e é válido
  805 │     if (conversationHistory[sessionId] && Array.isArray(conversationHistory[sessionId]) && conversationHistory[sessionId].length > 0) {
  806 │       // Verifica se há ao menos uma mensagem do sistema
  807 │       const hasSystemMessage = conversationHistory[sessionId].some(msg => msg.role === 'system');
  808 │ 
  809 │       if (hasSystemMessage) {
  810 │         return conversationHistory[sessionId];
  811 │       }
  812 │     }
  813 │ 
  814 │     // Tenta buscar dados adicionais do usuário para melhor armazenamento
  815 │     let userIdForStorage = '';
  816 │     try {
  817 │       const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
  818 │       userIdForStorage = sessionData?.session?.user?.id || '';
  819 │     } catch (e) {
  820 │       console.log('Erro ao obter ID do usuário:', e);
  821 │     }
  822 │ 
  823 │     // Tenta recuperar do localStorage usando vários formatos de chave
  824 │     const possibleKeys = [
  825 │       `conversationHistory_${sessionId}`,
  826 │       userIdForStorage ? `conversationHistory_${userIdForStorage}_${sessionId}` : null,
  827 │       `chat_history_${sessionId}`
  828 │     ].filter(Boolean);
  829 │ 
  830 │     let retrievedHistory = null;
  831 │ 
  832 │     // Tentar cada uma das possíveis chaves
  833 │     for (const key of possibleKeys) {
  834 │       try {
  835 │         const savedHistory = localStorage.getItem(key);
  836 │         if (savedHistory) {
  837 │           try {
  838 │             const parsedHistory = JSON.parse(savedHistory);
  839 │             if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
  840 │               retrievedHistory = parsedHistory;
  841 │               console.log(`Histórico recuperado com sucesso usando a chave: ${key}`);
  842 │               break;
  843 │             }
  844 │           } catch (parseError) {
  845 │             console.error(`Erro ao analisar histórico usando a chave ${key}:`, parseError);
  846 │           }
  847 │         }
  848 │       } catch (e) {
  849 │         console.error(`Erro ao tentar acessar o localStorage com a chave ${key}:`, e);
  850 │       }
  851 │     }
  852 │ 
  853 │     // Se encontrou histórico no localStorage
  854 │     if (retrievedHistory) {
  855 │       // Converter timestamps de string para Date e garantir formato adequado
  856 │       const processedHistory = retrievedHistory.map(msg => ({
  857 │         role: msg.role || 'user',
  858 │         content: msg.content || '',
  859 │         timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  860 │       }));
  861 │ 
  862 │       // Verificar se há mensagem do sistema
  863 │       const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  864 │ 
  865 │       if (!hasSystemMessage) {
  866 │         // Se não tiver mensagem do sistema, inicializar com uma nova
  867 │         const userContext = await getUserContext();
  868 │         initializeConversationHistory(sessionId, userContext);
  869 │ 
  870 │         // Adicionar as mensagens existentes (exceto mensagens do sistema já existentes)
  871 │         conversationHistory[sessionId] = [
  872 │           ...conversationHistory[sessionId],
  873 │           ...processedHistory.filter(msg => msg.role !== 'system')
  874 │         ];
  875 │       } else {
  876 │         conversationHistory[sessionId] = processedHistory;
  877 │       }
  878 │ 
  879 │       return conversationHistory[sessionId];
  880 │     }
  881 │ 
  882 │     // Se não encontrou no localStorage, tenta recuperar do Supabase
  883 │     try {
  884 │       const supabase = (await import('@/lib/supabase')).supabase;
  885 │       const { data: sessionData } = await supabase.auth.getSession();
  886 │       const userId = sessionData?.session?.user?.id;
  887 │ 
  888 │       if (userId) {
  889 │         try {
  890 │           // Verificar se a tabela existe antes de tentar consultar
  891 │           try {
  892 │             const { data: tableExists } = await supabase
  893 │               .from('information_schema.tables')
  894 │               .select('table_name')
  895 │               .eq('table_schema', 'public')
  896 │               .eq('table_name', 'ai_chat_history')
  897 │               .single();
  898 │ 
  899 │             if (!tableExists) {
  900 │               console.log('Tabela ai_chat_history não existe no Supabase.');
  901 │               throw new Error('Tabela não existe');
  902 │             }
  903 │           } catch (tableCheckError) {
  904 │             console.log('Erro ao verificar existência da tabela:', tableCheckError);
  905 │             throw tableCheckError;
  906 │           }
  907 │ 
  908 │           const { data, error } = await supabase
  909 │             .from('ai_chat_history')
  910 │             .select('messages')
  911 │             .eq('user_id', userId)
  912 │             .eq('session_id', sessionId)
  913 │             .single();
  914 │ 
  915 │           if (error) {
  916 │             console.error('Erro ao buscar histórico do Supabase:', error);
  917 │             throw error;
  918 │           }
  919 │ 
  920 │           if (data?.messages && Array.isArray(data.messages) && data.messages.length > 0) {
  921 │             // Converter timestamps de string para Date
  922 │             const processedHistory = data.messages.map(msg => ({
  923 │               role: msg.role || 'user',
  924 │               content: msg.content || '',
  925 │               timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  926 │             }));
  927 │ 
  928 │             // Verificar se há mensagem do sistema
  929 │             const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  930 │ 
  931 │             if (!hasSystemMessage) {
  932 │               // Se não tiver mensagem do sistema, inicializar com uma nova
  933 │               const userContext = await getUserContext();
  934 │               initializeConversationHistory(sessionId, userContext);
  935 │ 
  936 │               // Adicionar as mensagens existentes
  937 │               conversationHistory[sessionId] = [
  938 │                 ...conversationHistory[sessionId],
  939 │                 ...processedHistory.filter(msg => msg.role !== 'system')
  940 │               ];
  941 │             } else {
  942 │               conversationHistory[sessionId] = processedHistory;
  943 │             }
  944 │ 
  945 │             // Atualizar localStorage para sincronização
  946 │             try {
  947 │               localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(conversationHistory[sessionId]));
  948 │ 
  949 │               // Se temos o userId, também armazenar com chave mais específica
  950 │               if (userId) {
  951 │                 localStorage.setItem(`conversationHistory_${userId}_${sessionId}`, 
  952 │                   JSON.stringify(conversationHistory[sessionId]));
  953 │               }
  954 │             } catch (localStorageError) {
  955 │               console.log("Erro ao atualizar localStorage:", localStorageError);
  956 │             }
  957 │ 
  958 │             return conversationHistory[sessionId];
  959 │           }
  960 │         } catch (supabaseError) {
  961 │           console.error("Erro ao recuperar histórico do Supabase:", supabaseError);
  962 │         }
  963 │       }
  964 │     } catch (dbError) {
  965 │       console.error("Erro ao tentar acessar o banco de dados:", dbError);
  966 │     }
  967 │ 
  968 │     // Se chegou aqui, não foi possível recuperar o histórico
  969 │     // Inicializar com novo histórico
  970 │     console.log("Criando novo histórico de conversa para a sessão:", sessionId);
  971 │     const userContext = await getUserContext();
  972 │     initializeConversationHistory(sessionId, userContext);
  973 │ 
  974 │     // Salvar o histórico inicial
  975 │     try {
  976 │       localStorage.setItem(`conversationHistory_${sessionId}`, 
  977 │         JSON.stringify(conversationHistory[sessionId]));
  978 │ 
  979 │       // Se temos userIdForStorage, também armazenar com chave mais específica
  980 │       if (userIdForStorage) {
  981 │         localStorage.setItem(`conversationHistory_${userIdForStorage}_${sessionId}`, 
  982 │           JSON.stringify(conversationHistory[sessionId]));
  983 │       }
  984 │     } catch (e) {
  985 │       console.error("Erro ao salvar histórico inicial:", e);
  986 │     }
  987 │ 
  988 │     return conversationHistory[sessionId];
  989 │   } catch (generalError) {
  990 │     console.error("Erro geral ao obter histórico de conversa:", generalError);
  991 │ 
  992 │     // Retornar um histórico vazio em último caso
  993 │     return [{
  994 │       role: 'system',
  995 │       content: 'Você é o Epictus IA, o assistente inteligente da Ponto.School.',
  996 │       timestamp: new Date()
  997 │     }];
  998 │   }
  999 │ }
 1000 │ 
 1001 │ // Função para corrigir links da plataforma
 1002 │ function fixPlatformLinks(text: string): string {
 1003 │   const platformLinks = {
 1004 │     'Portal de Estudos': 'https://pontoschool.com/portal',
 1005 │     'Portal': 'https://pontoschool.com/portal',
 1006 │     'Agenda': 'https://pontoschool.com/agenda',
 1007 │     'Turmas': 'https://pontoschool.com/turmas',
 1008 │     'Biblioteca': 'https://pontoschool.com/biblioteca',
 1009 │     'Perfil': 'https://pontoschool.com/profile',
 1010 │     'Meu Perfil': 'https://pontoschool.com/profile',
 1011 │     'Configurações': 'https://pontoschool.com/configuracoes',
 1012 │     'Minhas Configurações': 'https://pontoschool.com/configuracoes',
 1013 │     'Dashboard': 'https://pontoschool.com/dashboard',
 1014 │     'Epictus IA': 'https://pontoschool.com/epictus-ia',
 1015 │     'Mentor IA': 'https://pontoschool.com/mentor-ia',
 1016 │     'Planos de Estudo': 'https://pontoschool.com/planos-estudo',
 1017 │     'Plano de Estudos': 'https://pontoschool.com/planos-estudo',
 1018 │     'Conquistas': 'https://pontoschool.com/conquistas',
 1019 │     'Minhas Conquistas': 'https://pontoschool.com/conquistas',
 1020 │     'Carteira': 'https://pontoschool.com/carteira',
 1021 │     'Minha Carteira': 'https://pontoschool.com/carteira',
 1022 │     'Mercado': 'https://pontoschool.com/mercado',
 1023 │     'Organização': 'https://pontoschool.com/organizacao',
 1024 │     'Comunidades': 'https://pontoschool.com/comunidades',
 1025 │     'Chat IA': 'https://pontoschool.com/chat-ia',
 1026 │     'School IA': 'https://pontoschool.com/school-ia',
 1027 │     'Novidades': 'https://pontoschool.com/novidades',
 1028 │     'Lembretes': 'https://pontoschool.com/lembretes',
 1029 │     'Pedidos de Ajuda': 'https://pontoschool.com/pedidos-ajuda',
 1030 │     'Estudos': 'https://pontoschool.com/estudos'
 1031 │   };
 1032 │ 
 1033 │   // Primeiro, procura por textos específicos que pedem redirecionamento
 1034 │   const redirectPatterns = [
 1035 │     /(?:me\s+(?:redirecione|encaminhe|leve|direcione|mande|envie)\s+(?:para|ao|à|a|até))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1036 │     /(?:quero\s+(?:ir|acessar|entrar|ver))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1037 │     /(?:me\s+(?:mostre|mostra))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1038 │     /(?:abrir?|abra|acesse|acessar|ver|veja)\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi
 1039 │   ];
 1040 │ 
 1041 │   // Aplicar padrões de redirecionamento de forma mais robusta
 1042 │   for (const pattern of redirectPatterns) {
 1043 │     text = text.replace(pattern, (match, sectionName) => {
 1044 │       if (!sectionName) return match;
 1045 │ 
 1046 │       const normalizedName = sectionName.trim();
 1047 │       // Verificar se o nome normalizado corresponde a alguma chave do objeto platformLinks
 1048 │       for (const key in platformLinks) {
 1049 │         if (normalizedName.toLowerCase() === key.toLowerCase() || 
 1050 │             key.toLowerCase().includes(normalizedName.toLowerCase()) || 
 1051 │             normalizedName.toLowerCase().includes(key.toLowerCase())) {
 1052 │           // Criar link em formato seguro sem possíveis bugs de formatação
 1053 │           return `Você pode acessar [${key}](${platformLinks[key]})`;
 1054 │         }
 1055 │       }
 1056 │       return match; // Se não encontrou correspondência, mantém o texto original
 1057 │     });
 1058 │   }
 1059 │ 
 1060 │   // Verificar se o texto já contém links markdown
 1061 │   const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
 1062 │   const existingLinks = [];
 1063 │   let match;
 1064 │ 
 1065 │   while ((match = markdownLinkRegex.exec(text)) !== null) {
 1066 │     existingLinks.push({
 1067 │       text: match[1],
 1068 │       url: match[2],
 1069 │       fullMatch: match[0]
 1070 │     });
 1071 │   }
 1072 │ 
 1073 │   // Depois, procurar menções a seções e converter para links (só se não forem já parte de um link)
 1074 │   let newText = text;
 1075 │ 
 1076 │   // Aplicar substituições de forma ordenada (das mais longas para as mais curtas)
 1077 │   const orderedKeys = Object.keys(platformLinks).sort((a, b) => b.length - a.length);
 1078 │ 
 1079 │   for (const key of orderedKeys) {
 1080 │     // Criar regex segura que não captura dentro de links existentes
 1081 │     const safeRegex = new RegExp(`(?<![\\[\\w])\\b(${escapeRegExp(key)})\\b(?![\\]\\w])`, 'g');
 1082 │ 
 1083 │     // Verificar cada ocorrência para garantir que não está dentro de um link existente
 1084 │     let lastIndex = 0;
 1085 │     let result = '';
 1086 │     let regexMatch;
 1087 │ 
 1088 │     while ((regexMatch = safeRegex.exec(newText)) !== null) {
 1089 │       const matchStart = regexMatch.index;
 1090 │       const matchEnd = matchStart + regexMatch[0].length;
 1091 │ 
 1092 │       // Verificar se esta ocorrência está dentro de algum link existente
 1093 │       let isInsideExistingLink = false;
 1094 │       for (const link of existingLinks) {
 1095 │         const linkIndex = newText.indexOf(link.fullMatch);
 1096 │         if (linkIndex <= matchStart && linkIndex + link.fullMatch.length >= matchEnd) {
 1097 │           isInsideExistingLink = true;
 1098 │           break;
 1099 │         }
 1100 │       }
 1101 │ 
 1102 │       if (!isInsideExistingLink) {
 1103 │         result += newText.substring(lastIndex, matchStart);
 1104 │         result += `[${regexMatch[1]}](${platformLinks[key]})`;
 1105 │         lastIndex = matchEnd;
 1106 │       }
 1107 │     }
 1108 │ 
 1109 │     if (lastIndex > 0) {
 1110 │       result += newText.substring(lastIndex);
 1111 │       newText = result;
 1112 │ 
 1113 │       // Atualizar a lista de links existentes
 1114 │       existingLinks.length = 0;
 1115 │       while ((match = markdownLinkRegex.exec(newText)) !== null) {
 1116 │         existingLinks.push({
 1117 │           text: match[1],
 1118 │           url: match[2],
 1119 │           fullMatch: match[0]
 1120 │         });
 1121 │       }
 1122 │     }
 1123 │   }
 1124 │ 
 1125 │   // Remover qualquer formatação incorreta que possa ter sido introduzida
 1126 │   newText = newText
 1127 │     .replace(/\]\(\[/g, ']([') // Corrigir links aninhados
 1128 │     .replace(/\]\(https:\/\/pontoschool\.com\/[a-z-]+\)\(https:\/\/pontoschool\.com\/[a-z-]+\)/g, match => {
 1129 │       // Extrair o primeiro link válido
 1130 │       const urlMatch = match.match(/\]\((https:\/\/pontoschool\.com\/[a-z-]+)\)/);
 1131 │       if (urlMatch && urlMatch[1]) {
 1132 │         return `](${urlMatch[1]})`;
 1133 │       }
 1134 │       return match;
 1135 │     });
 1136 │ 
 1137 │   return newText;
 1138 │ }
 1139 │ 
 1140 │ // Função auxiliar para escapar caracteres especiais em regex
 1141 │ function escapeRegExp(string) {
 1142 │   return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 1143 │ }
 1144 │ 
 1145 │ 
 1146 │ // Função para salvar o histórico da conversa no localStorage e sincronizar com Supabase
 1147 │ async function saveConversationHistory(sessionId: string, history: ChatMessage[]): Promise<void> {
 1148 │   try {
 1149 │     if (!sessionId || !history) {
 1150 │       console.error("Erro ao salvar histórico: sessionId ou history inválidos");
 1151 │       return;
 1152 │     }
 1153 │ 
 1154 │     // Salvar localmente
 1155 │     conversationHistory[sessionId] = history;
 1156 │ 
 1157 │     // Preparar o histórico para armazenamento (garantir que todos os objetos são serializáveis)
 1158 │     const serializableHistory = history.map(msg => ({
 1159 │       role: msg.role,
 1160 │       content: msg.content,
 1161 │       timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1162 │                 (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1163 │     }));
 1164 │ 
 1165 │     try {
 1166 │       // Salvar para o usuário atual com uma estrutura mais persistente
 1167 │       // Usar formato conversationHistory_USER_ID_sessionId quando possível
 1168 │       let storageKey = `conversationHistory_${sessionId}`;
 1169 │ 
 1170 │       // Tentar obter dados de identificação do usuário para melhor rastreamento
 1171 │       try {
 1172 │         const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
 1173 │         const userId = sessionData?.session?.user?.id;
 1174 │         if (userId) {
 1175 │           storageKey = `conversationHistory_${userId}_${sessionId}`;
 1176 │         }
 1177 │       } catch (e) {
 1178 │         console.log('Erro ao obter ID do usuário, usando chave padrão:', e);
 1179 │       }
 1180 │ 
 1181 │       // Salvar com uma chave mais específica para melhor identificação
 1182 │       localStorage.setItem(storageKey, JSON.stringify(serializableHistory));
 1183 │ 
 1184 │       // Para compatibilidade, também salvar com a chave antiga
 1185 │       localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(serializableHistory));
 1186 │ 
 1187 │       // Manter um índice de todas as conversas do usuário
 1188 │       try {
 1189 │         const userConversationsKey = 'userConversationsIndex';
 1190 │         let conversationsIndex = {};
 1191 │ 
 1192 │         const savedIndex = localStorage.getItem(userConversationsKey);
 1193 │         if (savedIndex) {
 1194 │           conversationsIndex = JSON.parse(savedIndex);
 1195 │         }
 1196 │ 
 1197 │         conversationsIndex[sessionId] = {
 1198 │           lastUpdated: new Date().toISOString(),
 1199 │           messageCount: serializableHistory.length,
 1200 │           title: serializableHistory.length > 1 ? 
 1201 │             serializableHistory[1].content.substring(0, 30) + "..." : 
 1202 │             "Nova conversa"
 1203 │         };
 1204 │ 
 1205 │         // Limitar o índice a 50 conversas mais recentes
 1206 │         const sortedEntries = Object.entries(conversationsIndex)
 1207 │           .sort((a, b) => new Date(b[1].lastUpdated).getTime() - new Date(a[1].lastUpdated).getTime())
 1208 │           .slice(0, 50);
 1209 │ 
 1210 │         const trimmedIndex = {};
 1211 │         sortedEntries.forEach(([key, value]) => {
 1212 │           trimmedIndex[key] = value;
 1213 │         });
 1214 │ 
 1215 │         localStorage.setItem(userConversationsKey, JSON.stringify(trimmedIndex));
 1216 │       } catch (indexError) {
 1217 │         console.error("Erro ao atualizar índice de conversas:", indexError);
 1218 │       }
 1219 │ 
 1220 │       // Salvar todas as sessões em um único item no localStorage com limite de tamanho
 1221 │       try {
 1222 │         const allSessions = {};
 1223 │         // Só armazenar as últimas 20 sessões
 1224 │         const sessionIds = Object.keys(conversationHistory).slice(-20);
 1225 │ 
 1226 │         for (const id of sessionIds) {
 1227 │           const sessionHistory = conversationHistory[id];
 1228 │           if (sessionHistory && sessionHistory.length > 0) {
 1229 │             // Limitar cada sessão a 100 mensagens para melhor contexto
 1230 │             allSessions[id] = sessionHistory.slice(-100).map(msg => ({
 1231 │               role: msg.role,
 1232 │               content: msg.content,
 1233 │               timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1234 │                         (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1235 │             }));
 1236 │           }
 1237 │         }
 1238 │ 
 1239 │         localStorage.setItem('aiChatSessions', JSON.stringify(allSessions));
 1240 │       } catch (batchSaveError) {
 1241 │         console.error("Erro ao salvar todas as sessões:", batchSaveError);
 1242 │       }
 1243 │     } catch (localStorageError) {
 1244 │       console.error("Erro ao salvar no localStorage:", localStorageError);
 1245 │       // Se falhar por exceder o limite, limpar o localStorage e tentar novamente só com a sessão atual
 1246 │       try {
 1247 │         localStorage.removeItem('aiChatSessions');
 1248 │         localStorage.setItem(`conversationHistory_${sessionId}`, 
 1249 │           JSON.stringify(serializableHistory.slice(-50))); // Salvar só as últimas 50 mensagens
 1250 │       } catch (retryError) {
 1251 │         console.error("Falha na segunda tentativa de salvar no localStorage:", retryError);
 1252 │       }
 1253 │     }
 1254 │ 
 1255 │     // Sincronizar com Supabase se disponível
 1256 │     try {
 1257 │       const supabase = (await import('@/lib/supabase')).supabase;
 1258 │       const { data: sessionData } = await supabase.auth.getSession();
 1259 │       const userId = sessionData?.session?.user?.id;
 1260 │ 
 1261 │       if (userId) {
 1262 │         try {
 1263 │           // Criar tabela ai_chat_history se não existir (verificar primeiro)
 1264 │           const { data: tablesData } = await supabase
 1265 │             .from('information_schema.tables')
 1266 │             .select('table_name')
 1267 │             .eq('table_schema', 'public')
 1268 │             .eq('table_name', 'ai_chat_history');
 1269 │ 
 1270 │           if (!tablesData || tablesData.length === 0) {
 1271 │             // Tabela não existe, tentar criar usando rpc
 1272 │             try {
 1273 │               await supabase.rpc('execute_sql', {
 1274 │                 sql_statement: `
 1275 │                   CREATE TABLE IF NOT EXISTS public.ai_chat_history (
 1276 │                     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
 1277 │                     user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
 1278 │                     session_id TEXT NOT NULL,
 1279 │                     messages JSONB NOT NULL DEFAULT '[]'::jsonb,
 1280 │                     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1281 │                     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1282 │                     UNIQUE (user_id, session_id)
 1283 │                   );
 1284 │ 
 1285 │                   CREATE INDEX IF NOT EXISTS ai_chat_history_user_id_idx ON public.ai_chat_history(user_id);
 1286 │                   CREATE INDEX IF NOT EXISTS ai_chat_history_session_id_idx ON public.ai_chat_history(session_id);
 1287 │                 `
 1288 │               });
 1289 │             } catch (createTableError) {
 1290 │               console.log('Erro ao criar tabela ai_chat_history:', createTableError);
 1291 │             }
 1292 │           }
 1293 │ 
 1294 │           // Upsert do histórico da conversa
 1295 │           const { error } = await supabase
 1296 │             .from('ai_chat_history')
 1297 │             .upsert({
 1298 │               user_id: userId,
 1299 │               session_id: sessionId,
 1300 │               messages: serializableHistory.slice(-100), // Armazenar até 100 mensagens
 1301 │               updated_at: new Date().toISOString()
 1302 │             }, {
 1303 │               onConflict: 'user_id,session_id'
 1304 │             });
 1305 │ 
 1306 │           if (error) {
 1307 │             console.error("Erro ao sincronizar histórico com Supabase:", error);
 1308 │           }
 1309 │         } catch (upsertError) {
 1310 │           console.error("Erro no upsert do histórico:", upsertError);
 1311 │         }
 1312 │       }
 1313 │     } catch (syncError) {
 1314 │       console.log("Supabase não disponível para sincronização:", syncError);
 1315 │     }
 1316 │   } catch (error) {
 1317 │     console.error("Erro ao salvar o histórico da conversa:", error);
 1318 │   }
 1319 │ }
 1320 │ 
 1321 │ // Simulação de resposta da IA
 1322 │ const getResponseForMessage = (message: string): string => {
 1323 │   // Análise básica da mensagem para gerar uma resposta contextual
 1324 │   const formattedMessage = message.toLowerCase();
 1325 │ 
 1326 │   if (formattedMessage.includes('olá') || formattedMessage.includes('oi') || formattedMessage.includes('bom dia') || formattedMessage.includes('boa tarde') || formattedMessage.includes('boa noite')) {
 1327 │     return `**Olá, ${userInfo?.username || 'amigo'}!** 😊\n\nComo posso ajudar você hoje?`;
 1328 │   } else if (formattedMessage.includes('função') || formattedMessage.includes('o que você faz') || formattedMessage.includes('para que serve')) {
 1329 │     return `**Eu sou Epictus IA**, seu assistente para a plataforma Ponto.School! 🚀\n\nPosso ajudar com:\n\n• **Informações** sobre cursos e conteúdos\n• **Dicas de estudos** personalizadas\n• **Navegação** na plataforma\n• **Respostas** para dúvidas gerais\n\nComo posso ajudar você agora?`;
 1330 │   } else if (formattedMessage.includes('portal') || formattedMessage.includes('material') || formattedMessage.includes('acessar conteúdo')) {
 1331 │     return `Você pode acessar o **Portal** com todos os materiais em https://pontoschool.com/portal\n\nLá você encontrará todos os seus cursos, materiais e recursos de estudo organizados por disciplina.\n\n_Basta clicar no link acima para ir direto para o Portal!_ 📚`;
 1332 │   } else {
 1333 │     return "Desculpe, não entendi sua pergunta. Pode reformulá-la?";
 1334 │   }
 1335 │ };
 1336 │ 
 1337 │ import { supabase } from "@/lib/supabase";
 1338 │ import * as aiChatDB from "./aiChatDatabaseService";
 1339 │ 
 1340 │ interface ChatMessage {
 1341 │   role: 'system' | 'user' | 'assistant';
 1342 │   content: string;
 1343 │ }
 1344 │ 
 1345 │ // Armazenamento temporário de histórico de chat no navegador
 1346 │ const conversationHistory: Record<string, ChatMessage[]> = {};
 1347 │ 
 1348 │ // Limpar histórico de conversa específica
 1349 │ export const clearConversationHistory = (sessionId: string) => {
      ·              ────────────┬───────────
      ·                          ╰── `clearConversationHistory` redefined here
 1350 │   if (conversationHistory[sessionId]) {
 1351 │     delete conversationHistory[sessionId];
 1352 │     // Também limpar do localStorage se existir
      ╰────

  × the name `generateAIResponse` is defined multiple times
      ╭─[/home/runner/workspace/src/services/aiChatService.ts:766:1]
  766 │ }
  767 │ 
  768 │ // Função principal para gerar resposta, tentando primeiro xAI e depois Gemini como fallback
  769 │ export async function generateAIResponse(
      ·                       ─────────┬────────
      ·                                ╰── previous definition of `generateAIResponse` here
  770 │   message: string, 
  771 │   sessionId: string, 
  772 │   options?: { 
  773 │     intelligenceLevel?: 'basic' | 'normal' | 'advanced',
  774 │     languageStyle?: 'casual' | 'formal' | 'technical'
  775 │   }
  776 │ ): Promise<string> {
  777 │   try {
  778 │     return await generateXAIResponse(message, sessionId, options);
  779 │   } catch (error) {
  780 │     console.error('Erro com xAI, tentando Gemini:', error);
  781 │     return generateGeminiResponse(message, sessionId, options);
  782 │   }
  783 │ }
  784 │ 
  785 │ // Limpar histórico da conversa
  786 │ export function clearConversationHistory(sessionId: string): void {
  787 │   if (conversationHistory[sessionId]) {
  788 │     // Mantém apenas a mensagem do sistema
  789 │     const systemMessage = conversationHistory[sessionId][0];
  790 │     conversationHistory[sessionId] = [systemMessage];
  791 │ 
  792 │     // Limpar do localStorage também
  793 │     try {
  794 │       localStorage.removeItem(`conversationHistory_${sessionId}`);
  795 │     } catch (error) {
  796 │       console.error("Erro ao limpar histórico do localStorage:", error);
  797 │     }
  798 │   }
  799 │ }
  800 │ 
  801 │ // Obter histórico da conversa
  802 │ export async function getConversationHistory(sessionId: string): Promise<ChatMessage[]> {
  803 │   try {
  804 │     // Primeiro verifica se já está carregado na memória e é válido
  805 │     if (conversationHistory[sessionId] && Array.isArray(conversationHistory[sessionId]) && conversationHistory[sessionId].length > 0) {
  806 │       // Verifica se há ao menos uma mensagem do sistema
  807 │       const hasSystemMessage = conversationHistory[sessionId].some(msg => msg.role === 'system');
  808 │ 
  809 │       if (hasSystemMessage) {
  810 │         return conversationHistory[sessionId];
  811 │       }
  812 │     }
  813 │ 
  814 │     // Tenta buscar dados adicionais do usuário para melhor armazenamento
  815 │     let userIdForStorage = '';
  816 │     try {
  817 │       const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
  818 │       userIdForStorage = sessionData?.session?.user?.id || '';
  819 │     } catch (e) {
  820 │       console.log('Erro ao obter ID do usuário:', e);
  821 │     }
  822 │ 
  823 │     // Tenta recuperar do localStorage usando vários formatos de chave
  824 │     const possibleKeys = [
  825 │       `conversationHistory_${sessionId}`,
  826 │       userIdForStorage ? `conversationHistory_${userIdForStorage}_${sessionId}` : null,
  827 │       `chat_history_${sessionId}`
  828 │     ].filter(Boolean);
  829 │ 
  830 │     let retrievedHistory = null;
  831 │ 
  832 │     // Tentar cada uma das possíveis chaves
  833 │     for (const key of possibleKeys) {
  834 │       try {
  835 │         const savedHistory = localStorage.getItem(key);
  836 │         if (savedHistory) {
  837 │           try {
  838 │             const parsedHistory = JSON.parse(savedHistory);
  839 │             if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
  840 │               retrievedHistory = parsedHistory;
  841 │               console.log(`Histórico recuperado com sucesso usando a chave: ${key}`);
  842 │               break;
  843 │             }
  844 │           } catch (parseError) {
  845 │             console.error(`Erro ao analisar histórico usando a chave ${key}:`, parseError);
  846 │           }
  847 │         }
  848 │       } catch (e) {
  849 │         console.error(`Erro ao tentar acessar o localStorage com a chave ${key}:`, e);
  850 │       }
  851 │     }
  852 │ 
  853 │     // Se encontrou histórico no localStorage
  854 │     if (retrievedHistory) {
  855 │       // Converter timestamps de string para Date e garantir formato adequado
  856 │       const processedHistory = retrievedHistory.map(msg => ({
  857 │         role: msg.role || 'user',
  858 │         content: msg.content || '',
  859 │         timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  860 │       }));
  861 │ 
  862 │       // Verificar se há mensagem do sistema
  863 │       const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  864 │ 
  865 │       if (!hasSystemMessage) {
  866 │         // Se não tiver mensagem do sistema, inicializar com uma nova
  867 │         const userContext = await getUserContext();
  868 │         initializeConversationHistory(sessionId, userContext);
  869 │ 
  870 │         // Adicionar as mensagens existentes (exceto mensagens do sistema já existentes)
  871 │         conversationHistory[sessionId] = [
  872 │           ...conversationHistory[sessionId],
  873 │           ...processedHistory.filter(msg => msg.role !== 'system')
  874 │         ];
  875 │       } else {
  876 │         conversationHistory[sessionId] = processedHistory;
  877 │       }
  878 │ 
  879 │       return conversationHistory[sessionId];
  880 │     }
  881 │ 
  882 │     // Se não encontrou no localStorage, tenta recuperar do Supabase
  883 │     try {
  884 │       const supabase = (await import('@/lib/supabase')).supabase;
  885 │       const { data: sessionData } = await supabase.auth.getSession();
  886 │       const userId = sessionData?.session?.user?.id;
  887 │ 
  888 │       if (userId) {
  889 │         try {
  890 │           // Verificar se a tabela existe antes de tentar consultar
  891 │           try {
  892 │             const { data: tableExists } = await supabase
  893 │               .from('information_schema.tables')
  894 │               .select('table_name')
  895 │               .eq('table_schema', 'public')
  896 │               .eq('table_name', 'ai_chat_history')
  897 │               .single();
  898 │ 
  899 │             if (!tableExists) {
  900 │               console.log('Tabela ai_chat_history não existe no Supabase.');
  901 │               throw new Error('Tabela não existe');
  902 │             }
  903 │           } catch (tableCheckError) {
  904 │             console.log('Erro ao verificar existência da tabela:', tableCheckError);
  905 │             throw tableCheckError;
  906 │           }
  907 │ 
  908 │           const { data, error } = await supabase
  909 │             .from('ai_chat_history')
  910 │             .select('messages')
  911 │             .eq('user_id', userId)
  912 │             .eq('session_id', sessionId)
  913 │             .single();
  914 │ 
  915 │           if (error) {
  916 │             console.error('Erro ao buscar histórico do Supabase:', error);
  917 │             throw error;
  918 │           }
  919 │ 
  920 │           if (data?.messages && Array.isArray(data.messages) && data.messages.length > 0) {
  921 │             // Converter timestamps de string para Date
  922 │             const processedHistory = data.messages.map(msg => ({
  923 │               role: msg.role || 'user',
  924 │               content: msg.content || '',
  925 │               timestamp: msg.timestamp ? (typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp) : new Date()
  926 │             }));
  927 │ 
  928 │             // Verificar se há mensagem do sistema
  929 │             const hasSystemMessage = processedHistory.some(msg => msg.role === 'system');
  930 │ 
  931 │             if (!hasSystemMessage) {
  932 │               // Se não tiver mensagem do sistema, inicializar com uma nova
  933 │               const userContext = await getUserContext();
  934 │               initializeConversationHistory(sessionId, userContext);
  935 │ 
  936 │               // Adicionar as mensagens existentes
  937 │               conversationHistory[sessionId] = [
  938 │                 ...conversationHistory[sessionId],
  939 │                 ...processedHistory.filter(msg => msg.role !== 'system')
  940 │               ];
  941 │             } else {
  942 │               conversationHistory[sessionId] = processedHistory;
  943 │             }
  944 │ 
  945 │             // Atualizar localStorage para sincronização
  946 │             try {
  947 │               localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(conversationHistory[sessionId]));
  948 │ 
  949 │               // Se temos o userId, também armazenar com chave mais específica
  950 │               if (userId) {
  951 │                 localStorage.setItem(`conversationHistory_${userId}_${sessionId}`, 
  952 │                   JSON.stringify(conversationHistory[sessionId]));
  953 │               }
  954 │             } catch (localStorageError) {
  955 │               console.log("Erro ao atualizar localStorage:", localStorageError);
  956 │             }
  957 │ 
  958 │             return conversationHistory[sessionId];
  959 │           }
  960 │         } catch (supabaseError) {
  961 │           console.error("Erro ao recuperar histórico do Supabase:", supabaseError);
  962 │         }
  963 │       }
  964 │     } catch (dbError) {
  965 │       console.error("Erro ao tentar acessar o banco de dados:", dbError);
  966 │     }
  967 │ 
  968 │     // Se chegou aqui, não foi possível recuperar o histórico
  969 │     // Inicializar com novo histórico
  970 │     console.log("Criando novo histórico de conversa para a sessão:", sessionId);
  971 │     const userContext = await getUserContext();
  972 │     initializeConversationHistory(sessionId, userContext);
  973 │ 
  974 │     // Salvar o histórico inicial
  975 │     try {
  976 │       localStorage.setItem(`conversationHistory_${sessionId}`, 
  977 │         JSON.stringify(conversationHistory[sessionId]));
  978 │ 
  979 │       // Se temos userIdForStorage, também armazenar com chave mais específica
  980 │       if (userIdForStorage) {
  981 │         localStorage.setItem(`conversationHistory_${userIdForStorage}_${sessionId}`, 
  982 │           JSON.stringify(conversationHistory[sessionId]));
  983 │       }
  984 │     } catch (e) {
  985 │       console.error("Erro ao salvar histórico inicial:", e);
  986 │     }
  987 │ 
  988 │     return conversationHistory[sessionId];
  989 │   } catch (generalError) {
  990 │     console.error("Erro geral ao obter histórico de conversa:", generalError);
  991 │ 
  992 │     // Retornar um histórico vazio em último caso
  993 │     return [{
  994 │       role: 'system',
  995 │       content: 'Você é o Epictus IA, o assistente inteligente da Ponto.School.',
  996 │       timestamp: new Date()
  997 │     }];
  998 │   }
  999 │ }
 1000 │ 
 1001 │ // Função para corrigir links da plataforma
 1002 │ function fixPlatformLinks(text: string): string {
 1003 │   const platformLinks = {
 1004 │     'Portal de Estudos': 'https://pontoschool.com/portal',
 1005 │     'Portal': 'https://pontoschool.com/portal',
 1006 │     'Agenda': 'https://pontoschool.com/agenda',
 1007 │     'Turmas': 'https://pontoschool.com/turmas',
 1008 │     'Biblioteca': 'https://pontoschool.com/biblioteca',
 1009 │     'Perfil': 'https://pontoschool.com/profile',
 1010 │     'Meu Perfil': 'https://pontoschool.com/profile',
 1011 │     'Configurações': 'https://pontoschool.com/configuracoes',
 1012 │     'Minhas Configurações': 'https://pontoschool.com/configuracoes',
 1013 │     'Dashboard': 'https://pontoschool.com/dashboard',
 1014 │     'Epictus IA': 'https://pontoschool.com/epictus-ia',
 1015 │     'Mentor IA': 'https://pontoschool.com/mentor-ia',
 1016 │     'Planos de Estudo': 'https://pontoschool.com/planos-estudo',
 1017 │     'Plano de Estudos': 'https://pontoschool.com/planos-estudo',
 1018 │     'Conquistas': 'https://pontoschool.com/conquistas',
 1019 │     'Minhas Conquistas': 'https://pontoschool.com/conquistas',
 1020 │     'Carteira': 'https://pontoschool.com/carteira',
 1021 │     'Minha Carteira': 'https://pontoschool.com/carteira',
 1022 │     'Mercado': 'https://pontoschool.com/mercado',
 1023 │     'Organização': 'https://pontoschool.com/organizacao',
 1024 │     'Comunidades': 'https://pontoschool.com/comunidades',
 1025 │     'Chat IA': 'https://pontoschool.com/chat-ia',
 1026 │     'School IA': 'https://pontoschool.com/school-ia',
 1027 │     'Novidades': 'https://pontoschool.com/novidades',
 1028 │     'Lembretes': 'https://pontoschool.com/lembretes',
 1029 │     'Pedidos de Ajuda': 'https://pontoschool.com/pedidos-ajuda',
 1030 │     'Estudos': 'https://pontoschool.com/estudos'
 1031 │   };
 1032 │ 
 1033 │   // Primeiro, procura por textos específicos que pedem redirecionamento
 1034 │   const redirectPatterns = [
 1035 │     /(?:me\s+(?:redirecione|encaminhe|leve|direcione|mande|envie)\s+(?:para|ao|à|a|até))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1036 │     /(?:quero\s+(?:ir|acessar|entrar|ver))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1037 │     /(?:me\s+(?:mostre|mostra))\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi,
 1038 │     /(?:abrir?|abra|acesse|acessar|ver|veja)\s+(?:a\s+)?(?:página\s+(?:de|do|da)\s+)?([a-zà-ú\s]+)/gi
 1039 │   ];
 1040 │ 
 1041 │   // Aplicar padrões de redirecionamento de forma mais robusta
 1042 │   for (const pattern of redirectPatterns) {
 1043 │     text = text.replace(pattern, (match, sectionName) => {
 1044 │       if (!sectionName) return match;
 1045 │ 
 1046 │       const normalizedName = sectionName.trim();
 1047 │       // Verificar se o nome normalizado corresponde a alguma chave do objeto platformLinks
 1048 │       for (const key in platformLinks) {
 1049 │         if (normalizedName.toLowerCase() === key.toLowerCase() || 
 1050 │             key.toLowerCase().includes(normalizedName.toLowerCase()) || 
 1051 │             normalizedName.toLowerCase().includes(key.toLowerCase())) {
 1052 │           // Criar link em formato seguro sem possíveis bugs de formatação
 1053 │           return `Você pode acessar [${key}](${platformLinks[key]})`;
 1054 │         }
 1055 │       }
 1056 │       return match; // Se não encontrou correspondência, mantém o texto original
 1057 │     });
 1058 │   }
 1059 │ 
 1060 │   // Verificar se o texto já contém links markdown
 1061 │   const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
 1062 │   const existingLinks = [];
 1063 │   let match;
 1064 │ 
 1065 │   while ((match = markdownLinkRegex.exec(text)) !== null) {
 1066 │     existingLinks.push({
 1067 │       text: match[1],
 1068 │       url: match[2],
 1069 │       fullMatch: match[0]
 1070 │     });
 1071 │   }
 1072 │ 
 1073 │   // Depois, procurar menções a seções e converter para links (só se não forem já parte de um link)
 1074 │   let newText = text;
 1075 │ 
 1076 │   // Aplicar substituições de forma ordenada (das mais longas para as mais curtas)
 1077 │   const orderedKeys = Object.keys(platformLinks).sort((a, b) => b.length - a.length);
 1078 │ 
 1079 │   for (const key of orderedKeys) {
 1080 │     // Criar regex segura que não captura dentro de links existentes
 1081 │     const safeRegex = new RegExp(`(?<![\\[\\w])\\b(${escapeRegExp(key)})\\b(?![\\]\\w])`, 'g');
 1082 │ 
 1083 │     // Verificar cada ocorrência para garantir que não está dentro de um link existente
 1084 │     let lastIndex = 0;
 1085 │     let result = '';
 1086 │     let regexMatch;
 1087 │ 
 1088 │     while ((regexMatch = safeRegex.exec(newText)) !== null) {
 1089 │       const matchStart = regexMatch.index;
 1090 │       const matchEnd = matchStart + regexMatch[0].length;
 1091 │ 
 1092 │       // Verificar se esta ocorrência está dentro de algum link existente
 1093 │       let isInsideExistingLink = false;
 1094 │       for (const link of existingLinks) {
 1095 │         const linkIndex = newText.indexOf(link.fullMatch);
 1096 │         if (linkIndex <= matchStart && linkIndex + link.fullMatch.length >= matchEnd) {
 1097 │           isInsideExistingLink = true;
 1098 │           break;
 1099 │         }
 1100 │       }
 1101 │ 
 1102 │       if (!isInsideExistingLink) {
 1103 │         result += newText.substring(lastIndex, matchStart);
 1104 │         result += `[${regexMatch[1]}](${platformLinks[key]})`;
 1105 │         lastIndex = matchEnd;
 1106 │       }
 1107 │     }
 1108 │ 
 1109 │     if (lastIndex > 0) {
 1110 │       result += newText.substring(lastIndex);
 1111 │       newText = result;
 1112 │ 
 1113 │       // Atualizar a lista de links existentes
 1114 │       existingLinks.length = 0;
 1115 │       while ((match = markdownLinkRegex.exec(newText)) !== null) {
 1116 │         existingLinks.push({
 1117 │           text: match[1],
 1118 │           url: match[2],
 1119 │           fullMatch: match[0]
 1120 │         });
 1121 │       }
 1122 │     }
 1123 │   }
 1124 │ 
 1125 │   // Remover qualquer formatação incorreta que possa ter sido introduzida
 1126 │   newText = newText
 1127 │     .replace(/\]\(\[/g, ']([') // Corrigir links aninhados
 1128 │     .replace(/\]\(https:\/\/pontoschool\.com\/[a-z-]+\)\(https:\/\/pontoschool\.com\/[a-z-]+\)/g, match => {
 1129 │       // Extrair o primeiro link válido
 1130 │       const urlMatch = match.match(/\]\((https:\/\/pontoschool\.com\/[a-z-]+)\)/);
 1131 │       if (urlMatch && urlMatch[1]) {
 1132 │         return `](${urlMatch[1]})`;
 1133 │       }
 1134 │       return match;
 1135 │     });
 1136 │ 
 1137 │   return newText;
 1138 │ }
 1139 │ 
 1140 │ // Função auxiliar para escapar caracteres especiais em regex
 1141 │ function escapeRegExp(string) {
 1142 │   return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 1143 │ }
 1144 │ 
 1145 │ 
 1146 │ // Função para salvar o histórico da conversa no localStorage e sincronizar com Supabase
 1147 │ async function saveConversationHistory(sessionId: string, history: ChatMessage[]): Promise<void> {
 1148 │   try {
 1149 │     if (!sessionId || !history) {
 1150 │       console.error("Erro ao salvar histórico: sessionId ou history inválidos");
 1151 │       return;
 1152 │     }
 1153 │ 
 1154 │     // Salvar localmente
 1155 │     conversationHistory[sessionId] = history;
 1156 │ 
 1157 │     // Preparar o histórico para armazenamento (garantir que todos os objetos são serializáveis)
 1158 │     const serializableHistory = history.map(msg => ({
 1159 │       role: msg.role,
 1160 │       content: msg.content,
 1161 │       timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1162 │                 (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1163 │     }));
 1164 │ 
 1165 │     try {
 1166 │       // Salvar para o usuário atual com uma estrutura mais persistente
 1167 │       // Usar formato conversationHistory_USER_ID_sessionId quando possível
 1168 │       let storageKey = `conversationHistory_${sessionId}`;
 1169 │ 
 1170 │       // Tentar obter dados de identificação do usuário para melhor rastreamento
 1171 │       try {
 1172 │         const { data: sessionData } = await (await import('@/lib/supabase')).supabase.auth.getSession();
 1173 │         const userId = sessionData?.session?.user?.id;
 1174 │         if (userId) {
 1175 │           storageKey = `conversationHistory_${userId}_${sessionId}`;
 1176 │         }
 1177 │       } catch (e) {
 1178 │         console.log('Erro ao obter ID do usuário, usando chave padrão:', e);
 1179 │       }
 1180 │ 
 1181 │       // Salvar com uma chave mais específica para melhor identificação
 1182 │       localStorage.setItem(storageKey, JSON.stringify(serializableHistory));
 1183 │ 
 1184 │       // Para compatibilidade, também salvar com a chave antiga
 1185 │       localStorage.setItem(`conversationHistory_${sessionId}`, JSON.stringify(serializableHistory));
 1186 │ 
 1187 │       // Manter um índice de todas as conversas do usuário
 1188 │       try {
 1189 │         const userConversationsKey = 'userConversationsIndex';
 1190 │         let conversationsIndex = {};
 1191 │ 
 1192 │         const savedIndex = localStorage.getItem(userConversationsKey);
 1193 │         if (savedIndex) {
 1194 │           conversationsIndex = JSON.parse(savedIndex);
 1195 │         }
 1196 │ 
 1197 │         conversationsIndex[sessionId] = {
 1198 │           lastUpdated: new Date().toISOString(),
 1199 │           messageCount: serializableHistory.length,
 1200 │           title: serializableHistory.length > 1 ? 
 1201 │             serializableHistory[1].content.substring(0, 30) + "..." : 
 1202 │             "Nova conversa"
 1203 │         };
 1204 │ 
 1205 │         // Limitar o índice a 50 conversas mais recentes
 1206 │         const sortedEntries = Object.entries(conversationsIndex)
 1207 │           .sort((a, b) => new Date(b[1].lastUpdated).getTime() - new Date(a[1].lastUpdated).getTime())
 1208 │           .slice(0, 50);
 1209 │ 
 1210 │         const trimmedIndex = {};
 1211 │         sortedEntries.forEach(([key, value]) => {
 1212 │           trimmedIndex[key] = value;
 1213 │         });
 1214 │ 
 1215 │         localStorage.setItem(userConversationsKey, JSON.stringify(trimmedIndex));
 1216 │       } catch (indexError) {
 1217 │         console.error("Erro ao atualizar índice de conversas:", indexError);
 1218 │       }
 1219 │ 
 1220 │       // Salvar todas as sessões em um único item no localStorage com limite de tamanho
 1221 │       try {
 1222 │         const allSessions = {};
 1223 │         // Só armazenar as últimas 20 sessões
 1224 │         const sessionIds = Object.keys(conversationHistory).slice(-20);
 1225 │ 
 1226 │         for (const id of sessionIds) {
 1227 │           const sessionHistory = conversationHistory[id];
 1228 │           if (sessionHistory && sessionHistory.length > 0) {
 1229 │             // Limitar cada sessão a 100 mensagens para melhor contexto
 1230 │             allSessions[id] = sessionHistory.slice(-100).map(msg => ({
 1231 │               role: msg.role,
 1232 │               content: msg.content,
 1233 │               timestamp: msg.timestamp instanceof Date ? msg.timestamp.toISOString() : 
 1234 │                         (typeof msg.timestamp === 'string' ? msg.timestamp : new Date().toISOString())
 1235 │             }));
 1236 │           }
 1237 │         }
 1238 │ 
 1239 │         localStorage.setItem('aiChatSessions', JSON.stringify(allSessions));
 1240 │       } catch (batchSaveError) {
 1241 │         console.error("Erro ao salvar todas as sessões:", batchSaveError);
 1242 │       }
 1243 │     } catch (localStorageError) {
 1244 │       console.error("Erro ao salvar no localStorage:", localStorageError);
 1245 │       // Se falhar por exceder o limite, limpar o localStorage e tentar novamente só com a sessão atual
 1246 │       try {
 1247 │         localStorage.removeItem('aiChatSessions');
 1248 │         localStorage.setItem(`conversationHistory_${sessionId}`, 
 1249 │           JSON.stringify(serializableHistory.slice(-50))); // Salvar só as últimas 50 mensagens
 1250 │       } catch (retryError) {
 1251 │         console.error("Falha na segunda tentativa de salvar no localStorage:", retryError);
 1252 │       }
 1253 │     }
 1254 │ 
 1255 │     // Sincronizar com Supabase se disponível
 1256 │     try {
 1257 │       const supabase = (await import('@/lib/supabase')).supabase;
 1258 │       const { data: sessionData } = await supabase.auth.getSession();
 1259 │       const userId = sessionData?.session?.user?.id;
 1260 │ 
 1261 │       if (userId) {
 1262 │         try {
 1263 │           // Criar tabela ai_chat_history se não existir (verificar primeiro)
 1264 │           const { data: tablesData } = await supabase
 1265 │             .from('information_schema.tables')
 1266 │             .select('table_name')
 1267 │             .eq('table_schema', 'public')
 1268 │             .eq('table_name', 'ai_chat_history');
 1269 │ 
 1270 │           if (!tablesData || tablesData.length === 0) {
 1271 │             // Tabela não existe, tentar criar usando rpc
 1272 │             try {
 1273 │               await supabase.rpc('execute_sql', {
 1274 │                 sql_statement: `
 1275 │                   CREATE TABLE IF NOT EXISTS public.ai_chat_history (
 1276 │                     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
 1277 │                     user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
 1278 │                     session_id TEXT NOT NULL,
 1279 │                     messages JSONB NOT NULL DEFAULT '[]'::jsonb,
 1280 │                     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1281 │                     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 1282 │                     UNIQUE (user_id, session_id)
 1283 │                   );
 1284 │ 
 1285 │                   CREATE INDEX IF NOT EXISTS ai_chat_history_user_id_idx ON public.ai_chat_history(user_id);
 1286 │                   CREATE INDEX IF NOT EXISTS ai_chat_history_session_id_idx ON public.ai_chat_history(session_id);
 1287 │                 `
 1288 │               });
 1289 │             } catch (createTableError) {
 1290 │               console.log('Erro ao criar tabela ai_chat_history:', createTableError);
 1291 │             }
 1292 │           }
 1293 │ 
 1294 │           // Upsert do histórico da conversa
 1295 │           const { error } = await supabase
 1296 │             .from('ai_chat_history')
 1297 │             .upsert({
 1298 │               user_id: userId,
 1299 │               session_id: sessionId,
 1300 │               messages: serializableHistory.slice(-100), // Armazenar até 100 mensagens
 1301 │               updated_at: new Date().toISOString()
 1302 │             }, {
 1303 │               onConflict: 'user_id,session_id'
 1304 │             });
 1305 │ 
 1306 │           if (error) {
 1307 │             console.error("Erro ao sincronizar histórico com Supabase:", error);
 1308 │           }
 1309 │         } catch (upsertError) {
 1310 │           console.error("Erro no upsert do histórico:", upsertError);
 1311 │         }
 1312 │       }
 1313 │     } catch (syncError) {
 1314 │       console.log("Supabase não disponível para sincronização:", syncError);
 1315 │     }
 1316 │   } catch (error) {
 1317 │     console.error("Erro ao salvar o histórico da conversa:", error);
 1318 │   }
 1319 │ }
 1320 │ 
 1321 │ // Simulação de resposta da IA
 1322 │ const getResponseForMessage = (message: string): string => {
 1323 │   // Análise básica da mensagem para gerar uma resposta contextual
 1324 │   const formattedMessage = message.toLowerCase();
 1325 │ 
 1326 │   if (formattedMessage.includes('olá') || formattedMessage.includes('oi') || formattedMessage.includes('bom dia') || formattedMessage.includes('boa tarde') || formattedMessage.includes('boa noite')) {
 1327 │     return `**Olá, ${userInfo?.username || 'amigo'}!** 😊\n\nComo posso ajudar você hoje?`;
 1328 │   } else if (formattedMessage.includes('função') || formattedMessage.includes('o que você faz') || formattedMessage.includes('para que serve')) {
 1329 │     return `**Eu sou Epictus IA**, seu assistente para a plataforma Ponto.School! 🚀\n\nPosso ajudar com:\n\n• **Informações** sobre cursos e conteúdos\n• **Dicas de estudos** personalizadas\n• **Navegação** na plataforma\n• **Respostas** para dúvidas gerais\n\nComo posso ajudar você agora?`;
 1330 │   } else if (formattedMessage.includes('portal') || formattedMessage.includes('material') || formattedMessage.includes('acessar conteúdo')) {
 1331 │     return `Você pode acessar o **Portal** com todos os materiais em https://pontoschool.com/portal\n\nLá você encontrará todos os seus cursos, materiais e recursos de estudo organizados por disciplina.\n\n_Basta clicar no link acima para ir direto para o Portal!_ 📚`;
 1332 │   } else {
 1333 │     return "Desculpe, não entendi sua pergunta. Pode reformulá-la?";
 1334 │   }
 1335 │ };
 1336 │ 
 1337 │ import { supabase } from "@/lib/supabase";
 1338 │ import * as aiChatDB from "./aiChatDatabaseService";
 1339 │ 
 1340 │ interface ChatMessage {
 1341 │   role: 'system' | 'user' | 'assistant';
 1342 │   content: string;
 1343 │ }
 1344 │ 
 1345 │ // Armazenamento temporário de histórico de chat no navegador
 1346 │ const conversationHistory: Record<string, ChatMessage[]> = {};
 1347 │ 
 1348 │ // Limpar histórico de conversa específica
 1349 │ export const clearConversationHistory = (sessionId: string) => {
 1350 │   if (conversationHistory[sessionId]) {
 1351 │     delete conversationHistory[sessionId];
 1352 │     // Também limpar do localStorage se existir
 1353 │     try {
 1354 │       localStorage.removeItem(`conversationHistory_${sessionId}`);
 1355 │     } catch (error) {
 1356 │       console.error('Erro ao limpar histórico do localStorage:', error);
 1357 │     }
 1358 │   }
 1359 │ };
 1360 │ 
 1361 │ // Função para gerar um prompt de sistema informativo para a IA
 1362 │ const generateSystemPrompt = async (
 1363 │   userName: string, 
 1364 │   userId: string | null, 
 1365 │   options: {
 1366 │     intelligenceLevel: 'basic' | 'normal' | 'advanced',
 1367 │     languageStyle: 'casual' | 'formal' | 'technical',
 1368 │     includeLinks: boolean
 1369 │   }
 1370 │ ) => {
 1371 │   let systemPrompt = `Você é o Epictus IA de Suporte, um assistente virtual amigável dentro da plataforma educacional Ponto.School. 
 1372 │   Seu papel é fornecer suporte para navegação, responder dúvidas sobre funcionalidades e dar dicas para o melhor aproveitamento da plataforma.
 1373 │   Você deve ser gentil, educado e paciente. Você tem acesso às informações da conta do usuário quando solicitado.
 1374 │ 
 1375 │   Diretrizes:
 1376 │   1. Seja conciso, direto e útil - respostas entre 2-3 parágrafos são ideais
 1377 │   2. Seja amigável e use um tom conversacional
 1378 │   3. Use formatação para organizar suas respostas: negrito para títulos, listas numeradas ou com marcadores para passos
 1379 │   4. Quando mencionar um recurso da plataforma, explique brevemente como acessá-lo
 1380 │   5. Se o usuário parecer confuso, ofereça opções para ajudá-lo
 1381 │   6. Se a pergunta for sobre um tópico educacional específico, direcione-o para usar o Epictus IA na seção específica para isso
 1382 │   7. Se a pergunta for sobre um problema técnico sem solução simples, sugira abrir um ticket de suporte ou entrar em contato por e-mail: suporte@pontoschool.com
 1383 │ 
 1384 │   IMPORTANTE: Você está conversando com ${userName} (utilize apenas o primeiro nome ao se referir ao usuário) e deve se referir a ele pelo primeiro nome em suas respostas.`;
 1385 │ 
 1386 │   // Adicionar informações da plataforma para referência
 1387 │   systemPrompt += `\n\nInformações da plataforma para referência:`;
 1388 │ 
 1389 │   // Adicionar seções da plataforma
 1390 │   const platformSections = aiChatDB.getPlatformNavigationInfo();
 1391 │   systemPrompt += `\n\nSeções principais:`;
 1392 │   platformSections.forEach(section => {
 1393 │     systemPrompt += `\n- ${section.section}: ${section.description}`;
 1394 │   });
 1395 │ 
 1396 │   // Adicionar categorias de FAQs para informar a IA sobre o conhecimento disponível
 1397 │   const faqs = aiChatDB.getFAQDatabase();
 1398 │   const categories = [...new Set(faqs.map(faq => faq.category))];
 1399 │ 
 1400 │   systemPrompt += `\n\nCategorias de perguntas frequentes:`;
 1401 │   categories.forEach(category => {
 1402 │     systemPrompt += `\n- ${category}`;
 1403 │   });
 1404 │ 
 1405 │   // Adicionar informações do usuário se disponíveis
 1406 │   if (userId) {
 1407 │     try {
 1408 │       const userInfo = await aiChatDB.formatUserInfoForAI(userId);
 1409 │       if (typeof userInfo === 'object') {
 1410 │         systemPrompt += `\n\nInformações do usuário:
 1411 │ - Nome: ${userInfo.full_name}
 1412 │ - Nome de exibição: ${userInfo.display_name}
 1413 │ - Email: ${userInfo.email}
 1414 │ - ID: ${userInfo.id}
 1415 │ - Nível: ${userInfo.level}
 1416 │ - Plano: ${userInfo.plan_type}
 1417 │ - Instituição: ${userInfo.institution}
 1418 │ - Criado em: ${userInfo.created_at}
 1419 │ - Bio: ${userInfo.bio}
 1420 │ - Número de turmas: ${userInfo.classes ? userInfo.classes.length : 0}`;
 1421 │       }
 1422 │     } catch (error) {
 1423 │       console.error("Erro ao obter informações do usuário:", error);
 1424 │     }
 1425 │   }
 1426 │ 
 1427 │   // Ajustar nível de inteligência
 1428 │   if (options.intelligenceLevel === 'basic') {
 1429 │     systemPrompt += '\nResponda de forma simples e direta, com explicações básicas.';
 1430 │   } else if (options.intelligenceLevel === 'advanced') {
 1431 │     systemPrompt += '\nResponda de forma detalhada e abrangente, com explicações avançadas quando aplicável.';
 1432 │   }
 1433 │ 
 1434 │   // Ajustar estilo de linguagem
 1435 │   if (options.languageStyle === 'formal') {
 1436 │     systemPrompt += '\nUtilize linguagem formal e profissional, evitando gírias e expressões coloquiais.';
 1437 │   } else if (options.languageStyle === 'technical') {
 1438 │     systemPrompt += '\nUtilize linguagem técnica e específica quando apropriado, mas garantindo que as explicações sejam claras.';
 1439 │   }
 1440 │ 
 1441 │   // Ajustar uso de links
 1442 │   if (!options.includeLinks) {
 1443 │     systemPrompt += '\nEvite incluir links nas suas respostas. Forneça instruções detalhadas em vez de links.';
 1444 │   }
 1445 │ 
 1446 │   return systemPrompt;
 1447 │ };
 1448 │ 
 1449 │ // Função para enriquecer a mensagem do usuário com contexto relevante
 1450 │ const enrichUserMessage = async (message: string, userId: string | null) => {
 1451 │   let enrichedMessage = message;
 1452 │   let contextAdded = false;
 1453 │ 
 1454 │   // Verificar se a mensagem parece solicitar informações pessoais
 1455 │   const askingForPersonalInfo = /meu (perfil|conta|usuário|saldo|turmas|nivel)/i.test(message) || 
 1456 │     /minha (s)? (informaç[õo]es|dados|conta)/i.test(message) ||
 1457 │     /me (mostre|diga|informe) (sobre )?m(eu|inha)/i.test(message);
 1458 │ 
 1459 │   if (askingForPersonalInfo && userId) {
 1460 │     try {
 1461 │       const userInfo = await aiChatDB.formatUserInfoForAI(userId);
 1462 │       if (typeof userInfo === 'object') {
 1463 │         enrichedMessage += `\n\nContexto adicional (não visível para o usuário): 
 1464 │ Informações atualizadas da conta do usuário:
 1465 │ - Nome completo: ${userInfo.full_name}
 1466 │ - Nome de usuário: ${userInfo.display_name}
 1467 │ - Email: ${userInfo.email}
 1468 │ - ID: ${userInfo.id}
 1469 │ - Nível: ${userInfo.level}
 1470 │ - Plano: ${userInfo.plan_type}
 1471 │ - Criado em: ${userInfo.created_at}
 1472 │ - Instituição: ${userInfo.institution}
 1473 │ - Bio: ${userInfo.bio}`;
 1474 │ 
 1475 │         if (userInfo.classes && userInfo.classes.length > 0) {
 1476 │           enrichedMessage += `\n- Turmas: ${userInfo.classes.map((c: any) => c.name).join(', ')}`;
 1477 │         } else {
 1478 │           enrichedMessage += `\n- Turmas: Nenhuma turma encontrada`;
 1479 │         }
 1480 │ 
 1481 │         contextAdded = true;
 1482 │       }
 1483 │     } catch (error) {
 1484 │       console.error("Erro ao enriquecer mensagem do usuário:", error);
 1485 │     }
 1486 │   }
 1487 │ 
 1488 │   // Verificar se a mensagem está pedindo ajuda sobre navegação/localização
 1489 │   const askingForNavigation = /(onde|como) (encontr[oa]|ach[oa]|acess[oa])/i.test(message) || 
 1490 │     /onde (fica|está)/i.test(message);
 1491 │ 
 1492 │   if (askingForNavigation) {
 1493 │     // Buscar informações relevantes no banco de dados de navegação
 1494 │     const navigationResults = aiChatDB.searchPlatformInfo(message);
 1495 │     if (navigationResults.length > 0) {
 1496 │       enrichedMessage += `\n\nContexto adicional (não visível para o usuário): 
 1497 │ Informações de navegação relevantes:`;
 1498 │       navigationResults.slice(0, 3).forEach(item => {
 1499 │         enrichedMessage += `\n- ${item.section}: ${item.description} (Caminho: ${item.path})`;
 1500 │       });
 1501 │       contextAdded = true;
 1502 │     }
 1503 │   }
 1504 │ 
 1505 │   // Verificar se é uma pergunta sobre funcionalidades ou ajuda
 1506 │   const askingForHelp = /como (faço|funciona|crio|acesso|uso|utilizo)/i.test(message) || 
 1507 │     /(o que é|para que serve)/i.test(message) ||
 1508 │     /(ajuda|dúvida|problema|dificuldade)/i.test(message);
 1509 │ 
 1510 │   if (askingForHelp) {
 1511 │     // Buscar FAQs relevantes
 1512 │     const faqResults = aiChatDB.searchFAQs(message);
 1513 │     if (faqResults.length > 0) {
 1514 │       enrichedMessage += `\n\nContexto adicional (não visível para o usuário): 
 1515 │ FAQs relevantes:`;
 1516 │       faqResults.slice(0, 3).forEach(item => {
 1517 │         enrichedMessage += `\n- P: ${item.question}\n  R: ${item.answer}`;
 1518 │       });
 1519 │       contextAdded = true;
 1520 │     }
 1521 │   }
 1522 │ 
 1523 │   // Se nenhum contexto foi adicionado, mas parece uma pergunta específica
 1524 │   if (!contextAdded && 
 1525 │     (message.includes("?") || 
 1526 │      /^(o que|como|onde|quando|quem|qual|quais|por que|pra que)/i.test(message))) {
 1527 │ 
 1528 │     // Buscar todas as informações potencialmente relevantes
 1529 │     const keywords = message.split(/\s+/).filter(word => word.length > 3);
 1530 │     const relevantFaqs: any[] = [];
 1531 │ 
 1532 │     for (const keyword of keywords) {
 1533 │       const results = aiChatDB.searchFAQs(keyword);
 1534 │       results.forEach(result => {
 1535 │         if (!relevantFaqs.some(faq => faq.id === result.id)) {
 1536 │           relevantFaqs.push(result);
 1537 │         }
 1538 │       });
 1539 │       if (relevantFaqs.length >= 2) break;
 1540 │     }
 1541 │ 
 1542 │     if (relevantFaqs.length > 0) {
 1543 │       enrichedMessage += `\n\nContexto adicional (não visível para o usuário): 
 1544 │ FAQs potencialmente relevantes:`;
 1545 │       relevantFaqs.slice(0, 2).forEach(item => {
 1546 │         enrichedMessage += `\n- P: ${item.question}\n  R: ${item.answer}`;
 1547 │       });
 1548 │     }
 1549 │   }
 1550 │ 
 1551 │   return enrichedMessage;
 1552 │ };
 1553 │ 
 1554 │ // Função principal para gerar resposta da IA
 1555 │ export const generateAIResponse = async (
      ·              ─────────┬────────
      ·                       ╰── `generateAIResponse` redefined here
 1556 │   message: string,
 1557 │   sessionId: string,
 1558 │   userName: string = "Usuário",
      ╰────
/home/runner/workspace/src/services/aiChatService.ts:16:1
160|        // Dados de contexto de uso
161|        currentPage: window.location.pathname,
162|        lastActivity: localStorage.getItem('lastActivity') || 'Nenhuma atividade recente',
   |                                                                            ^
163|  
164|        // Dados das turmas e séries