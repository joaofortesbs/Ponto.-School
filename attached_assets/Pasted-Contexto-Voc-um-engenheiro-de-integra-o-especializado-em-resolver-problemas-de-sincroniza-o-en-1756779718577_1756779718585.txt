Contexto:
Você é um engenheiro de integração especializado em resolver problemas de sincronização entre APIs de IA (Gemini) e interfaces de usuário em plataformas low-code (Replit/Vibe Code). O sistema já possui um template/estrutura de Flash Cards funcional, mas os dados gerados pela IA não estão sendo inseridos corretamente na interface. O problema pode estar em:

Geração dos dados pela IA (formato, estrutura ou conteúdo incorreto).
Transferência dos dados (falha na comunicação entre a API e o frontend).
Recepção e parsing dos dados (erro ao interpretar o JSON ou atualizar o estado).
Conflito com pré-visualização (dados fictícios bloqueando a renderização dos dados reais).
Integração com o template (campos não mapeados ou atualização assíncrona mal gerenciada).

Sua missão:


Analisar a estrutura atual da interface de Flash Cards no Replit:

Mapear todos os campos do template (ex.: pergunta, alternativas, resposta_certa, feedback, etapa_atual, total_etapas).
Identificar como os dados são recebidos, armazenados e renderizados (ex.: uso de state, props, signals, ou observables).
Verificar se há conflitos com dados fictícios da pré-visualização (ex.: variáveis estáticas ou cache não atualizado).



Validar a saída da API do Gemini:

Garantir que o JSON gerado pela IA corresponda exatamente à estrutura esperada pelo template.
Exemplo de formato esperado:
 Copiar{
  "flashcards": [
    {
      "pergunta": "string",
      "alternativas": ["string", "string", "string"],
      "resposta_certa": "índice",
      "feedback": "string",
      "etapa": "number"
    }
  ],
  "metadata": {
    "total_etapas": "number",
    "versao": "real" // Para diferenciar de dados fictícios
  }
}




Diagnosticar o fluxo de dados:

A IA está gerando os dados corretamente? (Verificar logs da API).
Os dados estão sendo enviados do backend para o frontend? (Checar requisições HTTP/WebSocket).
O frontend está recebendo e processando os dados? (Checar console.log, network tab, ou state).
Há algum bloqueio ou override por causa da pré-visualização? (Ex.: condicionais como if (modo_previa) { ... }).



Corrigir a sincronização:

Criar um mecanismo seguro para substituir os dados fictícios pelos reais sem quebrar a interface.
Usar flags de controle (ex.: modo_edicao: true/false) para alternar entre pré-visualização e dados reais.
Garantir que o template atualize automaticamente quando novos dados chegarem (ex.: useEffect no React, effect no SolidJS, ou watch no Vue).



Implementar uma solução não invasiva:

Não alterar a lógica existente da API ou do template.
Adicionar apenas o necessário para garantir a sincronização:

Validação de schema dos dados recebidos.
Atualização reativa do estado (ex.: setState, signal.value = novo_dado).
Limpeza de cache ou dados antigos antes de inserir os novos.





Fornecer um código de integração:

Exemplo em pseudocódigo/JS para inserir os dados da IA no template sem conflitos:
 Copiar// 1. Receber dados da API
const dadosIA = await fetchGeminiAPI();

// 2. Validar estrutura
if (!dadosIA.flashcards || dadosIA.metadata.versao !== "real") {
  throw new Error("Dados inválidos ou fictícios!");
}

// 3. Atualizar o estado da interface
setFlashCards(dadosIA.flashcards);
setTotalEtapas(dadosIA.metadata.total_etapas);

// 4. Forçar renderização (se necessário)
forceUpdate(); // ou trigger de observable/signal




Testar a solução:

Simular o fluxo completo: geração da IA → transferência → renderização.
Verificar se os dados aparecem sem corromper a estrutura existente.




Regras Críticas (NÃO VIOLAR!)

Não modificar a estrutura do template ou a lógica da API do Gemini.
Não apagar funcionalidades existentes (ex.: pré-visualização).
Não introduzir dependências externas ou refatorações desnecessárias.
Priorizar a correção do fluxo de dados sem efeitos colaterais.


Exemplo de Saída Esperada da IA
 Copiar{
  "flashcards": [
    {
      "pergunta": "Qual é a capital do Brasil?",
      "alternativas": ["Rio de Janeiro", "Brasília", "São Paulo"],
      "resposta_certa": 1,
      "feedback": "Brasília é a capital desde 1960.",
      "etapa": 1
    }
  ],
  "metadata": {
    "total_etapas": 5,
    "versao": "real",
    "timestamp": "2025-09-01T12:00:00Z"
  }
}

Checklist para Debug Manual


Logs da API:

A requisição à Gemini retorna sucesso (status 200)?
O payload está no formato correto?



Frontend:

Os dados chegam no console.log?
O estado é atualizado? (Checar DevTools → Components/State).
Há erros no console? (Ex.: Cannot read property 'map' of undefined).



Pré-visualização:

Existe uma variável como isPreviewMode bloqueando a atualização?
Os dados fictícios estão em um state separado?



Template:

Os campos mapeados batem com os dados da IA? (Ex.: flashcard.alternativas vs dadosIA.alternativas).




Solução Proposta (Passo a Passo)


Backend (Replit):

Adicionar um endpoint de debug para validar a saída da IA:
 Copiarapp.get('/debug-flashcards', async (req, res) => {
  const dadosIA = await chamarGeminiAPI();
  res.json({ dadosIA, estrutura_template: "OK" });
});




Frontend:

Adicionar um botão de "Atualizar Dados" para testar a sincronização manualmente:
 Copiarconst handleAtualizar = async () => {
  const resposta = await fetch('/debug-flashcards');
  const { dadosIA } = await resposta.json();
  setFlashCards(dadosIA.flashcards); // Atualiza o estado
};




Override Seguro:

Usar um seletor de versão para alternar entre pré-visualização e dados reais:
 Copiarconst [usarDadosReais, setUsarDadosReais] = useState(false);

// No template:
const dadosExibidos = usarDadosReais ? dadosReais : dadosFicticios;