ANÃLISE FORENSE E CORREÃ‡ÃƒO DEFINITIVA: Capability de GeraÃ§Ã£o de ConteÃºdo
DIAGNÃ“STICO CONFIRMADO (Baseado em EvidÃªncias do Git)
Pelos commits recentes, vejo que foram feitas tentativas de:

"Improve content generation by correctly passing activity data" (4 min atrÃ¡s)

"Add logging and retry mechanisms" (20 min atrÃ¡s)

"Improve activity content generation and debugging" (35 min atrÃ¡s)

PorÃ©m a capability AINDA estÃ¡ completando em 22ms processando 0 de 5 atividades. Isso indica que o problema NÃƒO Ã© logging ou retry - Ã© data injection failure.

PROBLEMA RAIZ IDENTIFICADO
O arquivo src/lib/capabilities/executor.ts ou equivalente tem um mÃ©todo enrichCapabilityParams() que estÃ¡ falhando em injetar os parÃ¢metros necessÃ¡rios para gerar_conteudo_atividades.

EvidÃªncia Concreta
A Ãºltima correÃ§Ã£o tentou passar activities_to_fill de getChosenActivities(), mas a capability AINDA nÃ£o estÃ¡ recebendo os dados. Isso significa que:

O mÃ©todo getChosenActivities() estÃ¡ retornando array vazio quando chamado no momento da execuÃ§Ã£o

O timing estÃ¡ errado - a capability estÃ¡ sendo executada ANTES do store ser populado

O fallback implementado nÃ£o estÃ¡ funcionando porque tambÃ©m nÃ£o encontra os dados

INSTRUÃ‡Ã•ES CIRÃšRGICAS DE CORREÃ‡ÃƒO
TAREFA 1: Garantir Sequenciamento Correto
Arquivo a modificar: src/lib/capabilities/CapabilityExecutor.ts (ou nome equivalente)

Problema: A capability gerar_conteudo_atividades estÃ¡ sendo agendada ou marcada como pronta ANTES de decidir_atividades_criar ter salvado os dados no store.

SoluÃ§Ã£o obrigatÃ³ria:

typescript
// NO MÃ‰TODO QUE EXECUTA "decidir_atividades_criar"
// Certifique-se de que ANTES de marcar como completa:

// 1. Salva as atividades no store
const chosenActivities = result.chosen_activities; // ou campo correto
await activityStore.setChosenActivities(chosenActivities); // Aguarde persistir!

// 2. AGUARDE confirmaÃ§Ã£o de que dados estÃ£o salvos
const verification = activityStore.getChosenActivities();
if (!verification || verification.length === 0) {
  throw new Error("CRITICAL: Failed to persist chosen activities to store");
}

// 3. SÃ“ AGORA marque "decidir_atividades_criar" como concluÃ­da
// 4. E entÃ£o TRIGGER "gerar_conteudo_atividades"
TAREFA 2: InjeÃ§Ã£o ExplÃ­cita de Dados
Arquivo: enrichCapabilityParams() dentro do executor

Problema: EstÃ¡ usando getChosenActivities() que retorna vazio no momento da chamada.

SoluÃ§Ã£o - FORCE data pass:

typescript
if (capabilityName === 'gerar_conteudo_atividades') {
  // OPÃ‡ÃƒO A: Buscar do resultado da capability anterior DIRETAMENTE
  const previousResult = this.getLastCompletedCapabilityResult('decidir_atividades_criar');
  
  if (previousResult?.chosen_activities) {
    enrichedParams.activities_to_fill = previousResult.chosen_activities;
  } else {
    // OPÃ‡ÃƒO B: Buscar de TODOS os stores possÃ­veis
    const fromActivityStore = activityStore.getChosenActivities();
    const fromDebugStore = debugStore.getCapabilityData('decidir_atividades_criar');
    const fromConversation = conversationStore.getLastAIResponse();
    
    // Tente extrair de QUALQUER fonte disponÃ­vel
    enrichedParams.activities_to_fill = fromActivityStore 
      || fromDebugStore?.result?.chosen_activities
      || parseActivitiesFromConversation(fromConversation);
  }
  
  // VALIDAÃ‡ÃƒO OBRIGATÃ“RIA
  if (!enrichedParams.activities_to_fill || enrichedParams.activities_to_fill.length === 0) {
    // NÃƒO EXECUTE A CAPABILITY - lance erro visÃ­vel
    throw new Error(`EXECUTION ABORTED: No activities found to generate content for. 
      Check if decidir_atividades_criar completed successfully and saved data.`);
  }
  
  // Log extremamente visÃ­vel
  console.error(`ğŸ”¥ GENERATING CONTENT FOR ${enrichedParams.activities_to_fill.length} ACTIVITIES`);
  enrichedParams.activities_to_fill.forEach((act, idx) => {
    console.error(`  Activity ${idx + 1}: Type=${act.type}, Fields=${Object.keys(act.fields || {}).length}`);
  });
}
TAREFA 3: Corrigir o Workflow State Machine
Arquivo: Orquestrador de capabilities (provavelmente em src/lib/capabilities/ ou src/stores/)

Problema: A capability estÃ¡ sendo adicionada Ã  fila de execuÃ§Ã£o mas nÃ£o estÃ¡ esperando a anterior completar.

SoluÃ§Ã£o - Implement strict dependency chain:

typescript
// No lugar onde capabilities sÃ£o enfileiradas:

const capabilityDependencies = {
  'gerar_conteudo_atividades': {
    requires: ['decidir_atividades_criar'],
    awaitDataPersistence: true, // FLAG CRÃTICA
    validateBeforeRun: (params) => {
      if (!params.activities_to_fill?.length) {
        return {
          canRun: false,
          reason: "Dependent capability data not available"
        };
      }
      return { canRun: true };
    }
  }
};

// Antes de executar qualquer capability:
async function executeCapability(name, params) {
  const deps = capabilityDependencies[name];
  
  if (deps) {
    // Aguarde TODAS as dependÃªncias completarem
    for (const requiredCap of deps.requires) {
      await this.waitForCapabilityCompletion(requiredCap);
      
      if (deps.awaitDataPersistence) {
        // Aguarde 100ms adicional para garantir store sync
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    // Valide ANTES de executar
    const validation = deps.validateBeforeRun(params);
    if (!validation.canRun) {
      throw new Error(`Cannot execute ${name}: ${validation.reason}`);
    }
  }
  
  // SÃ“ AGORA execute
  return await this.runCapability(name, params);
}
TAREFA 4: Debug ForÃ§ado na PrÃ³pria Capability
Arquivo: src/lib/capabilities/gerar_conteudo_atividades.ts (ou equivalente)

No INÃCIO da funÃ§Ã£o de execuÃ§Ã£o:

typescript
async execute(params: any) {
  // LOGGING INVASIVO - NÃƒO PODE SER IGNORADO
  const startMessage = `
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸš€ STARTING: gerar_conteudo_atividades
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Received params keys: ${Object.keys(params).join(', ')}
  activities_to_fill exists: ${!!params.activities_to_fill}
  activities_to_fill length: ${params.activities_to_fill?.length || 0}
  activities_to_fill content: ${JSON.stringify(params.activities_to_fill, null, 2)}
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `;
  
  console.error(startMessage);
  await debugStore.addEntry({
    type: 'ACTION',
    message: startMessage,
    capability_id: 'gerar_conteudo_atividades',
    timestamp: new Date().toISOString()
  });
  
  // SE NÃƒO TEM DADOS, FALHE LOUDLY
  if (!params.activities_to_fill || params.activities_to_fill.length === 0) {
    const errorMsg = "âŒ CRITICAL ERROR: No activities received in params!";
    console.error(errorMsg);
    await debugStore.addEntry({
      type: 'ERROR',
      message: errorMsg,
      capability_id: 'gerar_conteudo_atividades'
    });
    throw new Error(errorMsg);
  }
  
  // CONTINUA execuÃ§Ã£o normal...
}
TAREFA 5: Verificar Store de Atividades
Arquivo: src/stores/activityStore.ts ou equivalente

Adicione logging quando atividades sÃ£o salvas:

typescript
setChosenActivities(activities: ChosenActivity[]) {
  console.error(`ğŸ“ STORING ${activities.length} chosen activities`);
  console.error(`   First activity: ${activities[0]?.type}`);
  
  this.chosenActivities = activities;
  
  // VerificaÃ§Ã£o imediata
  const verification = this.getChosenActivities();
  console.error(`âœ… VERIFICATION: Store now contains ${verification.length} activities`);
  
  return verification.length > 0; // Retorne sucesso
}
CHECKLIST DE VALIDAÃ‡ÃƒO OBRIGATÃ“RIA
Execute este teste manual apÃ³s implementar:

âœ“ Inicie uma nova conversa no Jota

âœ“ Acione "decidir_atividades_criar"

âœ“ No console do navegador (F12), verifique se aparece: ğŸ“ STORING X chosen activities

âœ“ Verifique se aparece: âœ… VERIFICATION: Store now contains X activities

âœ“ Quando "gerar_conteudo_atividades" iniciar, DEVE aparecer: ğŸš€ STARTING: gerar_conteudo_atividades com lista de atividades

âœ“ Se nÃ£o aparecer o log ğŸš€, o problema estÃ¡ no AGENDAMENTO, nÃ£o na capability

âœ“ Se aparecer mas mostrar 0 activities, o problema estÃ¡ no TIMING do enrichment

ALTERNATIVA RADICAL: Bypass do Orchestrator
Se NADA funcionar, implemente execuÃ§Ã£o direta:

No final de decidir_atividades_criar:

typescript
// ApÃ³s salvar resultados
const chosenActivities = this.result.chosen_activities;
await activityStore.setChosenActivities(chosenActivities);

// EXECUTE IMEDIATAMENTE a prÃ³xima capability
const contentGenerator = new GerarConteudoAtividades();
await contentGenerator.execute({
  activities_to_fill: chosenActivities,
  session_id: this.session_id,
  user_objective: this.user_objective,
  conversation_context: this.conversation_context
});
Isso garante que os dados estÃ£o disponÃ­veis no momento da execuÃ§Ã£o.

REQUISITO FINAL
ApÃ³s cada tentativa de correÃ§Ã£o, a IA DEVE adicionar um commit message DESCRITIVO:

âŒ "Saved progress at the end of the loop"

âœ… "FIX: Force data persistence verification before triggering content generation"

Isso permite rastrear qual correÃ§Ã£o especÃ­fica funcionou.
â€‹