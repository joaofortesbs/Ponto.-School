Objetivo:

Criar um sistema totalmente funcional, modular e confiável dentro da seção School Power, que:

Recebe a primeira mensagem do usuário (via chat).

Interpreta e armazena corretamente a intenção.

Suavemente esconde os elementos da interface atual (tela inicial).

Renderiza com perfeição o componente de “Contextualização do Plano” como próximo passo.

Protege o sistema contra estados indefinidos, duplicação de renderizações, conflitos de estados ou falhas de transição.

Tecnologias recomendadas:

React 18+

TypeScript estritamente tipado

Zustand para gerenciamento global de estados leves

Framer Motion para transições suaves

Shadcn/UI (ou Tailwind + HeadlessUI) para componentes UI

React Query ou SWR para chamadas assíncronas à IA

Axios para chamadas de API

Zod ou Yup para validações de entrada

localStorage/indexedDB para histórico persistente (se necessário)

⚙️ Escopo da Tarefa:

O sistema deve fazer o seguinte:

Detectar quando o usuário envia sua primeira mensagem na caixa de input (ex: “Quero criar o plano de conteúdos…”).

Verificar se a mensagem é válida (não vazia, com no mínimo 4 palavras) — prevenir falhas.

Armazenar a mensagem original no estado global e/ou localStorage.

Esconder todos os elementos iniciais da interface usando Framer Motion (fade-out, scale-down, ou slide).

Esperar a animação terminar (usar onAnimationComplete).

Renderizar o componente “Card de Contextualização do Plano”.

Garantir que os componentes renderizados sejam exclusivos e não entrem em conflito com roteamento/layouts globais.

🧩 Fluxo Visual da Interface:

Entrada: Caixa de chat
Ação: Usuário envia mensagem
Resultado esperado:

Elementos de introdução desaparecem suavemente

Card de Contextualização aparece com efeito visual

Estrutura do card:

Conteúdos Principais (entrada + tag list)

Tipos de Materiais (entrada + tag list)

Datas Importantes (entrada com calendário + tag list)

Restrições Específicas (entrada + tag list)

Botão “Confirmar Contexto” (ativado somente com todos campos preenchidos)

⚠️ Erros Anteriores a Evitar:

Componentes renderizados em duplicidade após o envio da mensagem

Falta de fallback visual ou loading

Mensagens enviadas sem validação mínima

Estado global quebrando ao atualizar rapidamente

Elementos antigos ainda visíveis (falta de controle no unmount)

✅ Especificações de Implementação:

Crie um Zustand store schoolPowerStore com:

userMessage: string

stage: 'start' | 'contextualization' | 'planning' | 'execution'

contextData: { content: string[]; materials: string[]; dates: string[]; restrictions: string[] }

setStage(), setUserMessage(), setContextData()

No ChatInput:

Verifique se há conteúdo com mais de 3 palavras.

setUserMessage() → ‘mensagem inicial’

setStage('contextualization')

Após isso, dispare uma animação para esconder os elementos da home (motion.div exit)

No componente SchoolPowerInterface:

Faça uma checagem do stage global.

Se for 'start', mostre interface padrão (introdução)

Se for 'contextualization', mostre <ContextualizationForm />

Se for 'planning', mostre <ChecklistPlanner />

Se for 'execution', mostre <IAExecutionDashboard />

No ContextualizationForm:

Cada campo deve ser obrigatório antes de habilitar o botão “Confirmar Contexto”.

Use Zod ou Yup para garantir consistência dos dados (datas válidas, listas não vazias).

setContextData() e setStage('planning') após clique no botão.

Se possível, salve dados no localStorage para restaurar estado se usuário sair da página.

Adicione tratamento de loading caso a IA seja chamada após envio do contexto.

📁 Estrutura Recomendada:

school-power/
├── components/
│ ├── ChatInput.tsx ✅
│ ├── ChatMessageList.tsx
│ ├── ContextualizationForm.tsx ✅
│ ├── ChecklistPlanner.tsx
│ ├── IAExecutionDashboard.tsx
├── state/
│ └── schoolPowerStore.ts ✅
├── services/
│ └── iaService.ts
├── utils/
│ └── validators.ts (Zod/Yup)
├── AppWrapper.tsx
└── index.tsx

🧪 Testes Esperados:

Enviar uma mensagem válida → elementos somem → form de contextualização aparece

Campos obrigatórios ausentes → botão “Confirmar” desativado

Campos preenchidos corretamente → renderiza próxima etapa sem bugs

Refresh da página com dados em localStorage → restaurar estado (opcional)

Mensagens duplicadas → impedidas

Stage incorreto → fallback visual preventivo (erro controlado)

🧠 Considerações Adicionais:

Toda a transição entre telas deve ser desacoplada e controlada por estado, não por imperativo direto.

Todos os dados devem ser isolados por sessão do usuário (ex: professor, aluno, etc.)

Design responsivo e acessível (tabIndex, aria-labels)

Os dados do formulário serão usados para chamada da IA e renderização do plano de ação.