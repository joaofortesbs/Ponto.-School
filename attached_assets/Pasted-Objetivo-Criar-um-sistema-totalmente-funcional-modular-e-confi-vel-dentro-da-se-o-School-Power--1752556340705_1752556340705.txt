Objetivo:

Criar um sistema totalmente funcional, modular e confiÃ¡vel dentro da seÃ§Ã£o School Power, que:

Recebe a primeira mensagem do usuÃ¡rio (via chat).

Interpreta e armazena corretamente a intenÃ§Ã£o.

Suavemente esconde os elementos da interface atual (tela inicial).

Renderiza com perfeiÃ§Ã£o o componente de â€œContextualizaÃ§Ã£o do Planoâ€ como prÃ³ximo passo.

Protege o sistema contra estados indefinidos, duplicaÃ§Ã£o de renderizaÃ§Ãµes, conflitos de estados ou falhas de transiÃ§Ã£o.

Tecnologias recomendadas:

React 18+

TypeScript estritamente tipado

Zustand para gerenciamento global de estados leves

Framer Motion para transiÃ§Ãµes suaves

Shadcn/UI (ou Tailwind + HeadlessUI) para componentes UI

React Query ou SWR para chamadas assÃ­ncronas Ã  IA

Axios para chamadas de API

Zod ou Yup para validaÃ§Ãµes de entrada

localStorage/indexedDB para histÃ³rico persistente (se necessÃ¡rio)

âš™ï¸ Escopo da Tarefa:

O sistema deve fazer o seguinte:

Detectar quando o usuÃ¡rio envia sua primeira mensagem na caixa de input (ex: â€œQuero criar o plano de conteÃºdosâ€¦â€).

Verificar se a mensagem Ã© vÃ¡lida (nÃ£o vazia, com no mÃ­nimo 4 palavras) â€” prevenir falhas.

Armazenar a mensagem original no estado global e/ou localStorage.

Esconder todos os elementos iniciais da interface usando Framer Motion (fade-out, scale-down, ou slide).

Esperar a animaÃ§Ã£o terminar (usar onAnimationComplete).

Renderizar o componente â€œCard de ContextualizaÃ§Ã£o do Planoâ€.

Garantir que os componentes renderizados sejam exclusivos e nÃ£o entrem em conflito com roteamento/layouts globais.

ğŸ§© Fluxo Visual da Interface:

Entrada: Caixa de chat
AÃ§Ã£o: UsuÃ¡rio envia mensagem
Resultado esperado:

Elementos de introduÃ§Ã£o desaparecem suavemente

Card de ContextualizaÃ§Ã£o aparece com efeito visual

Estrutura do card:

ConteÃºdos Principais (entrada + tag list)

Tipos de Materiais (entrada + tag list)

Datas Importantes (entrada com calendÃ¡rio + tag list)

RestriÃ§Ãµes EspecÃ­ficas (entrada + tag list)

BotÃ£o â€œConfirmar Contextoâ€ (ativado somente com todos campos preenchidos)

âš ï¸ Erros Anteriores a Evitar:

Componentes renderizados em duplicidade apÃ³s o envio da mensagem

Falta de fallback visual ou loading

Mensagens enviadas sem validaÃ§Ã£o mÃ­nima

Estado global quebrando ao atualizar rapidamente

Elementos antigos ainda visÃ­veis (falta de controle no unmount)

âœ… EspecificaÃ§Ãµes de ImplementaÃ§Ã£o:

Crie um Zustand store schoolPowerStore com:

userMessage: string

stage: 'start' | 'contextualization' | 'planning' | 'execution'

contextData: { content: string[]; materials: string[]; dates: string[]; restrictions: string[] }

setStage(), setUserMessage(), setContextData()

No ChatInput:

Verifique se hÃ¡ conteÃºdo com mais de 3 palavras.

setUserMessage() â†’ â€˜mensagem inicialâ€™

setStage('contextualization')

ApÃ³s isso, dispare uma animaÃ§Ã£o para esconder os elementos da home (motion.div exit)

No componente SchoolPowerInterface:

FaÃ§a uma checagem do stage global.

Se for 'start', mostre interface padrÃ£o (introduÃ§Ã£o)

Se for 'contextualization', mostre <ContextualizationForm />

Se for 'planning', mostre <ChecklistPlanner />

Se for 'execution', mostre <IAExecutionDashboard />

No ContextualizationForm:

Cada campo deve ser obrigatÃ³rio antes de habilitar o botÃ£o â€œConfirmar Contextoâ€.

Use Zod ou Yup para garantir consistÃªncia dos dados (datas vÃ¡lidas, listas nÃ£o vazias).

setContextData() e setStage('planning') apÃ³s clique no botÃ£o.

Se possÃ­vel, salve dados no localStorage para restaurar estado se usuÃ¡rio sair da pÃ¡gina.

Adicione tratamento de loading caso a IA seja chamada apÃ³s envio do contexto.

ğŸ“ Estrutura Recomendada:

school-power/
â”œâ”€â”€ components/
â”‚ â”œâ”€â”€ ChatInput.tsx âœ…
â”‚ â”œâ”€â”€ ChatMessageList.tsx
â”‚ â”œâ”€â”€ ContextualizationForm.tsx âœ…
â”‚ â”œâ”€â”€ ChecklistPlanner.tsx
â”‚ â”œâ”€â”€ IAExecutionDashboard.tsx
â”œâ”€â”€ state/
â”‚ â””â”€â”€ schoolPowerStore.ts âœ…
â”œâ”€â”€ services/
â”‚ â””â”€â”€ iaService.ts
â”œâ”€â”€ utils/
â”‚ â””â”€â”€ validators.ts (Zod/Yup)
â”œâ”€â”€ AppWrapper.tsx
â””â”€â”€ index.tsx

ğŸ§ª Testes Esperados:

Enviar uma mensagem vÃ¡lida â†’ elementos somem â†’ form de contextualizaÃ§Ã£o aparece

Campos obrigatÃ³rios ausentes â†’ botÃ£o â€œConfirmarâ€ desativado

Campos preenchidos corretamente â†’ renderiza prÃ³xima etapa sem bugs

Refresh da pÃ¡gina com dados em localStorage â†’ restaurar estado (opcional)

Mensagens duplicadas â†’ impedidas

Stage incorreto â†’ fallback visual preventivo (erro controlado)

ğŸ§  ConsideraÃ§Ãµes Adicionais:

Toda a transiÃ§Ã£o entre telas deve ser desacoplada e controlada por estado, nÃ£o por imperativo direto.

Todos os dados devem ser isolados por sessÃ£o do usuÃ¡rio (ex: professor, aluno, etc.)

Design responsivo e acessÃ­vel (tabIndex, aria-labels)

Os dados do formulÃ¡rio serÃ£o usados para chamada da IA e renderizaÃ§Ã£o do plano de aÃ§Ã£o.