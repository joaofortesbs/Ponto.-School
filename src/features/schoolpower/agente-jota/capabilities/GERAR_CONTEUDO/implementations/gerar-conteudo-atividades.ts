/**
 * CAPABILITY: gerar_conteudo_atividades
 * 
 * Responsabilidade: Gerar conteÃºdo para preencher automaticamente os campos
 * de cada atividade decidida, mantendo contexto completo da conversa.
 * 
 * Fluxo:
 * 1. Consome atividades do ChosenActivitiesStore
 * 2. Para cada atividade, gera conteÃºdo baseado no tipo e contexto
 * 3. Atualiza o store com os campos preenchidos
 * 4. Emite eventos para sincronizaÃ§Ã£o com UI
 * 5. Registra debug entries detalhadas para visualizaÃ§Ã£o no DebugModal
 */

import { executeWithCascadeFallback } from '../../../../services/controle-APIs-gerais-school-power';
import { useChosenActivitiesStore, type ChosenActivity } from '../../../../interface-chat-producao/stores/ChosenActivitiesStore';
import { 
  ACTIVITY_FIELDS_MAPPING, 
  getFieldsForActivityType,
  type ActivityFieldsMapping,
  type FieldDefinition 
} from '../schemas/gerar-conteudo-schema';
import { 
  syncSchemaToFormData, 
  validateSyncedFields,
  generateFieldSyncDebugReport,
  persistActivityToStorage
} from '../../../../construction/utils/activity-fields-sync';
import { createDebugEntry, useDebugStore } from '../../../../interface-chat-producao/debug-system/DebugStore';
import { useActivityDebugStore } from '../../../../construction/stores/activityDebugStore';

interface GerarConteudoParams {
  session_id: string;
  conversation_context: string;
  user_objective: string;
  activities_to_fill?: ChosenActivity[];
  on_progress?: (update: ProgressUpdate) => void;
}

interface ProgressUpdate {
  type: 'activity_started' | 'field_generated' | 'activity_completed' | 'activity_error' | 'all_completed';
  activity_id?: string;
  activity_title?: string;
  field_name?: string;
  field_value?: string;
  progress?: number;
  total_activities?: number;
  current_activity?: number;
  error?: string;
  message?: string;
}

interface GeneratedFieldsResult {
  activity_id: string;
  activity_type: string;
  generated_fields: Record<string, any>;
  success: boolean;
  error?: string;
}

interface DebugLogEntry {
  timestamp: string;
  type: 'action' | 'discovery' | 'decision' | 'error' | 'warning' | 'info';
  narrative: string;
  technical_data?: any;
}

interface GerarConteudoOutput {
  success: boolean;
  capability_id: string;
  data: any;
  error: string | null;
  debug_log: DebugLogEntry[];
  execution_time_ms: number;
  message?: string;
}

const MAX_RETRIES = 2;
const EXPONENTIAL_BACKOFF_BASE_MS = 1000;

// ============================================================
// HELPER: Truncamento Inteligente para Debug
// ============================================================
function truncateForDebug(value: any, maxLength: number = 150): string {
  if (value === null || value === undefined) return 'null';
  const str = typeof value === 'string' ? value : JSON.stringify(value);
  if (str.length <= maxLength) return str;
  return str.substring(0, maxLength) + `... [+${str.length - maxLength} chars]`;
}

// ============================================================
// HELPER: Gerar Correlation ID Ãºnico
// ============================================================
function generateCorrelationId(): string {
  return `corr_${Date.now()}_${Math.random().toString(36).slice(2, 7)}`;
}

// ============================================================
// HELPER: Sleep com exponential backoff
// ============================================================
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function buildContentGenerationPrompt(
  activity: ChosenActivity,
  fieldsMapping: ActivityFieldsMapping,
  conversationContext: string,
  userObjective: string
): string {
  const fieldsDescription = fieldsMapping.requiredFields.map((field, idx) => `
${idx + 1}. "${field.name}" (${field.label})
   - DescriÃ§Ã£o: ${field.description}
   - Tipo: ${field.type}
   ${field.options ? `- OpÃ§Ãµes vÃ¡lidas: ${field.options.join(', ')}` : ''}
   ${field.placeholder ? `- Exemplo: ${field.placeholder}` : ''}
`).join('');

  const optionalFieldsDescription = fieldsMapping.optionalFields?.map((field, idx) => `
${idx + 1}. "${field.name}" (${field.label})
   - DescriÃ§Ã£o: ${field.description}
   - Tipo: ${field.type}
   ${field.options ? `- OpÃ§Ãµes vÃ¡lidas: ${field.options.join(', ')}` : ''}
`).join('') || '';

  return `
# TAREFA: Gerar ConteÃºdo para Atividade Educacional

VocÃª Ã© um especialista pedagÃ³gico gerando conteÃºdo detalhado para uma atividade educacional.

## CONTEXTO COMPLETO DA CONVERSA
${conversationContext}

## OBJETIVO ORIGINAL DO USUÃRIO
${userObjective}

## ATIVIDADE A PREENCHER
- **Tipo**: ${fieldsMapping.displayName} (${activity.tipo})
- **TÃ­tulo**: ${activity.titulo}
- **Justificativa da escolha**: ${activity.justificativa}
- **Categoria**: ${activity.categoria || 'NÃ£o especificada'}
- **MatÃ©ria**: ${activity.materia || 'NÃ£o especificada'}

## CAMPOS OBRIGATÃ“RIOS A GERAR
${fieldsDescription}

${optionalFieldsDescription ? `## CAMPOS OPCIONAIS (gere se relevante)
${optionalFieldsDescription}` : ''}

## INSTRUÃ‡Ã•ES CRÃTICAS

1. **MANTENHA COERÃŠNCIA**: Todo conteÃºdo deve estar alinhado com o objetivo original do usuÃ¡rio
2. **SEJA ESPECÃFICO**: Gere conteÃºdo detalhado e pronto para uso, nÃ£o genÃ©rico
3. **RESPEITE O CONTEXTO**: Use informaÃ§Ãµes da conversa (disciplina, sÃ©rie, tema) 
4. **QUALIDADE PEDAGÃ“GICA**: ConteÃºdo deve ser educacionalmente vÃ¡lido
5. **CAMPOS SELECT**: Use APENAS as opÃ§Ãµes listadas
6. **CAMPOS TEXTAREA**: Gere texto rico e detalhado (mÃ­nimo 50 caracteres)
7. **CAMPOS NUMBER**: Use valores numÃ©ricos apropriados

## FORMATO DE RESPOSTA (JSON VÃLIDO)

{
  "generated_fields": {
    "${fieldsMapping.requiredFields[0]?.name || 'campo1'}": "valor gerado...",
    "${fieldsMapping.requiredFields[1]?.name || 'campo2'}": "valor gerado..."
  },
  "reasoning": "Breve explicaÃ§Ã£o de como o conteÃºdo foi pensado pedagogicamente"
}

âš ï¸ Retorne APENAS o JSON vÃ¡lido, sem texto adicional antes ou depois.
`.trim();
}

function validateGeneratedFields(
  fields: Record<string, any>,
  mapping: ActivityFieldsMapping
): { valid: boolean; errors: string[]; correctedFields: Record<string, any> } {
  const errors: string[] = [];
  const correctedFields = { ...fields };

  for (const fieldDef of mapping.requiredFields) {
    const value = fields[fieldDef.name];
    
    if (value === undefined || value === null || value === '') {
      errors.push(`Campo obrigatÃ³rio "${fieldDef.label}" nÃ£o foi preenchido`);
      continue;
    }

    if (fieldDef.type === 'select' && fieldDef.options) {
      const normalizedValue = String(value).toLowerCase();
      const validOption = fieldDef.options.find(opt => 
        opt.toLowerCase() === normalizedValue
      );
      if (!validOption) {
        const closestOption = fieldDef.options[0];
        correctedFields[fieldDef.name] = closestOption;
        errors.push(`Campo "${fieldDef.label}" corrigido de "${value}" para "${closestOption}"`);
      } else {
        correctedFields[fieldDef.name] = validOption;
      }
    }

    if (fieldDef.type === 'number') {
      const numValue = Number(value);
      if (isNaN(numValue)) {
        correctedFields[fieldDef.name] = 10;
        errors.push(`Campo "${fieldDef.label}" nÃ£o Ã© numÃ©rico, usando valor padrÃ£o`);
      } else {
        correctedFields[fieldDef.name] = numValue;
      }
    }

    if (fieldDef.type === 'textarea') {
      const textValue = String(value);
      if (textValue.length < 20) {
        errors.push(`Campo "${fieldDef.label}" tem conteÃºdo muito curto`);
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    correctedFields
  };
}

async function generateContentForActivity(
  activity: ChosenActivity,
  conversationContext: string,
  userObjective: string,
  onProgress?: (update: ProgressUpdate) => void,
  capabilityId?: string,
  capabilityName?: string
): Promise<GeneratedFieldsResult> {
  const correlationId = generateCorrelationId();
  const activityStartTime = Date.now();
  const CAPABILITY_ID = capabilityId || 'gerar_conteudo_atividades';
  const CAPABILITY_NAME = capabilityName || 'Gerando conteÃºdo para as atividades';
  
  const fieldsMapping = getFieldsForActivityType(activity.tipo);
  
  if (!fieldsMapping) {
    console.warn(`âš ï¸ [GerarConteudo] Tipo de atividade nÃ£o mapeado: ${activity.tipo}`);
    
    createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'error',
      `Tipo de atividade "${activity.tipo}" nÃ£o possui mapeamento de campos definido.`,
      'high',
      { correlation_id: correlationId, activity_id: activity.id, activity_type: activity.tipo }
    );
    
    return {
      activity_id: activity.id,
      activity_type: activity.tipo,
      generated_fields: {},
      success: false,
      error: `Tipo de atividade "${activity.tipo}" nÃ£o possui mapeamento de campos`
    };
  }

  // ========================================
  // ESTÃGIO 1: PRE-GENERATION (Schema Mapping)
  // ========================================
  const requiredFieldNames = fieldsMapping.requiredFields.map(f => f.name);
  const optionalFieldNames = fieldsMapping.optionalFields?.map(f => f.name) || [];
  
  createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'info',
    `[PRE-GEN] Mapeando schema para "${activity.titulo}" (${fieldsMapping.displayName}):\n` +
    `- Campos obrigatÃ³rios: ${requiredFieldNames.join(', ')}\n` +
    `- Campos opcionais: ${optionalFieldNames.length > 0 ? optionalFieldNames.join(', ') : 'nenhum'}`,
    'low',
    { 
      correlation_id: correlationId,
      stage: 'pre_generation',
      activity_id: activity.id,
      activity_type: activity.tipo,
      schema: {
        required_fields: requiredFieldNames,
        optional_fields: optionalFieldNames,
        total_fields: requiredFieldNames.length + optionalFieldNames.length
      }
    }
  );

  const prompt = buildContentGenerationPrompt(
    activity,
    fieldsMapping,
    conversationContext,
    userObjective
  );

  let lastError: string = '';
  
  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    const attemptStartTime = Date.now();
    
    // Exponential backoff para retries
    if (attempt > 0) {
      const backoffMs = EXPONENTIAL_BACKOFF_BASE_MS * Math.pow(2, attempt - 1);
      console.log(`â³ [GerarConteudo] Aguardando ${backoffMs}ms antes da tentativa ${attempt + 1}`);
      
      createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'warning',
        `[GEN] Retry ${attempt + 1}/${MAX_RETRIES + 1} apÃ³s ${backoffMs}ms de backoff. Erro anterior: ${truncateForDebug(lastError, 100)}`,
        'medium',
        { correlation_id: correlationId, attempt, backoff_ms: backoffMs, previous_error: lastError }
      );
      
      await sleep(backoffMs);
    }
    
    try {
      console.log(`ğŸ¯ [GerarConteudo] Gerando conteÃºdo para "${activity.titulo}" (tentativa ${attempt + 1})`);
      
      // ========================================
      // ESTÃGIO 2: GENERATION (API Call)
      // ========================================
      createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'action',
        `[GEN] Chamando API LLM para "${activity.titulo}" (tentativa ${attempt + 1}/${MAX_RETRIES + 1})`,
        'low',
        { 
          correlation_id: correlationId,
          stage: 'generation',
          attempt: attempt + 1,
          prompt_length: prompt.length,
          prompt_preview: truncateForDebug(prompt, 200)
        }
      );
      
      const response = await executeWithCascadeFallback(prompt);
      const apiResponseTime = Date.now() - attemptStartTime;

      if (!response.success || !response.data) {
        lastError = response.errors?.[0]?.error || 'Resposta vazia da IA';
        
        createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'warning',
          `[GEN] API retornou erro: ${truncateForDebug(lastError, 100)}`,
          'medium',
          { 
            correlation_id: correlationId, 
            stage: 'generation',
            error: lastError, 
            response_time_ms: apiResponseTime,
            model_used: response.modelUsed || 'unknown'
          }
        );
        
        continue;
      }

      // ========================================
      // ESTÃGIO 3: POST-GENERATION (Validation & Formatting)
      // ========================================
      let parsed: any;
      try {
        const jsonMatch = response.data.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          lastError = 'Resposta nÃ£o contÃ©m JSON vÃ¡lido';
          
          createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'warning',
            `[POST-GEN] Falha ao extrair JSON da resposta`,
            'medium',
            { 
              correlation_id: correlationId, 
              stage: 'post_generation',
              raw_response_preview: truncateForDebug(response.data, 300)
            }
          );
          
          continue;
        }
        parsed = JSON.parse(jsonMatch[0]);
      } catch (parseError) {
        lastError = 'Erro ao parsear JSON da resposta';
        
        createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'warning',
          `[POST-GEN] Erro de parse JSON: ${parseError instanceof Error ? parseError.message : 'unknown'}`,
          'medium',
          { correlation_id: correlationId, stage: 'post_generation' }
        );
        
        continue;
      }

      if (!parsed.generated_fields || typeof parsed.generated_fields !== 'object') {
        lastError = 'Resposta nÃ£o contÃ©m generated_fields';
        continue;
      }

      const validation = validateGeneratedFields(parsed.generated_fields, fieldsMapping);
      
      // Log de validaÃ§Ã£o detalhado
      createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'discovery',
        `[POST-GEN] ValidaÃ§Ã£o de schema concluÃ­da:\n` +
        `- Campos validados: ${Object.keys(validation.correctedFields).length}\n` +
        `- CorreÃ§Ãµes aplicadas: ${validation.errors.length}` +
        (validation.errors.length > 0 ? `\n- Detalhes: ${validation.errors.join('; ')}` : ''),
        validation.errors.length > 0 ? 'medium' : 'low',
        { 
          correlation_id: correlationId,
          stage: 'post_generation',
          validation_passed: validation.valid,
          corrections_count: validation.errors.length,
          corrections: validation.errors
        }
      );
      
      if (validation.errors.length > 0) {
        console.log(`âš ï¸ [GerarConteudo] CorreÃ§Ãµes aplicadas: ${validation.errors.join(', ')}`);
      }

      for (const [fieldName, fieldValue] of Object.entries(validation.correctedFields)) {
        onProgress?.({
          type: 'field_generated',
          activity_id: activity.id,
          activity_title: activity.titulo,
          field_name: fieldName,
          field_value: String(fieldValue).substring(0, 50) + '...'
        });
      }

      // Log final de sucesso com todos os campos gerados
      const fieldsGeneratedSummary = Object.entries(validation.correctedFields)
        .map(([key, value]) => `â€¢ ${key}: "${truncateForDebug(value, 80)}"`)
        .join('\n');
      
      createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'action',
        `[POST-GEN] GeraÃ§Ã£o concluÃ­da para "${activity.titulo}":\n${fieldsGeneratedSummary}`,
        'low',
        { 
          correlation_id: correlationId,
          stage: 'post_generation',
          activity_id: activity.id,
          total_execution_time_ms: Date.now() - activityStartTime,
          api_response_time_ms: apiResponseTime,
          fields_count: Object.keys(validation.correctedFields).length,
          generated_fields: validation.correctedFields
        }
      );

      return {
        activity_id: activity.id,
        activity_type: activity.tipo,
        generated_fields: validation.correctedFields,
        success: true
      };

    } catch (error) {
      lastError = error instanceof Error ? error.message : 'Erro desconhecido';
      console.error(`âŒ [GerarConteudo] Erro na tentativa ${attempt + 1}:`, lastError);
      
      createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'error',
        `[GEN] ExceÃ§Ã£o na tentativa ${attempt + 1}: ${truncateForDebug(lastError, 150)}`,
        'high',
        { 
          correlation_id: correlationId, 
          stage: 'generation',
          attempt: attempt + 1,
          error: lastError,
          stack_trace: error instanceof Error ? error.stack?.substring(0, 500) : undefined
        }
      );
    }
  }

  // Falha apÃ³s todas as tentativas
  createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'error',
    `Falha ao gerar conteÃºdo para "${activity.titulo}" apÃ³s ${MAX_RETRIES + 1} tentativas. Ãšltimo erro: ${truncateForDebug(lastError, 150)}`,
    'high',
    { 
      correlation_id: correlationId,
      activity_id: activity.id,
      total_attempts: MAX_RETRIES + 1,
      final_error: lastError,
      total_time_ms: Date.now() - activityStartTime
    }
  );

  return {
    activity_id: activity.id,
    activity_type: activity.tipo,
    generated_fields: {},
    success: false,
    error: lastError
  };
}

export async function gerarConteudoAtividades(
  params: GerarConteudoParams
): Promise<GerarConteudoOutput> {
  const startTime = Date.now();
  const debugLog: DebugLogEntry[] = [];
  const CAPABILITY_ID = 'gerar_conteudo_atividades';
  const CAPABILITY_NAME = 'Gerando conteÃºdo para as atividades';
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”¥ LOGGING INVASIVO - DIAGNÃ“STICO DE PARÃ‚METROS RECEBIDOS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const diagnosticMessage = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš€ STARTING: gerar_conteudo_atividades
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Received params keys: ${Object.keys(params).join(', ')}
activities_to_fill exists: ${!!params.activities_to_fill}
activities_to_fill length: ${params.activities_to_fill?.length || 0}
session_id: ${params.session_id || 'NOT PROVIDED'}
user_objective: ${params.user_objective?.substring(0, 50) || 'NOT PROVIDED'}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  
  console.error(diagnosticMessage);
  
  // Inicializar DebugStore
  useDebugStore.getState().startCapability(CAPABILITY_ID, CAPABILITY_NAME);
  
  // Entry com diagnÃ³stico completo
  createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'action', 
    `Iniciando execuÃ§Ã£o da capability "${CAPABILITY_NAME}". Objetivo: processar dados conforme parÃ¢metros recebidos.`,
    'low',
    { 
      session_id: params.session_id, 
      objetivo: params.user_objective?.substring(0, 100),
      params_keys: Object.keys(params),
      activities_to_fill_count: params.activities_to_fill?.length || 0
    }
  );
  
  debugLog.push({
    timestamp: new Date().toISOString(),
    type: 'action',
    narrative: 'ğŸš€ Iniciando geraÃ§Ã£o de conteÃºdo para atividades',
    technical_data: { session_id: params.session_id }
  });

  // BUSCA DE ATIVIDADES COM MÃšLTIPLAS FONTES (FALLBACK ROBUSTO)
  const store = useChosenActivitiesStore.getState();
  
  // Fonte 1: ParÃ¢metro activities_to_fill (preferencial - vem do executor)
  let activities = params.activities_to_fill;
  let activitySource = 'params.activities_to_fill';
  
  // Fonte 2: Fallback para store
  if (!activities || activities.length === 0) {
    activities = store.getChosenActivities();
    activitySource = 'store.getChosenActivities()';
    console.error(`ğŸ“¦ [GerarConteudo] Fallback para store: ${activities?.length || 0} atividades`);
  }
  
  // Log detalhado das fontes de dados
  console.error(`
ğŸ“Š [GerarConteudo] FONTES DE DADOS:
   - params.activities_to_fill: ${params.activities_to_fill?.length || 0} atividades
   - store.getChosenActivities(): ${store.getChosenActivities()?.length || 0} atividades
   - store.isDecisionComplete: ${store.isDecisionComplete}
   - store.sessionId: ${store.sessionId}
   - FONTE USADA: ${activitySource}
   - TOTAL FINAL: ${activities?.length || 0} atividades
  `);

  if (!activities || activities.length === 0) {
    const errorDetail = `
âŒ CRITICAL ERROR: No activities received!
   - params.activities_to_fill: ${params.activities_to_fill?.length || 'undefined'}
   - store.getChosenActivities(): ${store.getChosenActivities()?.length || 0}
   - store.isDecisionComplete: ${store.isDecisionComplete}
   - Possible cause: gerar_conteudo_atividades executed BEFORE decidir_atividades_criar saved data
    `;
    console.error(errorDetail);
    
    createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'error',
      'Nenhuma atividade encontrada para preencher. Verifique se a capability "decidir_atividades_criar" foi executada e salvou os dados.',
      'high',
      {
        params_activities_count: params.activities_to_fill?.length || 0,
        store_activities_count: store.getChosenActivities()?.length || 0,
        store_is_decision_complete: store.isDecisionComplete,
        diagnostic: 'TIMING ISSUE - capability executed before data persistence'
      }
    );
    
    // CRÃTICO: Encerrar capability antes de retornar
    useDebugStore.getState().endCapability(CAPABILITY_ID);
    
    return {
      success: false,
      capability_id: CAPABILITY_ID,
      error: 'Nenhuma atividade encontrada para preencher. A capability decidir_atividades_criar pode nÃ£o ter salvado os dados corretamente.',
      data: null,
      debug_log: debugLog,
      execution_time_ms: Date.now() - startTime
    };
  }
  
  // LOG DE SUCESSO - ATIVIDADES ENCONTRADAS
  console.error(`ğŸ”¥ GENERATING CONTENT FOR ${activities.length} ACTIVITIES (source: ${activitySource})`);
  activities.forEach((act, idx) => {
    console.error(`  Activity ${idx + 1}: ID=${act.id}, Type=${act.tipo}, Title=${act.titulo}`);
  });

  // Entry informativa sobre capabilities encontradas
  createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'info',
    `Capability "${CAPABILITY_ID}" encontrada no registro. Iniciando execuÃ§Ã£o com os parÃ¢metros configurados.`,
    'low'
  );
  
  // Entry com descoberta das atividades
  const activitySummary = activities.map(a => `â€¢ ${a.titulo} (${a.tipo})`).join('\n');
  createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'discovery',
    `Encontradas ${activities.length} atividades para gerar conteÃºdo:\n${activitySummary}`,
    'low',
    { 
      quantidade: activities.length,
      atividades: activities.map(a => ({ id: a.id, titulo: a.titulo, tipo: a.tipo }))
    }
  );
  
  debugLog.push({
    timestamp: new Date().toISOString(),
    type: 'discovery',
    narrative: `ğŸ“‹ ${activities.length} atividades para preencher`,
    technical_data: { activity_ids: activities.map(a => a.id) }
  });
  
  // MOSTRAR CAMPOS QUE PRECISAM SER GERADOS PARA CADA ATIVIDADE
  for (const activity of activities) {
    const fieldsMapping = getFieldsForActivityType(activity.tipo);
    
    if (fieldsMapping) {
      const requiredFieldsList = fieldsMapping.requiredFields.map(f => `â€¢ ${f.label}: ${f.description}`).join('\n');
      const optionalFieldsList = fieldsMapping.optionalFields?.map(f => `â€¢ ${f.label}: ${f.description}`).join('\n') || '';
      
      createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'discovery',
        `ğŸ“‹ Campos para "${activity.titulo}" (${fieldsMapping.displayName}):\n\n` +
        `CAMPOS OBRIGATÃ“RIOS:\n${requiredFieldsList}` +
        (optionalFieldsList ? `\n\nCAMPOS OPCIONAIS:\n${optionalFieldsList}` : ''),
        'low',
        {
          activity_id: activity.id,
          activity_type: activity.tipo,
          required_fields: fieldsMapping.requiredFields.map(f => f.name),
          optional_fields: fieldsMapping.optionalFields?.map(f => f.name) || []
        }
      );
    } else {
      createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'warning',
        `Tipo de atividade "${activity.tipo}" nÃ£o possui mapeamento de campos definido.`,
        'medium'
      );
    }
  }

  const results: GeneratedFieldsResult[] = [];
  const totalActivities = activities.length;

  // Obter referÃªncia do ActivityDebugStore para logs detalhados por atividade
  const activityDebugStore = useActivityDebugStore.getState();

  for (let i = 0; i < activities.length; i++) {
    const activity = activities[i];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INICIALIZAR DEBUG DA ATIVIDADE - Logs aparecerÃ£o no ActivityDebugModal
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    activityDebugStore.initActivity(activity.id, activity.titulo, activity.tipo);
    activityDebugStore.setStatus(activity.id, 'building');
    activityDebugStore.setProgress(activity.id, 0, 'Iniciando geraÃ§Ã£o de conteÃºdo');
    
    activityDebugStore.log(
      activity.id, 'action', 'GerarConteudo',
      `Iniciando geraÃ§Ã£o de conteÃºdo para "${activity.titulo}"`,
      { 
        activity_type: activity.tipo, 
        index: i + 1, 
        total: totalActivities,
        fields_to_generate: getFieldsForActivityType(activity.tipo)?.requiredFields?.map(f => f.name) || []
      }
    );
    
    params.on_progress?.({
      type: 'activity_started',
      activity_id: activity.id,
      activity_title: activity.titulo,
      current_activity: i + 1,
      total_activities: totalActivities,
      progress: Math.round((i / totalActivities) * 100),
      message: `Gerando conteÃºdo para: ${activity.titulo}`
    });

    store.updateActivityStatus(activity.id, 'construindo', Math.round((i / totalActivities) * 100));
    
    activityDebugStore.setProgress(activity.id, 10, 'Preparando chamada Ã  API de IA');
    activityDebugStore.log(
      activity.id, 'api', 'GerarConteudo',
      'Chamando API de IA (Groq/Gemini) para gerar campos...',
      { model_cascade: ['llama3.3-70b', 'llama3.1-8b', 'gemini-1.5-flash'] }
    );

    const result = await generateContentForActivity(
      activity,
      params.conversation_context,
      params.user_objective,
      params.on_progress,
      CAPABILITY_ID,
      CAPABILITY_NAME
    );

    // A funÃ§Ã£o generateContentForActivity jÃ¡ registra debug entries detalhadas
    // Aqui sÃ³ atualizamos o store e emitimos eventos

    results.push(result);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOGS DE DEBUG PÃ“S-GERAÃ‡ÃƒO - Mostrar resultado da API
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    activityDebugStore.setProgress(activity.id, 50, 'Processando resposta da IA');
    
    if (result.success) {
      activityDebugStore.log(
        activity.id, 'success', 'API-Response',
        `API retornou ${Object.keys(result.generated_fields).length} campos gerados`,
        { 
          fields_generated: Object.keys(result.generated_fields),
          sample_values: Object.fromEntries(
            Object.entries(result.generated_fields).slice(0, 3).map(([k, v]) => 
              [k, typeof v === 'string' ? v.substring(0, 100) + (v.length > 100 ? '...' : '') : v]
            )
          )
        }
      );
    } else {
      activityDebugStore.log(
        activity.id, 'error', 'API-Response',
        `Falha na geraÃ§Ã£o: ${result.error}`,
        { error: result.error }
      );
    }

    if (result.success) {
      // CORREÃ‡ÃƒO: Primeiro salvamos os campos, DEPOIS atualizamos o status para 'concluida'
      // Isso garante que o contador de campos esteja correto quando o status mudar
      
      activityDebugStore.setProgress(activity.id, 60, 'Sincronizando campos com formulÃ¡rio');
      const syncedFields = syncSchemaToFormData(activity.tipo, result.generated_fields);
      
      console.log('%cğŸ“Š [GerarConteudo] RelatÃ³rio de sincronizaÃ§Ã£o:', 
        'background: #9C27B0; color: white; padding: 2px 5px; border-radius: 3px;');
      console.log(generateFieldSyncDebugReport(activity.tipo, syncedFields));
      
      const validation = validateSyncedFields(activity.tipo, syncedFields);
      console.log(`%cğŸ“‹ [GerarConteudo] ValidaÃ§Ã£o: ${validation.filledFields.length} campos preenchidos, ${validation.missingFields.length} faltando`,
        validation.valid ? 'color: green;' : 'color: orange;');
      
      activityDebugStore.setProgress(activity.id, 70, 'Validando campos gerados');
      activityDebugStore.log(
        activity.id, 'info', 'Validation',
        `ValidaÃ§Ã£o: ${validation.filledFields.length} campos preenchidos, ${validation.missingFields.length} faltando`,
        { 
          filled_fields: validation.filledFields,
          missing_fields: validation.missingFields,
          is_valid: validation.valid
        }
      );
      
      store.setActivityGeneratedFields(activity.id, syncedFields);
      
      const updatedActivity = store.getActivityById(activity.id);
      if (updatedActivity) {
        store.setActivityBuiltData(activity.id, {
          ...updatedActivity.dados_construidos,
          generated_fields: syncedFields,
          original_generated_fields: result.generated_fields,
          generation_timestamp: new Date().toISOString(),
          sync_validation: validation
        });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PERSISTÃŠNCIA IMEDIATA NO LOCALSTORAGE
      // Esta Ã© a correÃ§Ã£o crÃ­tica: salvar no localStorage AGORA, nÃ£o depender
      // do autoBuildService/ModalBridge que pode ter race conditions
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      activityDebugStore.setProgress(activity.id, 80, 'Salvando no localStorage');
      activityDebugStore.log(
        activity.id, 'action', 'LocalStorage',
        'Persistindo dados no localStorage...',
        { keys_to_save: ['activity_*', 'constructed_*', 'generated_content_*'] }
      );
      
      const savedKeys = persistActivityToStorage(
        activity.id,
        activity.tipo,
        activity.titulo,
        syncedFields,
        {
          description: (activity as any).descricao || activity.titulo,
          isPreGenerated: true,
          source: 'gerar_conteudo_atividades'
        }
      );
      
      console.log(`%cğŸ’¾ [GerarConteudo] Atividade persistida em ${savedKeys.length} chaves do localStorage`,
        'background: #FF5722; color: white; padding: 2px 5px; border-radius: 3px;');
      
      activityDebugStore.log(
        activity.id, 'success', 'LocalStorage',
        `Dados persistidos em ${savedKeys.length} chaves do localStorage`,
        { saved_keys: savedKeys }
      );

      // CORREÃ‡ÃƒO CRÃTICA: Usar contagens diretamente do syncedFields que acabamos de criar
      // NÃƒO depender do store pois pode nÃ£o ter atualizado ainda
      const actualFieldsCount = validation.filledFields.length; // Contagem exata do validation
      const totalRequiredFields = activity.campos_obrigatorios?.length || validation.filledFields.length + validation.missingFields.length;
      
      console.log(`%câœ… [GerarConteudo] Campos gerados para ${activity.id}: ${actualFieldsCount}/${totalRequiredFields} campos. Atualizando status para 'concluida'`,
        'background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px;');
      
      // Aguardar prÃ³ximo tick para garantir que o store foi atualizado
      await Promise.resolve();
      
      // Status 'concluida' sÃ³ Ã© definido DEPOIS que os campos foram salvos
      store.updateActivityStatus(activity.id, 'concluida', 100);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // MARCAR DEBUG COMO CONCLUÃDO - ActivityDebugModal mostrarÃ¡ status verde
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      activityDebugStore.setProgress(activity.id, 100, 'Atividade construÃ­da com sucesso');
      activityDebugStore.markCompleted(activity.id);

      console.log('ğŸ“¤ [GerarConteudo] Emitindo evento agente-jota-fields-generated para:', activity.id);
      window.dispatchEvent(new CustomEvent('agente-jota-fields-generated', {
        detail: {
          activity_id: activity.id,
          activity_type: activity.tipo,
          fields: syncedFields,
          original_fields: result.generated_fields,
          validation: validation,
          // CORREÃ‡ÃƒO: Usar contagens diretamente do syncedFields/validation, nÃ£o do store
          fields_completed: actualFieldsCount,
          fields_total: totalRequiredFields
        }
      }));

      params.on_progress?.({
        type: 'activity_completed',
        activity_id: activity.id,
        activity_title: activity.titulo,
        current_activity: i + 1,
        total_activities: totalActivities,
        progress: Math.round(((i + 1) / totalActivities) * 100),
        message: `ConteÃºdo gerado para: ${activity.titulo}`
      });

      debugLog.push({
        timestamp: new Date().toISOString(),
        type: 'action',
        narrative: `âœ… ConteÃºdo gerado para "${activity.titulo}"`,
        technical_data: { 
          activity_id: activity.id,
          fields_count: Object.keys(result.generated_fields).length,
          generated_fields: result.generated_fields
        }
      });

    } else {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // MARCAR DEBUG COMO ERRO - ActivityDebugModal mostrarÃ¡ status vermelho
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      activityDebugStore.setError(activity.id, result.error || 'Erro desconhecido na geraÃ§Ã£o');
      
      store.updateActivityStatus(activity.id, 'erro', 0, result.error);
      
      params.on_progress?.({
        type: 'activity_error',
        activity_id: activity.id,
        activity_title: activity.titulo,
        error: result.error,
        message: `Erro ao gerar conteÃºdo para: ${activity.titulo}`
      });

      debugLog.push({
        timestamp: new Date().toISOString(),
        type: 'error',
        narrative: `âŒ Erro em "${activity.titulo}": ${result.error}`,
        technical_data: { activity_id: activity.id, error: result.error }
      });
    }
  }

  const successCount = results.filter(r => r.success).length;
  const failCount = results.filter(r => !r.success).length;
  const executionTime = Date.now() - startTime;

  const totalFieldsGenerated = results.reduce((acc, r) => 
    acc + (r.success ? Object.keys(r.generated_fields || {}).length : 0), 0
  );
  
  createDebugEntry(CAPABILITY_ID, CAPABILITY_NAME, 'action',
    `Capability "${CAPABILITY_NAME}" concluÃ­da em ${executionTime}ms.\n` +
    `Atividades processadas: ${successCount}/${totalActivities}\n` +
    `Total de campos gerados: ${totalFieldsGenerated}`,
    failCount > 0 ? 'medium' : 'low',
    {
      success_count: successCount,
      fail_count: failCount,
      total_fields_generated: totalFieldsGenerated,
      execution_time_ms: executionTime
    }
  );
  
  useDebugStore.getState().endCapability(CAPABILITY_ID);

  params.on_progress?.({
    type: 'all_completed',
    total_activities: totalActivities,
    progress: 100,
    message: `GeraÃ§Ã£o concluÃ­da: ${successCount} sucesso, ${failCount} erros`
  });

  window.dispatchEvent(new CustomEvent('agente-jota-content-generation-complete', {
    detail: {
      session_id: params.session_id,
      success_count: successCount,
      fail_count: failCount,
      results
    }
  }));

  debugLog.push({
    timestamp: new Date().toISOString(),
    type: 'action',
    narrative: `ğŸ GeraÃ§Ã£o de conteÃºdo finalizada: ${successCount}/${totalActivities} atividades`,
    technical_data: { success_count: successCount, fail_count: failCount }
  });

  // PARTIAL SUCCESS: Se pelo menos 1 atividade foi gerada, consideramos sucesso
  const isPartialOrFullSuccess = successCount > 0;
  const successfulResults = results.filter(r => r.success);
  
  if (failCount > 0 && successCount > 0) {
    console.log(`ğŸ“Š [GerarConteudo] PARTIAL SUCCESS: ${successCount} succeeded, ${failCount} failed. Pipeline continues.`);
  }
  
  return {
    success: isPartialOrFullSuccess, // â† MUDANÃ‡A: sucesso se pelo menos 1 atividade gerada
    capability_id: CAPABILITY_ID,
    data: {
      session_id: params.session_id,
      total_activities: totalActivities,
      success_count: successCount,
      fail_count: failCount,
      results,
      successful_results: successfulResults, // â† NOVO: apenas atividades bem-sucedidas
      partial_success: failCount > 0 && successCount > 0,
      generated_at: new Date().toISOString()
    },
    error: failCount > 0 && successCount === 0 
      ? `Todas as ${failCount} atividades falharam` 
      : (failCount > 0 ? `${failCount} falharam, ${successCount} bem-sucedidas` : null),
    debug_log: debugLog,
    execution_time_ms: executionTime,
    message: `ConteÃºdo gerado para ${successCount} de ${totalActivities} atividades`
  };
}

export default gerarConteudoAtividades;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERSÃƒO V2 - API-FIRST CAPABILITY (Seguindo padrÃ£o de decidirAtividadesCriarV2)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import type { 
  CapabilityInput, 
  CapabilityOutput, 
  CapabilityError,
  ChosenActivity as ChosenActivityFromTypes
} from '../../shared/types';

// Helper para criar erro estruturado compatÃ­vel com CapabilityOutput
function createCapabilityError(message: string, severity: 'low' | 'medium' | 'high' | 'critical' = 'high'): CapabilityError {
  return {
    code: 'GENERATION_ERROR',
    message,
    severity,
    recoverable: severity !== 'critical',
    recovery_suggestion: severity === 'critical' 
      ? 'Reinicie o fluxo de criaÃ§Ã£o de atividades'
      : 'Tente novamente ou verifique os parÃ¢metros de entrada'
  };
}

export async function gerarConteudoAtividadesV2(
  input: CapabilityInput
): Promise<CapabilityOutput> {
  const debug_log: DebugLogEntry[] = [];
  const startTime = Date.now();
  const CAPABILITY_ID = 'gerar_conteudo_atividades';
  
  try {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. OBTER RESULTADO DA CAPABILITY ANTERIOR (decidir_atividades_criar)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.error(`
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš€ [V2] STARTING: gerarConteudoAtividadesV2
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
input.execution_id: ${input.execution_id}
input.previous_results keys: ${input.previous_results ? Array.from(input.previous_results.keys()).join(', ') : 'NONE'}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);

    // Tentar obter atividades da capability anterior
    const decisionResult = input.previous_results?.get('decidir_atividades_criar');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DIAGNÃ“STICO COMPLETO DO decisionResult
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.error(`
ğŸ” [V2] DIAGNOSTIC: decisionResult FULL ANALYSIS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
decisionResult exists: ${!!decisionResult}
decisionResult type: ${typeof decisionResult}
decisionResult keys: ${decisionResult ? Object.keys(decisionResult).join(', ') : 'NONE'}
decisionResult.success: ${decisionResult?.success}
decisionResult.data exists: ${!!(decisionResult as any)?.data}
decisionResult.data type: ${typeof (decisionResult as any)?.data}
decisionResult.data keys: ${(decisionResult as any)?.data ? Object.keys((decisionResult as any).data).join(', ') : 'NONE'}
decisionResult.chosen_activities exists: ${!!(decisionResult as any)?.chosen_activities}
decisionResult.chosen_activities length: ${(decisionResult as any)?.chosen_activities?.length || 0}
decisionResult.data?.chosen_activities exists: ${!!(decisionResult as any)?.data?.chosen_activities}
decisionResult.data?.chosen_activities length: ${(decisionResult as any)?.data?.chosen_activities?.length || 0}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    
    if (!decisionResult) {
      throw new Error('Dependency nÃ£o encontrada: decidir_atividades_criar. Execute a capability de decisÃ£o primeiro.');
    }
    
    if (!decisionResult.success) {
      throw new Error(`Dependency falhou: decidir_atividades_criar retornou success=false. Erro: ${decisionResult.error}`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NORMALIZAÃ‡ÃƒO ROBUSTA: Suportar TODOS os formatos possÃ­veis
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const resultAsAny = decisionResult as any;
    
    // Tentar mÃºltiplos caminhos para encontrar as atividades
    let chosenActivities: ChosenActivity[] = [];
    let activitySource = 'none';
    
    // Caminho 1: V2 format - data.chosen_activities
    if (resultAsAny.data?.chosen_activities?.length > 0) {
      chosenActivities = resultAsAny.data.chosen_activities;
      activitySource = 'data.chosen_activities (V2)';
    }
    // Caminho 2: Legacy format - chosen_activities direto
    else if (resultAsAny.chosen_activities?.length > 0) {
      chosenActivities = resultAsAny.chosen_activities;
      activitySource = 'chosen_activities (legacy)';
    }
    // Caminho 3: Outro formato possÃ­vel - activities
    else if (resultAsAny.activities?.length > 0) {
      chosenActivities = resultAsAny.activities;
      activitySource = 'activities (alt)';
    }
    // Caminho 4: Outro formato - data.activities
    else if (resultAsAny.data?.activities?.length > 0) {
      chosenActivities = resultAsAny.data.activities;
      activitySource = 'data.activities (alt)';
    }
    // Caminho 5: Fallback para store
    else {
      const store = useChosenActivitiesStore.getState();
      chosenActivities = store.getChosenActivities();
      activitySource = 'store fallback';
    }
    
    console.error(`ğŸ“Š [V2] chosenActivities source: ${activitySource}`);
    console.error(`ğŸ“Š [V2] chosenActivities count: ${chosenActivities.length}`);
    
    if (chosenActivities.length === 0) {
      throw new Error('Nenhuma atividade escolhida encontrada no resultado de decidir_atividades_criar');
    }
    
    debug_log.push({
      timestamp: new Date().toISOString(),
      type: 'info',
      narrative: `Recebido ${chosenActivities.length} atividades da capability decidir_atividades_criar. Iniciando geraÃ§Ã£o de conteÃºdo.`,
      technical_data: { 
        activities_count: chosenActivities.length,
        activity_ids: chosenActivities.map(a => a.id)
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2. EXTRAIR CONTEXTO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const conversationContext = input.context.conversation_context || 
                                input.context.conversa || 
                                'Contexto educacional';
    const userObjective = input.context.user_objective || 
                          input.context.objetivo || 
                          'Criar atividades educacionais';
    const sessionId = input.context.session_id || input.execution_id;
    
    debug_log.push({
      timestamp: new Date().toISOString(),
      type: 'action',
      narrative: `Contexto extraÃ­do. Objetivo: "${userObjective.substring(0, 100)}...". Processando ${chosenActivities.length} atividades.`,
      technical_data: { 
        objective_length: userObjective.length,
        context_length: conversationContext.length,
        session_id: sessionId
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 3. PROCESSAR CADA ATIVIDADE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const results: GeneratedFieldsResult[] = [];
    const store = useChosenActivitiesStore.getState();
    
    // Inicializar DebugStore
    useDebugStore.getState().startCapability(CAPABILITY_ID, 'Gerando conteÃºdo V2');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // OBTER REFERÃŠNCIA DO ACTIVITY DEBUG STORE PARA LOGS POR ATIVIDADE
    // Este Ã© o store que alimenta o modal de debug individual de cada atividade
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const activityDebugStore = useActivityDebugStore.getState();
    
    for (let i = 0; i < chosenActivities.length; i++) {
      const activity = chosenActivities[i];
      
      console.error(`ğŸ”„ [V2] Processing activity ${i + 1}/${chosenActivities.length}: ${activity.titulo}`);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // INICIALIZAR DEBUG DA ATIVIDADE - Logs aparecerÃ£o no ActivityDebugModal
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      activityDebugStore.initActivity(activity.id, activity.titulo, activity.tipo);
      activityDebugStore.setStatus(activity.id, 'building');
      activityDebugStore.setProgress(activity.id, 0, 'Iniciando geraÃ§Ã£o de conteÃºdo');
      
      activityDebugStore.log(
        activity.id, 'action', 'GerarConteudoV2',
        `[${i + 1}/${chosenActivities.length}] Iniciando geraÃ§Ã£o para "${activity.titulo}"`,
        { 
          activity_type: activity.tipo, 
          index: i + 1, 
          total: chosenActivities.length,
          timestamp: new Date().toISOString()
        }
      );
      
      debug_log.push({
        timestamp: new Date().toISOString(),
        type: 'action',
        narrative: `[${i + 1}/${chosenActivities.length}] Gerando conteÃºdo para "${activity.titulo}" (${activity.tipo})`,
        technical_data: { 
          activity_id: activity.id,
          activity_type: activity.tipo,
          progress: Math.round((i / chosenActivities.length) * 100)
        }
      });
      
      // Atualizar status no store
      store.updateActivityStatus(activity.id, 'construindo', Math.round((i / chosenActivities.length) * 100));
      
      // Log de preparaÃ§Ã£o da chamada Ã  API
      activityDebugStore.setProgress(activity.id, 10, 'Preparando chamada Ã  API de IA');
      activityDebugStore.log(
        activity.id, 'api', 'GerarConteudoV2',
        'Chamando API de IA (Groq/Gemini) para gerar campos...',
        { model_cascade: ['llama3.3-70b', 'llama3.1-8b', 'gemini-1.5-flash'] }
      );
      
      // Gerar conteÃºdo usando a funÃ§Ã£o existente
      const result = await generateContentForActivity(
        activity,
        conversationContext,
        userObjective,
        undefined, // on_progress
        CAPABILITY_ID,
        'Gerando conteÃºdo V2'
      );
      
      results.push(result);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // LOGS DE DEBUG PÃ“S-GERAÃ‡ÃƒO - Mostrar resultado da API
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      activityDebugStore.setProgress(activity.id, 50, 'Processando resposta da IA');
      
      if (result.success) {
        // Log de sucesso da API
        activityDebugStore.log(
          activity.id, 'success', 'API-Response',
          `API retornou ${Object.keys(result.generated_fields).length} campos gerados`,
          { 
            fields_generated: Object.keys(result.generated_fields),
            sample_values: Object.fromEntries(
              Object.entries(result.generated_fields).slice(0, 3).map(([k, v]) => 
                [k, typeof v === 'string' ? v.substring(0, 100) + (v.length > 100 ? '...' : '') : v]
              )
            )
          }
        );
        
        // Sincronizar campos e atualizar store
        activityDebugStore.setProgress(activity.id, 60, 'Sincronizando campos com formulÃ¡rio');
        const syncedFields = syncSchemaToFormData(activity.tipo, result.generated_fields);
        const validation = validateSyncedFields(activity.tipo, syncedFields);
        
        // Log de validaÃ§Ã£o
        activityDebugStore.setProgress(activity.id, 70, 'Validando campos gerados');
        activityDebugStore.log(
          activity.id, 'info', 'Validation',
          `ValidaÃ§Ã£o: ${validation.filledFields.length} campos preenchidos, ${validation.missingFields.length} faltando`,
          { 
            filled_fields: validation.filledFields,
            missing_fields: validation.missingFields,
            is_valid: validation.valid
          }
        );
        
        store.updateActivityStatus(activity.id, 'aguardando', 100);
        store.setActivityGeneratedFields(activity.id, syncedFields);
        
        // ğŸ”¥ SALVAR NO LOCALSTORAGE PARA INTERFACE DE CONSTRUÃ‡ÃƒO
        // A interface verifica localStorage para preencher campos automaticamente
        activityDebugStore.setProgress(activity.id, 80, 'Salvando no localStorage');
        activityDebugStore.log(
          activity.id, 'action', 'LocalStorage',
          'Persistindo dados no localStorage...',
          { keys_to_save: ['generated_content_*', 'activity_*', 'constructed_*'] }
        );
        
        let savedKeys: string[] = [];
        if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {
          try {
            const storageKey = `generated_content_${activity.id}`;
            const storageData = {
              activity_id: activity.id,
              activity_type: activity.tipo,
              fields: syncedFields,
              original_fields: result.generated_fields,
              validation: validation,
              timestamp: new Date().toISOString()
            };
            localStorage.setItem(storageKey, JSON.stringify(storageData));
            savedKeys.push(storageKey);
            
            // TambÃ©m usar persistActivityToStorage para chaves adicionais
            const additionalKeys = persistActivityToStorage(
              activity.id,
              activity.tipo,
              activity.titulo,
              syncedFields,
              {
                description: activity.titulo,
                isPreGenerated: true,
                source: 'gerar_conteudo_atividades_v2'
              }
            );
            savedKeys = [...savedKeys, ...additionalKeys];
            
            console.log(`ğŸ’¾ [V2] Saved to localStorage: ${savedKeys.join(', ')}`);
          } catch (e) {
            console.warn(`âš ï¸ [V2] Failed to save to localStorage:`, e);
            activityDebugStore.log(
              activity.id, 'warning', 'LocalStorage',
              `Erro ao salvar no localStorage: ${e}`,
              { error: String(e) }
            );
          }
        }
        
        // Log de sucesso do localStorage
        activityDebugStore.log(
          activity.id, 'success', 'LocalStorage',
          `Dados persistidos em ${savedKeys.length} chaves do localStorage`,
          { saved_keys: savedKeys }
        );
        
        // Emitir evento para UI
        if (typeof window !== 'undefined') {
          window.dispatchEvent(new CustomEvent('agente-jota-fields-generated', {
            detail: {
              activity_id: activity.id,
              activity_type: activity.tipo,
              fields: syncedFields,
              original_fields: result.generated_fields,
              validation: validation
            }
          }));
        }
        
        // ğŸ“‹ CRIAR LOG DETALHADO COM CADA CAMPO E SEU VALOR
        const fieldDetails = Object.entries(syncedFields).map(([key, value]) => {
          const displayValue = typeof value === 'string' 
            ? (value.length > 100 ? value.substring(0, 100) + '...' : value)
            : JSON.stringify(value);
          return `â€¢ ${key}: ${displayValue}`;
        }).join('\n');
        
        debug_log.push({
          timestamp: new Date().toISOString(),
          type: 'discovery',
          narrative: `âœ… ConteÃºdo gerado para "${activity.titulo}": ${Object.keys(result.generated_fields).length} campos preenchidos\n\nğŸ“‹ CAMPOS GERADOS:\n${fieldDetails}`,
          technical_data: { 
            activity_id: activity.id,
            activity_type: activity.tipo,
            fields_count: Object.keys(result.generated_fields).length,
            generated_fields: result.generated_fields,
            synced_fields: syncedFields,
            validation_result: validation
          }
        });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MARCAR ATIVIDADE COMO CONCLUÃDA NO DEBUG STORE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        activityDebugStore.setProgress(activity.id, 100, 'Atividade construÃ­da com sucesso');
        activityDebugStore.markCompleted(activity.id);
        
      } else {
        // Log de erro da API
        activityDebugStore.log(
          activity.id, 'error', 'API-Response',
          `Falha na geraÃ§Ã£o: ${result.error}`,
          { error: result.error }
        );
        activityDebugStore.setError(activity.id, result.error || 'Erro desconhecido na geraÃ§Ã£o');
        
        store.updateActivityStatus(activity.id, 'erro', 0, result.error);
        
        debug_log.push({
          timestamp: new Date().toISOString(),
          type: 'error',
          narrative: `âŒ Falha ao gerar conteÃºdo para "${activity.titulo}": ${result.error}`,
          technical_data: { 
            activity_id: activity.id,
            error: result.error
          }
        });
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 4. CALCULAR RESULTADOS E RETORNAR
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const successCount = results.filter(r => r.success).length;
    const failCount = results.filter(r => !r.success).length;
    const elapsedTime = Date.now() - startTime;
    
    const totalFieldsGenerated = results.reduce((acc, r) => 
      acc + (r.success ? Object.keys(r.generated_fields || {}).length : 0), 0
    );
    
    debug_log.push({
      timestamp: new Date().toISOString(),
      type: 'action',
      narrative: `ğŸ GeraÃ§Ã£o concluÃ­da: ${successCount}/${chosenActivities.length} atividades processadas com sucesso. Total de campos: ${totalFieldsGenerated}`,
      technical_data: { 
        success_count: successCount,
        fail_count: failCount,
        total_fields: totalFieldsGenerated,
        duration_ms: elapsedTime
      }
    });
    
    // Encerrar capability no DebugStore
    useDebugStore.getState().endCapability(CAPABILITY_ID);
    
    // Emitir evento de conclusÃ£o
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('agente-jota-content-generation-complete', {
        detail: {
          session_id: sessionId,
          success_count: successCount,
          fail_count: failCount,
          results
        }
      }));
    }
    
    console.error(`âœ… [V2] COMPLETED: ${successCount}/${chosenActivities.length} activities, ${totalFieldsGenerated} fields in ${elapsedTime}ms`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PARTIAL SUCCESS: Se QUALQUER atividade foi gerada com sucesso, 
    // consideramos a capability como bem-sucedida e passamos para a prÃ³xima etapa.
    // Apenas se TODAS falharem Ã© que consideramos falha total.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const isPartialOrFullSuccess = successCount > 0;
    const successfulResults = results.filter(r => r.success);
    
    // Log do status de sucesso parcial
    if (failCount > 0 && successCount > 0) {
      console.error(`ğŸ“Š [V2] PARTIAL SUCCESS: ${successCount} succeeded, ${failCount} failed. Pipeline will CONTINUE with successful activities.`);
      
      debug_log.push({
        timestamp: new Date().toISOString(),
        type: 'warning',
        narrative: `âš ï¸ SUCESSO PARCIAL: ${failCount} atividades falharam, mas ${successCount} foram geradas com sucesso. O pipeline continuarÃ¡ com as atividades bem-sucedidas.`,
        technical_data: { 
          success_count: successCount,
          fail_count: failCount,
          failed_activities: results.filter(r => !r.success).map(r => ({ id: r.activity_id, error: r.error })),
          successful_activities: successfulResults.map(r => r.activity_id)
        }
      });
    }
    
    return {
      success: isPartialOrFullSuccess, // â† MUDANÃ‡A CRÃTICA: sucesso se pelo menos 1 atividade foi gerada
      capability_id: CAPABILITY_ID,
      execution_id: input.execution_id,
      timestamp: new Date().toISOString(),
      data: {
        generated_content: results,
        successful_content: successfulResults, // â† NOVO: apenas atividades bem-sucedidas para prÃ³xima etapa
        total_activities: chosenActivities.length,
        success_count: successCount,
        fail_count: failCount,
        total_fields_generated: totalFieldsGenerated,
        partial_success: failCount > 0 && successCount > 0 // â† NOVO: flag de sucesso parcial
      },
      error: failCount > 0 && successCount === 0 
        ? createCapabilityError(`Todas as ${failCount} atividades falharam na geraÃ§Ã£o de conteÃºdo`, 'critical') 
        : (failCount > 0 
            ? createCapabilityError(`${failCount} de ${chosenActivities.length} atividades falharam (${successCount} bem-sucedidas)`, 'low')
            : null),
      debug_log,
      metadata: {
        duration_ms: elapsedTime,
        retry_count: 0,
        data_source: 'ai_content_generation'
      }
    };
    
  } catch (error) {
    const elapsedTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    console.error(`âŒ [V2] ERROR: ${errorMessage}`);
    
    debug_log.push({
      timestamp: new Date().toISOString(),
      type: 'error',
      narrative: `âŒ ERRO CRÃTICO: ${errorMessage}`,
      technical_data: { 
        error: errorMessage,
        stack: error instanceof Error ? error.stack?.substring(0, 500) : undefined
      }
    });
    
    // Encerrar capability no DebugStore
    useDebugStore.getState().endCapability(CAPABILITY_ID);
    
    return {
      success: false,
      capability_id: CAPABILITY_ID,
      execution_id: input.execution_id,
      timestamp: new Date().toISOString(),
      data: null,
      error: createCapabilityError(errorMessage, 'critical'),
      debug_log,
      metadata: {
        duration_ms: elapsedTime,
        retry_count: 0,
        data_source: 'error'
      }
    };
  }
}
