import { ContextualizationData } from '../contextualization/ContextualizationCard';
import { ActionPlanItem } from '../actionplan/ActionPlanCard';
import schoolPowerActivities from '../data/schoolPowerActivities.json';
import activityFieldsSchema from '../data/activityFieldsSchema.json';
import { isActivityEligibleForTrilhas } from '../data/trilhasActivitiesConfig';
import { validateGeminiPlan } from './validateGeminiPlan';
import { processAIGeneratedContent } from './exerciseListProcessor';
import { sequenciaDidaticaPrompt } from '../prompts/sequenciaDidaticaPrompt';
import { validateSequenciaDidaticaData } from './sequenciaDidaticaValidator';

// Usar API Key centralizada
import { API_KEYS, API_URLS } from '@/config/apiKeys';

const GEMINI_API_KEY = API_KEYS.GEMINI;
const GEMINI_API_URL = API_URLS.GEMINI;

interface GeminiResponse {
  candidates?: {
    content?: {
      parts?: {
        text?: string;
      }[];
    };
  }[];
}

/**
 * Interface para resposta esperada da Gemini
 */
interface GeminiActivityResponse {
  id: string;
  title: string;
  description: string;
  personalizedTitle?: string;
  personalizedDescription?: string;
  duration: string;
  difficulty: string;
  category: string;
  type: string;
  customFields?: Record<string, string>;
}

/**
 * Constr√≥i o prompt otimizado para a API Gemini
 */
function buildGeminiPrompt(
  initialMessage: string,
  contextualizationData: ContextualizationData,
  allowedActivities: typeof schoolPowerActivities
): string {
  // Simplificar lista de atividades para economizar tokens
  const activitiesIds = allowedActivities
    .filter(a => a.enabled)
    .map(a => a.id); // Remover limita√ß√£o para permitir todas as atividades

    const activitiesString = allowedActivities
    .filter(a => a.enabled)
    .map(a => `"${a.id}"`)
    .join(', ');

      // Obter campos personalizados dispon√≠veis
    const getCustomFieldsForActivity = (activityId: string): string[] => {
      const schema = activityFieldsSchema[activityId as keyof typeof activityFieldsSchema];
      return schema?.fields || [];
    };

    // Criar string com informa√ß√µes sobre campos personalizados
    const customFieldsInfo = Object.keys(activityFieldsSchema).map(activityId => {
      const fields = getCustomFieldsForActivity(activityId);
      return `${activityId}: [${fields.join(', ')}]`;
    }).join('\n');

    // Adicionar informa√ß√µes espec√≠ficas para plano-aula
    const planoAulaSpecificInfo = `
ATEN√á√ÉO ESPECIAL PARA PLANO-AULA:
Os campos obrigat√≥rios s√£o EXATAMENTE:
- Tema ou T√≥pico Central
- Ano/S√©rie Escolar
- Componente Curricular
- Carga Hor√°ria
- Habilidades BNCC
- Objetivo Geral
- Materiais/Recursos
- Perfil da Turma
- Tipo de Aula
- Observa√ß√µes do Professor

USE EXATAMENTE ESTES NOMES DE CAMPOS para plano-aula!`;

    // Construir o prompt para a Gemini
    const prompt = `Voc√™ √© uma IA especializada em gerar planos de a√ß√£o educacionais para professores e coordenadores, seguindo e planejando exatamente o que eles pedem, e seguindo muito bem os requesitos, sendo super treinado, utilizando apenas as atividades poss√≠veis listadas abaixo.

DADOS COLETADOS DO USU√ÅRIO:
- Mensagem inicial: "${initialMessage}"
- Mat√©rias e temas: ${contextualizationData.materias || 'N√£o especificado'}
- P√∫blico-alvo: ${contextualizationData.publicoAlvo || 'N√£o especificado'}
- Restri√ß√µes: "${contextualizationData.restricoes || 'Nenhuma'}"
- Datas importantes: "${contextualizationData.datasImportantes || 'N√£o informado'}"
- Observa√ß√µes: ${contextualizationData.observacoes || 'Nenhuma'}

ATIVIDADES DISPON√çVEIS: ${activitiesString}

CAMPOS PERSONALIZADOS POR ATIVIDADE:
${customFieldsInfo}

${planoAulaSpecificInfo}

INSTRU√á√ïES CR√çTICAS:
1. ANALISE CUIDADOSAMENTE o pedido: "${initialMessage}"
2. IDENTIFIQUE TODAS as atividades espec√≠ficas mencionadas (ex: "Quadro Interativo", "Sequ√™ncia Did√°tica", etc.)
3. INCLUA OBRIGATORIAMENTE todas as atividades espec√≠ficas pedidas pelo usu√°rio
4. Complete com 3-5 atividades complementares relevantes ao contexto
5. Para CADA atividade, PREENCHA os customFields com informa√ß√µes ESPEC√çFICAS baseadas nos dados coletados
6. Use SEMPRE as mat√©rias informadas (${contextualizationData.materias}) para personalizar os campos
7. Use SEMPRE o p√∫blico-alvo informado (${contextualizationData.publicoAlvo}) nos campos relevantes
8. Retorne APENAS JSON v√°lido no formato especificado abaixo

FORMATO DE RESPOSTA (JSON):
[
  {
    "id": "id-da-atividade-exata-da-lista",
    "personalizedTitle": "T√≠tulo personalizado com a mat√©ria: ${contextualizationData.materias}",
    "personalizedDescription": "Descri√ß√£o detalhada personalizada baseada no contexto coletado",
    "customFields": {
      "campo1": "valor personalizado baseado nos dados coletados",
      "campo2": "valor personalizado baseado nos dados coletados"
    }
  }
]

IMPORTANTE: Retorne APENAS o JSON, sem texto adicional antes ou depois.`;

  return prompt;
}

/**
 * Makes the call to the Gemini API
 */
async function callGeminiAPI(prompt: string): Promise<string> {
  console.log('üöÄ Making call to Gemini API...');
  console.log('üîë API Key available:', !!GEMINI_API_KEY);
  console.log('üåê API URL:', GEMINI_API_URL);

  if (!GEMINI_API_KEY) {
    throw new Error('Gemini API Key is not configured');
  }

  try {
    const requestBody = {
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.3, // Reduced for more consistent responses
        topK: 20,
        topP: 0.8,
        maxOutputTokens: 32768, // Significantly increased to support 50+ activities
      }
    };

    console.log('üìã Request body:', JSON.stringify(requestBody, null, 2));

    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Error in Gemini API response:', response.status, errorText);
      throw new Error(`Gemini API Error: ${response.status} - ${errorText}`);
    }

    const data: GeminiResponse = await response.json();
    console.log('üì• Raw Gemini response:', data);

    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      console.error('‚ùå Empty response from Gemini API');
      throw new Error('Empty response from Gemini API');
    }

    console.log('‚úÖ Text generated by Gemini:', generatedText);
    return generatedText;

  } catch (error) {
    console.error('‚ùå Error calling Gemini API:', error);
    throw error;
  }
}

/**
 * Processes and cleans the Gemini response
 */
function parseGeminiResponse(responseText: string): GeminiActivityResponse[] {
  console.log('üîç Processing Gemini response...');

  try {
    // Removes markdown and other unwanted characters
    let cleanedText = responseText.trim();

    // Removes markdown code blocks if they exist
    cleanedText = cleanedText.replace(/```json\n?/g, '').replace(/```\n?/g, '');

    // Removes extra line breaks
    cleanedText = cleanedText.trim();

    console.log('üßπ Cleaned text:', cleanedText);

    // Attempts to parse the JSON
    const parsedActivities: GeminiActivityResponse[] = JSON.parse(cleanedText);

    if (!Array.isArray(parsedActivities)) {
      throw new Error('Response is not a valid array');
    }

    console.log('‚úÖ Parsed activities:', parsedActivities);
    return parsedActivities;

  } catch (error) {
    console.error('‚ùå Error parsing response:', error);
    console.error('üìù Original text:', responseText);
    throw new Error('Error processing AI response');
  }
}

/**
 * Converts Gemini response to ActionPlanItem format
 */
function convertToActionPlanItems(
  geminiActivities: GeminiActivityResponse[],
  allowedActivities: typeof schoolPowerActivities
): ActionPlanItem[] {
  console.log('üîÑ Converting activities to ActionPlanItems...');

  return geminiActivities.map(activity => {
    // Finds the original activity in the JSON for validation
    const originalActivity = allowedActivities.find(a => a.id === activity.id);

    if (!originalActivity) {
      console.warn(`‚ö†Ô∏è Activity not found: ${activity.id}`);
      return null;
    }

    const actionPlanItem: ActionPlanItem = {
      id: activity.id,
      title: activity.personalizedTitle || activity.title || originalActivity.name,
      description: activity.personalizedDescription || activity.description || originalActivity.description,
      approved: false,
      isTrilhasEligible: isActivityEligibleForTrilhas(activity.id),
      customFields: activity.customFields || {}
    };

    console.log('‚úÖ ActionPlanItem created:', actionPlanItem);
    return actionPlanItem;
  }).filter((item): item is ActionPlanItem => item !== null);
}

/**
 * Generates a fallback plan if the API fails
 */
function generateFallbackPlan(
  initialMessage: string,
  contextualizationData: ContextualizationData
): ActionPlanItem[] {
  console.log('üîÑ Generating fallback plan...');

  // Selects relevant activities based on keywords
  const keywords = [
    initialMessage.toLowerCase(),
    contextualizationData.subjects?.toLowerCase() || '',
    contextualizationData.audience?.toLowerCase() || '',
  ].join(' ');

  let relevantActivities = schoolPowerActivities.filter(activity => {
    return activity.enabled && (
      keywords.includes('prova') && activity.tags.includes('avalia√ß√£o') ||
      keywords.includes('exercicio') && activity.tags.includes('exerc√≠cios') ||
      keywords.includes('resumo') && activity.tags.includes('resumo') ||
      keywords.includes('jogo') && activity.tags.includes('jogos') ||
      keywords.includes('atividade') && activity.tags.includes('atividades')
    );
  });

  // If no specific activities are found, uses the most popular ones
  if (relevantActivities.length === 0) {
    relevantActivities = schoolPowerActivities.filter(activity =>
      activity.enabled && [
        'lista-exercicios',
        'resumo',
        'prova',
        'atividades-matematica',
        'plano-aula',
        'mapa-mental',
        'jogos-educativos',
        'atividades-ortografia-alfabeto',
        'caca-palavras',
        'projeto',
        'slides-didaticos',
        'palavra-cruzada',
        'desenho-simetrico',
        'sequencia-didatica',
        'atividades-contos-infantis'
      ].includes(activity.id)
    );
  }

  // Removes limit to allow generation of more activities as needed
  // relevantActivities = relevantActivities.slice(0, 35);

  const fallbackPlan: ActionPlanItem[] = relevantActivities.map(activity => ({
    id: activity.id,
    title: `${activity.name} - ${contextualizationData.subjects || 'Personalized'}`,
    description: `${activity.description} Based on: "${initialMessage.substring(0, 100)}..."`,
    approved: false
  }));

  console.log('‚úÖ Fallback plan generated:', fallbackPlan);
  return fallbackPlan;
}

/**
 * Main function to generate a personalized plan
 */
export async function generatePersonalizedPlan(
  initialMessage: string,
  contextualizationData: ContextualizationData
): Promise<ActionPlanItem[]> {
  console.log('ü§ñ Starting personalized plan generation...');
  console.log('üìù Input data:', { initialMessage, contextualizationData });

  try {
    // Validation of input data
    if (!initialMessage?.trim()) {
      throw new Error('Initial message is mandatory');
    }

    if (!contextualizationData) {
      throw new Error('Contextualization data is mandatory');
    }

    // Loads allowed activities
    console.log('üìö Available activities:', schoolPowerActivities.length);

    // Builds the structured prompt
    const prompt = buildGeminiPrompt(initialMessage, contextualizationData, schoolPowerActivities);
    console.log('üìù Prompt built successfully');

    // Calls the Gemini API
    const geminiResponse = await callGeminiAPI(prompt);

    // Processes the response
    const generatedActivities = parseGeminiResponse(geminiResponse);

    // Validates the returned activities
    const validatedActivities = await validateGeminiPlan(generatedActivities, schoolPowerActivities);

    // Processar cada atividade e extrair custom fields
    const actionPlanItems = validatedActivities.map(activityData => {
        console.log(`üîÑ Processing activity: ${activityData.id}`);

        // Valida√ß√£o espec√≠fica para Sequ√™ncia Did√°tica
        if (activityData.id === 'sequencia-didatica') {
          console.log('üéØ Aplicando valida√ß√£o espec√≠fica para Sequ√™ncia Did√°tica');
          const validation = validateSequenciaDidaticaData(activityData);

          if (!validation.isValid) {
            console.error('‚ùå Sequ√™ncia Did√°tica inv√°lida:', validation.errors);
            // Use fallback data for invalid Sequ√™ncia Did√°tica
            activityData = {
              ...activityData,
              customFields: {
                'T√≠tulo do Tema / Assunto': activityData.personalizedTitle || 'Sequ√™ncia Did√°tica Personalizada',
                'Ano / S√©rie': '9¬∫ Ano',
                'Disciplina': 'Portugu√™s',
                'BNCC / Compet√™ncias': 'EF89LP01, EF89LP02',
                'P√∫blico-alvo': 'Alunos do Ensino Fundamental',
                'Objetivos de Aprendizagem': 'Desenvolver habilidades espec√≠ficas',
                'Quantidade de Aulas': '4',
                'Quantidade de Diagn√≥sticos': '1',
                'Quantidade de Avalia√ß√µes': '2',
                'Cronograma': 'Cronograma a ser definido'
              }
            };
          } else if (validation.processedData) {
            activityData = validation.processedData;
          }
        }

        // Extract custom fields (all fields except standard ones)
        const customFields: Record<string, string> = {};
        const standardFields = ['id', 'title', 'description', 'duration',
                               'difficulty', 'category', 'type', 'personalizedTitle', 'personalizedDescription'];

        Object.keys(activityData).forEach(key => {
            if (!standardFields.includes(key) && typeof activityData[key] === 'string') {
                customFields[key] = activityData[key];
            }
        });

        // Garantir que customFields seja um objeto v√°lido
        const finalCustomFields = activityData.customFields || customFields || {};

        // Para Sequ√™ncia Did√°tica, garantir que todos os valores sejam strings
        if (activityData.id === 'sequencia-didatica') {
          Object.keys(finalCustomFields).forEach(key => {
            if (typeof finalCustomFields[key] !== 'string') {
              finalCustomFields[key] = String(finalCustomFields[key]);
            }
          });
        }

        console.log(`‚úÖ Custom fields extracted for ${activityData.id}:`, finalCustomFields);

        const activity = {
          id: activityData.id,
          title: activityData.title,
          description: activityData.description,
          duration: activityData.duration,
          difficulty: activityData.difficulty,
          category: activityData.category,
          type: activityData.type,
          customFields: finalCustomFields,
          approved: true,
          isTrilhasEligible: true,
          isBuilt: false, // Will be marked as true after automatic build
          builtAt: null
        };

        console.log(`‚úÖ Complete ActionPlanItem created for ${activityData.id}:`, activity);
        return activity;
    });

    if (validatedActivities.length === 0) {
      console.warn('‚ö†Ô∏è No valid activities returned, using fallback');
      return generateFallbackPlan(initialMessage, contextualizationData);
    }

    console.log(`‚úÖ Total validated activities generated: ${validatedActivities.length}`);

    // Converts to ActionPlanItems
    const actionPlanItems2 = convertToActionPlanItems(validatedActivities, schoolPowerActivities);

    console.log('‚úÖ Personalized plan generated successfully:', actionPlanItems);
    return actionPlanItems;

  } catch (error) {
    console.error('‚ùå Error generating personalized plan:', error);

    // In case of error, returns the fallback plan
    console.log('üîÑ Using fallback plan due to error');
    return generateFallbackPlan(initialMessage, contextualizationData);
  }
}