import schoolPowerActivities from '../data/schoolPowerActivities.json';

/**
 * Interface para atividade retornada pela Gemini
 */
interface GeminiActivity {
  id: string;
  title?: string;
  description?: string;
  personalizedTitle?: string;
  personalizedDescription?: string;
  [key: string]: any;
}

/**
 * Interface para atividade v√°lida
 */
interface ValidatedActivity {
  id: string;
  title: string;
  description: string;
  personalizedTitle?: string;
  personalizedDescription?: string;
}

/**
 * Relat√≥rio de valida√ß√£o
 */
interface ValidationReport {
  total: number;
  valid: number;
  invalid: number;
  duplicates: number;
  validActivities: ValidatedActivity[];
  invalidIds: string[];
  duplicateIds: string[];
}

/**
 * Valida se um ID de atividade existe na lista permitida
 */
function isValidActivityId(activityId: string, allowedActivities: typeof schoolPowerActivities): boolean {
  if (!activityId || typeof activityId !== 'string') {
    return false;
  }

  const normalizedId = activityId.trim().toLowerCase();

  return allowedActivities.some(activity => {
    const activityNormalizedId = activity.id.toLowerCase();
    return (
      (activityNormalizedId === normalizedId || 
       activity.id === activityId.trim()) && 
      activity.enabled
    );
  });
}

/**
 * Busca uma atividade pela ID na lista permitida
 */
function findActivityById(activityId: string, allowedActivities: typeof schoolPowerActivities) {
  return allowedActivities.find(activity => 
    activity.id === activityId.trim().toLowerCase() && activity.enabled
  );
}

/**
 * Valida uma √∫nica atividade retornada pela Gemini
 */
function validateSingleActivity(
  activity: GeminiActivity, 
  allowedActivities: typeof schoolPowerActivities
): ValidatedActivity | null {
  console.log('üîç Validando atividade:', activity);

  // Verifica se a atividade tem ID
  if (!activity.id) {
    console.warn('‚ö†Ô∏è Atividade sem ID ignorada:', activity);
    return null;
  }

  // Normaliza o ID
  const normalizedId = activity.id.trim().toLowerCase();

  // Verifica se o ID √© v√°lido
  if (!isValidActivityId(normalizedId, allowedActivities)) {
    console.warn(`‚ùå ID de atividade inv√°lido: ${normalizedId}`);
    return null;
  }

  // Busca a atividade original
  const originalActivity = findActivityById(normalizedId, allowedActivities);

  if (!originalActivity) {
    console.warn(`‚ùå Atividade n√£o encontrada: ${normalizedId}`);
    return null;
  }

  // Cria atividade validada
  const validatedActivity: ValidatedActivity = {
    id: originalActivity.id,
    title: activity.personalizedTitle || activity.title || originalActivity.name,
    description: activity.personalizedDescription || activity.description || originalActivity.description,
  };

  // Adiciona campos de personaliza√ß√£o se existirem
  if (activity.personalizedTitle) {
    validatedActivity.personalizedTitle = activity.personalizedTitle;
  }

  if (activity.personalizedDescription) {
    validatedActivity.personalizedDescription = activity.personalizedDescription;
  }

  console.log('‚úÖ Atividade validada:', validatedActivity);
  return validatedActivity;
}

/**
 * Remove atividades duplicadas mantendo a primeira ocorr√™ncia
 */
function removeDuplicates(activities: ValidatedActivity[]): { 
  uniqueActivities: ValidatedActivity[], 
  duplicateIds: string[] 
} {
  console.log('üîÑ Removendo duplicatas...');

  const seen = new Set<string>();
  const uniqueActivities: ValidatedActivity[] = [];
  const duplicateIds: string[] = [];

  for (const activity of activities) {
    if (seen.has(activity.id)) {
      duplicateIds.push(activity.id);
      console.warn(`‚ö†Ô∏è Atividade duplicada removida: ${activity.id}`);
    } else {
      seen.add(activity.id);
      uniqueActivities.push(activity);
    }
  }

  console.log(`‚úÖ Remo√ß√£o de duplicatas conclu√≠da: ${uniqueActivities.length} √∫nicas, ${duplicateIds.length} removidas`);
  return { uniqueActivities, duplicateIds };
}

/**
 * Gera relat√≥rio detalhado da valida√ß√£o
 */
function generateValidationReport(
  originalActivities: GeminiActivity[],
  validActivities: ValidatedActivity[],
  invalidIds: string[],
  duplicateIds: string[]
): ValidationReport {
  const report: ValidationReport = {
    total: originalActivities.length,
    valid: validActivities.length,
    invalid: invalidIds.length,
    duplicates: duplicateIds.length,
    validActivities,
    invalidIds,
    duplicateIds
  };

  console.log('üìä Relat√≥rio de valida√ß√£o:', {
    total: report.total,
    valid: report.valid,
    invalid: report.invalid,
    duplicates: report.duplicates
  });

  return report;
}

/**
 * Valida o plano completo retornado pela Gemini
 */
export async function validateGeminiPlan(geminiActivities: any[], schoolPowerActivities: any[]): Promise<any[]> {
  console.log('üîç Iniciando valida√ß√£o do plano da Gemini...');
  console.log('üìä Dados de entrada:', {
    activitiesCount: geminiActivities?.length || 0,
    allowedCount: schoolPowerActivities?.length || 0,
    maxProcessing: 100 // Aumentando limite de processamento
  });

  const validActivities: any[] = [];

  if (!geminiActivities || !Array.isArray(geminiActivities) || geminiActivities.length === 0) {
    console.warn('‚ö†Ô∏è Nenhuma atividade foi fornecida pela Gemini');
    return [];
  }

  console.log('üöÄ Processando at√© 100 atividades da Gemini...');

  const invalidIds: string[] = [];

  // Valida cada atividade individualmente
  for (let i = 0; i < geminiActivities.length; i++) {
    const activity = geminiActivities[i];
    console.log(`üîç Validando atividade ${i + 1}/${geminiActivities.length}:`, activity);

    const validatedActivity = validateSingleActivity(activity, schoolPowerActivities);

    if (validatedActivity) {
      validActivities.push(validatedActivity);
    } else {
      invalidIds.push(activity.id || `atividade-${i}`);
    }
  }

  // Remove duplicatas
  const { uniqueActivities, duplicateIds } = removeDuplicates(validActivities);

  // Gera relat√≥rio final
  const report = generateValidationReport(
    geminiActivities,
    uniqueActivities,
    invalidIds,
    duplicateIds
  );

  // Log de relat√≥rio detalhado
  console.log('üìã Relat√≥rio final de valida√ß√£o:');
  console.log(`‚úÖ Total processado: ${report.total}`);
  console.log(`‚úÖ Atividades v√°lidas: ${report.valid}`);
  console.log(`‚ùå Atividades inv√°lidas: ${report.invalid}`);
  console.log(`üîÑ Duplicatas removidas: ${report.duplicates}`);

  if (report.invalidIds.length > 0) {
    console.warn('‚ùå IDs inv√°lidos encontrados:', report.invalidIds);
  }

  if (report.duplicateIds.length > 0) {
    console.warn('üîÑ IDs duplicados removidos:', report.duplicateIds);
  }

  // Alerta se muitas atividades foram rejeitadas
  if (report.valid === 0 && report.total > 0) {
    console.error('‚ùå CR√çTICO: Todas as atividades foram rejeitadas na valida√ß√£o!');
    console.error('üìù Atividades originais:', geminiActivities);
    console.error('üìã IDs permitidos:', schoolPowerActivities.map(a => a.id));
  } else if (report.valid < report.total / 2) {
    console.warn('‚ö†Ô∏è ATEN√á√ÉO: Mais da metade das atividades foram rejeitadas');
  }

  console.log('‚úÖ Valida√ß√£o conclu√≠da com sucesso');
  console.log('üìä Atividades aprovadas:', uniqueActivities.map(a => ({ id: a.id, title: a.title })));

  return uniqueActivities;
}

/**
 * Valida apenas os IDs de atividades (fun√ß√£o auxiliar)
 */
export function validateActivityIds(activityIds: string[]): {
  validIds: string[];
  invalidIds: string[];
} {
  console.log('üîç Validando IDs de atividades:', activityIds);

  const validIds: string[] = [];
  const invalidIds: string[] = [];

  for (const id of activityIds) {
    if (isValidActivityId(id, schoolPowerActivities)) {
      validIds.push(id.trim().toLowerCase());
    } else {
      invalidIds.push(id);
    }
  }

  console.log('‚úÖ Valida√ß√£o de IDs conclu√≠da:', { validIds, invalidIds });
  return { validIds, invalidIds };
}

/**
 * Obt√©m lista de IDs de atividades v√°lidas (fun√ß√£o auxiliar)
 */
export function getValidActivityIds(): string[] {
  return schoolPowerActivities
    .filter(activity => activity.enabled)
    .map(activity => activity.id);
}

/**
 * Verifica se existe pelo menos uma atividade v√°lida
 */
export function hasValidActivities(activities: GeminiActivity[]): boolean {
  return activities.some(activity => 
    activity.id && isValidActivityId(activity.id, schoolPowerActivities)
  );
}