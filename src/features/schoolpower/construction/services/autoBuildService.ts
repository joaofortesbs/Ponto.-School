
import { ConstructionActivity } from '../types';

export interface AutoBuildProgress {
  current: number;
  total: number;
  currentActivity: string;
  status: 'idle' | 'running' | 'completed' | 'error';
  errors: string[];
}

export class AutoBuildService {
  private static instance: AutoBuildService;
  private progressCallback?: (progress: AutoBuildProgress) => void;
  private onActivityBuilt?: (activityId: string) => void;

  private constructor() {}

  static getInstance(): AutoBuildService {
    if (!AutoBuildService.instance) {
      AutoBuildService.instance = new AutoBuildService();
    }
    return AutoBuildService.instance;
  }

  setProgressCallback(callback: (progress: AutoBuildProgress) => void) {
    this.progressCallback = callback;
  }

  setOnActivityBuilt(callback: (activityId: string) => void) {
    this.onActivityBuilt = callback;
  }

  private updateProgress(progress: Partial<AutoBuildProgress>) {
    if (this.progressCallback) {
      this.progressCallback(progress as AutoBuildProgress);
    }
  }

  private prepareActivityFormData(activity: ConstructionActivity): any {
    console.log(`üéØ Preparando dados do formul√°rio para: ${activity.title}`);

    // Usar dados originais da atividade aprovada se dispon√≠vel
    const originalData = activity.originalData || {};
    
    // Criar formData seguindo exatamente o mesmo padr√£o do modal individual
    const formData = {
      typeId: activity.id,
      title: activity.title || originalData.title || '',
      description: activity.description || originalData.description || '',
      // Adicionar campos personalizados baseados no tipo de atividade
      disciplina: originalData.disciplina || originalData.subject || activity.customFields?.disciplina || 'Matem√°tica',
      nivel: originalData.nivel || originalData.level || activity.customFields?.nivel || 'Ensino M√©dio',
      duracao: originalData.duracao || originalData.duration || activity.customFields?.duracao || '50 minutos',
      objetivo: originalData.objetivo || originalData.objective || activity.customFields?.objetivo || activity.description,
      conteudo: originalData.conteudo || originalData.content || activity.customFields?.conteudo || activity.description,
      metodologia: originalData.metodologia || originalData.methodology || activity.customFields?.metodologia || 'Pr√°tica',
      recursos: originalData.recursos || originalData.resources || activity.customFields?.recursos || 'Quadro, computador',
      avaliacao: originalData.avaliacao || originalData.evaluation || activity.customFields?.avaliacao || 'Participa√ß√£o e exerc√≠cios',
      ...activity.customFields,
      ...originalData
    };

    console.log('üìù FormData preparado:', formData);
    return formData;
  }

  private async generateActivityWithRealLogic(activity: ConstructionActivity): Promise<void> {
    console.log(`üéØ Usando l√≥gica REAL de gera√ß√£o para: ${activity.title}`);

    try {
      // Preparar dados do formul√°rio usando mesma l√≥gica do modal
      const formData = this.prepareActivityFormData(activity);

      console.log('üìù Dados do formul√°rio para gera√ß√£o:', formData);

      // Preparar dados de contexto para a IA (mesmo formato usado no modal)
      const contextData = {
        // Dados em portugu√™s para o prompt
        titulo: formData.title || 'Atividade',
        descricao: formData.description || '',
        disciplina: formData.subject || 'Portugu√™s',
        tema: formData.theme || 'Conte√∫do Geral',
        anoEscolaridade: formData.schoolYear || '6¬∫ ano',
        numeroQuestoes: parseInt(formData.numberOfQuestions || '10'),
        nivelDificuldade: formData.difficultyLevel || 'M√©dio',
        modeloQuestoes: formData.questionModel || 'M√∫ltipla escolha e complete as frases',
        fontes: formData.sources || 'Gram√°tica b√°sica para concursos e exerc√≠cios online Brasil Escola',
        objetivos: formData.objectives || '',
        materiais: formData.materials || '',
        instrucoes: formData.instructions || '',
        tempoLimite: formData.timeLimit || '',
        contextoAplicacao: formData.context || '',

        // Dados alternativos em ingl√™s para compatibilidade
        title: formData.title,
        description: formData.description,
        subject: formData.subject,
        theme: formData.theme,
        schoolYear: formData.schoolYear,
        numberOfQuestions: formData.numberOfQuestions,
        difficultyLevel: formData.difficultyLevel,
        questionModel: formData.questionModel,
        sources: formData.sources,
        objectives: formData.objectives,
        materials: formData.materials,
        instructions: formData.instructions,
        timeLimit: formData.timeLimit,
        context: formData.context
      };

      console.log('üìä Context data preparado para IA:', contextData);

      // Usar a mesma fun√ß√£o que o modal usa para gerar conte√∫do
      const { generateActivityContent } = await import('../api/generateActivity');
      const result = await generateActivityContent(activity.type || 'lista-exercicios', contextData);

      if (result) {
        // Processar resultado da mesma forma que o modal
        const generatedContent = {
          ...result,
          generatedAt: new Date().toISOString(),
          formData: formData,
          isBuilt: true,
          builtAt: new Date().toISOString(),
          activityType: activity.type,
          activityId: activity.id
        };

        // Salvar conte√∫do gerado
        localStorage.setItem(`activity_${activity.id}`, JSON.stringify(generatedContent));

        // Atualizar status de atividades constru√≠das
        const constructedActivities = JSON.parse(localStorage.getItem('constructedActivities') || '{}');
        constructedActivities[activity.id] = {
          isBuilt: true,
          builtAt: new Date().toISOString(),
          formData: formData,
          content: result.content
        };
        localStorage.setItem('constructedActivities', JSON.stringify(constructedActivities));

        // Marcar atividade como constru√≠da
        activity.isBuilt = true;
        activity.builtAt = new Date().toISOString();
        activity.progress = 100;
        activity.status = 'completed';

        // Callback de atividade constru√≠da
        if (this.onActivityBuilt) {
          this.onActivityBuilt(activity.id);
        }

        console.log(`‚úÖ Atividade constru√≠da com sucesso usando l√≥gica REAL: ${activity.title}`);
      } else {
        throw new Error(result.error || 'Erro na gera√ß√£o da atividade');
      }

    } catch (error) {
      console.error(`‚ùå Erro na gera√ß√£o REAL da atividade ${activity.title}:`, error);
      throw error;
    }
  }

  async buildAllActivities(activities: ConstructionActivity[]): Promise<void> {
    console.log('üöÄ Iniciando constru√ß√£o autom√°tica com l√≥gica REAL de', activities.length, 'atividades');
    console.log('üìã Lista de atividades para construir:', activities.map(a => ({ id: a.id, title: a.title, isBuilt: a.isBuilt, status: a.status })));

    const errors: string[] = [];
    let processedCount = 0;

    this.updateProgress({
      current: 0,
      total: activities.length,
      currentActivity: 'Iniciando...',
      status: 'running',
      errors: []
    });

    for (let i = 0; i < activities.length; i++) {
      const activity = activities[i];

      // Pular atividades j√° constru√≠das
      if (activity.isBuilt || activity.status === 'completed') {
        console.log(`‚è≠Ô∏è Pulando atividade j√° constru√≠da: ${activity.title}`);
        processedCount++;
        this.updateProgress({
          current: processedCount,
          total: activities.length,
          currentActivity: `Pulando: ${activity.title}`,
          status: 'running',
          errors
        });
        continue;
      }

      this.updateProgress({
        current: processedCount,
        total: activities.length,
        currentActivity: `Construindo: ${activity.title}`,
        status: 'running',
        errors
      });

      console.log(`üî® Construindo com l√≥gica REAL (${i + 1}/${activities.length}): ${activity.title}`);

      try {
        // Usar a l√≥gica REAL de gera√ß√£o (mesma do modal individual)
        await this.generateActivityWithRealLogic(activity);

        processedCount++;
        console.log(`‚úÖ Atividade ${i + 1}/${activities.length} constru√≠da com L√ìGICA REAL: ${activity.title}`);

        this.updateProgress({
          current: processedCount,
          total: activities.length,
          currentActivity: `Conclu√≠da: ${activity.title}`,
          status: 'running',
          errors
        });

        // Pequeno delay para n√£o sobrecarregar a API
        await new Promise(resolve => setTimeout(resolve, 2000));

      } catch (error) {
        console.error(`‚ùå Erro ao construir atividade ${activity.title}:`, error);
        const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';
        errors.push(`Erro em "${activity.title}": ${errorMessage}`);
        
        processedCount++;
        this.updateProgress({
          current: processedCount,
          total: activities.length,
          currentActivity: `Erro em: ${activity.title}`,
          status: 'running',
          errors
        });
      }
    }

    // Progresso final
    this.updateProgress({
      current: activities.length,
      total: activities.length,
      currentActivity: 'Processo conclu√≠do!',
      status: errors.length > 0 ? 'error' : 'completed',
      errors
    });

    console.log('üéâ Processo de constru√ß√£o autom√°tica finalizado com l√≥gica REAL');
    console.log(`üìä Resultado: ${activities.length - errors.length}/${activities.length} atividades constru√≠das com sucesso`);

    if (errors.length > 0) {
      console.warn('‚ö†Ô∏è Alguns erros ocorreram:', errors);
      // N√£o fazer throw para permitir que atividades constru√≠das com sucesso sejam salvas
    }
  }
}

export const autoBuildService = AutoBuildService.getInstance();
